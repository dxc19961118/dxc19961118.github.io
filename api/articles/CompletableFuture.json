{"title":"CompletableFuture","uid":"894a6ea288f6d047d2f12049a353fbe7","slug":"CompletableFuture","date":"2023-05-28T14:09:53.000Z","updated":"2023-05-28T14:09:53.000Z","comments":true,"path":"api/articles/CompletableFuture.json","keywords":null,"cover":"/images/log.jpg","content":"<h2 id=\"CompletableFuture\"><a href=\"#CompletableFuture\" class=\"headerlink\" title=\"CompletableFuture\"></a>CompletableFuture</h2><p>在JDK8之前，我们使用的Java多线程，主要是 <strong>Thread+Runnable</strong> 来完成，但是这种方式有个弊端就是没有返回值。如果想要返回值怎么办呢，大多数人就会想到 <strong><code>Callable + Thread</code></strong> 的方式来获取到返回值。</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class TestCompletable &#123;\n    public static void main(String[] args) throws Exception &#123;\n        FutureTask &lt;String&gt; task &#x3D; new FutureTask((Callable &lt;String&gt; )() - &gt; &#123;\n            TimeUnit.SECONDS.sleep(2);\n            return UUID.randomUUID().toString();\n        &#125;);\n        new Thread(task).start();\n        String s &#x3D; task.get();\n        System.out.println(s);\n    &#125;</code></pre>\n\n<p>当调用代码 <code>String s = task.get();</code> 的时候，当前主线程是阻塞状态，另一种方式获取到返回值就是通过轮询 <code>task.isDone()</code> 来判断任务是否做完获取返回值。因此JDK8之前提供的异步能力有一定的局限性：</p>\n<ul>\n<li>Runnable+Thread虽然提供了多线程的能力但是没有返回值。</li>\n<li>Callable+Thread的方法提供多线程和返回值的能力但是在获取返回值的时候会阻塞主线程。</li>\n</ul>\n<h3 id=\"1-CompletableFuture与Future的关系\"><a href=\"#1-CompletableFuture与Future的关系\" class=\"headerlink\" title=\"1 CompletableFuture与Future的关系\"></a>1 CompletableFuture与Future的关系</h3><p> <strong><code>CompletableFuture</code></strong> 实现了 <strong><code>Future</code></strong> 接口和 <strong><code>CompletionStage</code></strong> 。因此 CompletableFuture是对 Futrue的功能增强包含了Future的功能。从继承的另一个 <strong><code>CompletionStage</code></strong> 的名称来看完成阶段性的接口。这个怎么理解，这个就是下面要说的CompletableFuture本质。</p>\n<p><code>CompletableFuture</code>是对<code>Future</code>的扩展和增强。<code>CompletableFuture</code>实现了<code>Future</code>接口，并在此基础上进行了丰富的扩展，完美弥补了<code>Future</code>的局限性，<strong>同时<code>CompletableFuture</code>实现了对任务编排的能力</strong>。借助这项能力，可以轻松地组织不同任务的运行顺序、规则以及方式。从某种程度上说，这项能力是它的核心能力。而在以往，虽然通过<code>CountDownLatch</code>等工具类也可以实现任务的编排，但需要复杂的逻辑处理，不仅耗费精力且难以维护。</p>\n<h3 id=\"2-CompletableFuture本质\"><a href=\"#2-CompletableFuture本质\" class=\"headerlink\" title=\"2 CompletableFuture本质\"></a>2 CompletableFuture本质</h3><p>CompletableFuture本质是什么？笔者的理解CompletableFuture相当于一个Task编排工具。为什么这么说依据如下：</p>\n<ul>\n<li>CompletableFuture#completedFuture、CompletableFuture#whenComplete 这些方法都是对某一个阶段Task计算完成然后进行下一步的动作。将下一个Task和前一个Task进行编排。</li>\n<li>CompletableFuture#handle 将Task串连起来</li>\n</ul>\n<p>这些动作其实就是Task编排。</p>\n<p><strong>CompletableFuture具有Future的功能：</strong></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class TestCompletable &#123;\n    public static void main(String[] args) throws Exception &#123;\n            FutureTask &lt; String &gt; futureTask &#x3D; new FutureTask(() - &gt; &#123;\n                Thread.sleep(2000);\n                return UUID.randomUUID().toString();\n            &#125;);\n            new Thread(futureTask).start();\n            CompletableFuture &lt; String &gt; future &#x3D; CompletableFuture.completedFuture(futureTask.get(); \n            String uuid &#x3D; future.get(); System.out.println(uuid);                      </code></pre>\n\n<h3 id=\"3-功能\"><a href=\"#3-功能\" class=\"headerlink\" title=\"3 功能\"></a>3 功能</h3><h4 id=\"依赖关系\"><a href=\"#依赖关系\" class=\"headerlink\" title=\"依赖关系\"></a>依赖关系</h4><ul>\n<li><code>thenApply()</code>：把前面任务的执行结果，交给后面的<code>Function</code></li>\n<li><code>thenCompose()</code>：用来连接两个有依赖关系的任务，结果由第二个任务返回</li>\n</ul>\n<h4 id=\"and集合关系\"><a href=\"#and集合关系\" class=\"headerlink\" title=\"and集合关系\"></a>and集合关系</h4><ul>\n<li><code>thenCombine()</code>：合并任务，有返回值</li>\n<li><code>thenAccepetBoth()</code>：两个任务执行完成后，将结果交给<code>thenAccepetBoth</code>处理，无返回值</li>\n<li><code>runAfterBoth()</code>：两个任务都执行完成后，执行下一步操作(<code>Runnable</code>类型任务)</li>\n</ul>\n<h4 id=\"or聚合关系\"><a href=\"#or聚合关系\" class=\"headerlink\" title=\"or聚合关系\"></a>or聚合关系</h4><ul>\n<li><code>applyToEither()</code>：两个任务哪个执行的快，就使用哪一个结果，有返回值</li>\n<li><code>acceptEither()</code>：两个任务哪个执行的快，就消费哪一个结果，无返回值</li>\n<li><code>runAfterEither()</code>：任意一个任务执行完成，进行下一步操作(<code>Runnable</code>类型任务)</li>\n</ul>\n<h4 id=\"并行执行\"><a href=\"#并行执行\" class=\"headerlink\" title=\"并行执行\"></a>并行执行</h4><ul>\n<li><code>allOf()</code>：当所有给定的 CompletableFuture 完成时，返回一个新的 CompletableFuture</li>\n<li><code>anyOf()</code>：当任何一个给定的<code>CompletablFuture</code>完成时，返回一个新的CompletableFuture</li>\n</ul>\n<h4 id=\"结果处理\"><a href=\"#结果处理\" class=\"headerlink\" title=\"结果处理\"></a>结果处理</h4><ul>\n<li><p><code>whenComplete</code>：当任务完成时，将使用结果(或 null)和此阶段的异常(或 null如果没有)执行给定操作</p>\n</li>\n<li><p><code>exceptionally</code>：返回一个新的<code>CompletableFuture</code>，当前面的<code>CompletableFuture</code>完成时，它也完成，当它异常完成时，给定函数的异常触发这个<code>CompletableFuture</code>的完成</p>\n<h4 id=\"异步操作\"><a href=\"#异步操作\" class=\"headerlink\" title=\"异步操作\"></a>异步操作</h4><p><code>CompletableFuture</code>提供了四个静态方法来创建一个异步操作：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public static CompletableFuture&lt;Void&gt; runAsync(Runnable runnable)\npublic static CompletableFuture&lt;Void&gt; runAsync(Runnable runnable, Executor executor)\npublic static &lt;U&gt; CompletableFuture&lt;U&gt; supplyAsync(Supplier&lt;U&gt; supplier)\npublic static &lt;U&gt; CompletableFuture&lt;U&gt; supplyAsync(Supplier&lt;U&gt; supplier, Executor executor)</code></pre>\n\n<p>这四个方法的区别：</p>\n<ul>\n<li><code>runAsync()</code> 以<code>Runnable</code>函数式接口类型为参数，没有返回结果，<code>supplyAsync()</code> 以<code>Supplier</code>函数式接口类型为参数，返回结果类型为U；Supplier接口的 <code>get()</code>是有返回值的(会阻塞)</li>\n<li>使用没有指定<code>Executor</code>的方法时，内部使用<code>ForkJoinPool.commonPool()</code> 作为它的线程池执行异步代码。如果指定线程池，则使用指定的线程池运行。</li>\n<li>默认情况下<code>CompletableFuture</code>会使用公共的<code>ForkJoinPool</code>线程池，这个线程池默认创建的线程数是 CPU 的核数（也可以通过 <code>JVM option:-Djava.util.concurrent.ForkJoinPool.common.parallelism</code> 来设置<code>ForkJoinPool</code>线程池的线程数）。<strong>如果所有<code>CompletableFuture</code>共享一个线程池，那么一旦有任务执行一些很慢的 I&#x2F;O 操作，就会导致线程池中所有线程都阻塞在 I&#x2F;O 操作上，从而造成线程饥饿，进而影响整个系统的性能。所以，强烈建议你要根据不同的业务类型创建不同的线程池，以避免互相干扰</strong></li>\n</ul>\n<h4 id=\"异步操作-1\"><a href=\"#异步操作-1\" class=\"headerlink\" title=\"异步操作\"></a>异步操作</h4><pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">Runnable runnable &#x3D; () -&gt; System.out.println(&quot;无返回结果异步任务&quot;);\nCompletableFuture.runAsync(runnable);\n\nCompletableFuture&lt;String&gt; future &#x3D; CompletableFuture.supplyAsync(() -&gt; &#123;\n    System.out.println(&quot;有返回值的异步任务&quot;);\n    try &#123;\n        Thread.sleep(5000);\n    &#125; catch (InterruptedException e) &#123;\n        e.printStackTrace();\n    &#125;\n    return &quot;Hello World&quot;;\n&#125;);\nString result &#x3D; future.get();\n12345678910111213</code></pre>\n\n<h4 id=\"获取结果-join-amp-get\"><a href=\"#获取结果-join-amp-get\" class=\"headerlink\" title=\"获取结果(join&amp;get)\"></a>获取结果(join&amp;get)</h4><p><code>join()和get()方法都是用来获取CompletableFuture异步之后的返回值</code>。join()方法抛出的是uncheck异常（即未经检查的异常),不会强制开发者抛出。get()方法抛出的是经过检查的异常，ExecutionException, InterruptedException 需要用户手动处理（抛出或者 try catch）</p>\n<h4 id=\"结果处理-1\"><a href=\"#结果处理-1\" class=\"headerlink\" title=\"结果处理\"></a>结果处理</h4><p>当CompletableFuture的计算结果完成，或者抛出异常的时候，我们可以执行特定的 Action。主要是下面的方法：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public CompletableFuture&lt;T&gt; whenComplete(BiConsumer&lt;? super T,? super Throwable&gt; action)\npublic CompletableFuture&lt;T&gt; whenCompleteAsync(BiConsumer&lt;? super T,? super Throwable&gt; action)\npublic CompletableFuture&lt;T&gt; whenCompleteAsync(BiConsumer&lt;? super T,? super Throwable&gt; action, Executor executor)\n123</code></pre>\n\n<ul>\n<li><code>Action</code>的类型是<code>BiConsumer&lt;? super T,? super Throwable&gt;</code>，它可以处理正常的计算结果，或者异常情况。</li>\n<li>方法不以<code>Async</code>结尾，意味着Action使用相同的线程执行，而<code>Async</code>可能会使用其它的线程去执行(如果使用相同的线程池，也可能会被同一个线程选中执行)。</li>\n<li>这几个方法都会返回<code>CompletableFuture</code>，当Action执行完毕后它的结果返回原始的CompletableFuture的计算结果或者返回异常</li>\n</ul>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">CompletableFuture&lt;String&gt; future &#x3D; CompletableFuture.supplyAsync(() -&gt; &#123;\n    try &#123;\n        TimeUnit.SECONDS.sleep(1);\n    &#125; catch (InterruptedException e) &#123;\n    &#125;\n    if (new Random().nextInt(10) % 2 &#x3D;&#x3D; 0) &#123;\n        int i &#x3D; 12 &#x2F; 0;\n    &#125;\n    System.out.println(&quot;执行结束！&quot;);\n    return &quot;test&quot;;\n&#125;);\n&#x2F;&#x2F; 任务完成或异常方法完成时执行该方法\n&#x2F;&#x2F; 如果出现了异常,任务结果为null\nfuture.whenComplete(new BiConsumer&lt;String, Throwable&gt;() &#123;\n    @Override\n    public void accept(String t, Throwable action) &#123;\n        System.out.println(t+&quot; 执行完成！&quot;);\n    &#125;\n&#125;);\n&#x2F;&#x2F; 出现异常时先执行该方法\nfuture.exceptionally(new Function&lt;Throwable, String&gt;() &#123;\n    @Override\n    public String apply(Throwable t) &#123;\n        System.out.println(&quot;执行失败：&quot; + t.getMessage());\n        return &quot;异常xxxx&quot;;\n    &#125;\n&#125;);\n\nfuture.get();\n1234567891011121314151617181920212223242526272829</code></pre>\n\n<p>上面的代码当出现异常时，输出结果如下</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">执行失败：java.lang.ArithmeticException: &#x2F; by zero\nnull 执行完成！</code></pre></li>\n</ul>\n<h3 id=\"4-总结\"><a href=\"#4-总结\" class=\"headerlink\" title=\"4 总结\"></a>4 总结</h3><p><code>CompletableFuture</code>可以指定异步处理流程：</p>\n<ul>\n<li><code>thenAccept()</code>处理正常结果；</li>\n<li><code>exceptional()</code>处理异常结果；</li>\n<li><code>thenApplyAsync()</code>用于串行化另一个<code>CompletableFuture</code></li>\n<li><code>anyOf()</code>和<code>allOf()</code>用于并行化多个<code>CompletableFuture</code></li>\n</ul>\n<p>在<code>CompletableFuture</code>执行Task的时候，是需要使用线程池还是用当前的线程去执行。这个需要根据具体的情况来定。使用的时候要尽可能的小心。</p>\n","feature":true,"text":"CompletableFuture...","link":"","photos":[],"count_time":{"symbolsCount":"6.3k","symbolsTime":"6 mins."},"categories":[{"name":"编程","slug":"编程","count":16,"path":"api/categories/编程.json"}],"tags":[{"name":"Java","slug":"Java","count":9,"path":"api/tags/Java.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#CompletableFuture\"><span class=\"toc-text\">CompletableFuture</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-CompletableFuture%E4%B8%8EFuture%E7%9A%84%E5%85%B3%E7%B3%BB\"><span class=\"toc-text\">1 CompletableFuture与Future的关系</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2-CompletableFuture%E6%9C%AC%E8%B4%A8\"><span class=\"toc-text\">2 CompletableFuture本质</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3-%E5%8A%9F%E8%83%BD\"><span class=\"toc-text\">3 功能</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E4%BE%9D%E8%B5%96%E5%85%B3%E7%B3%BB\"><span class=\"toc-text\">依赖关系</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#and%E9%9B%86%E5%90%88%E5%85%B3%E7%B3%BB\"><span class=\"toc-text\">and集合关系</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#or%E8%81%9A%E5%90%88%E5%85%B3%E7%B3%BB\"><span class=\"toc-text\">or聚合关系</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E5%B9%B6%E8%A1%8C%E6%89%A7%E8%A1%8C\"><span class=\"toc-text\">并行执行</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E7%BB%93%E6%9E%9C%E5%A4%84%E7%90%86\"><span class=\"toc-text\">结果处理</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E5%BC%82%E6%AD%A5%E6%93%8D%E4%BD%9C\"><span class=\"toc-text\">异步操作</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E5%BC%82%E6%AD%A5%E6%93%8D%E4%BD%9C-1\"><span class=\"toc-text\">异步操作</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E8%8E%B7%E5%8F%96%E7%BB%93%E6%9E%9C-join-amp-get\"><span class=\"toc-text\">获取结果(join&amp;get)</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E7%BB%93%E6%9E%9C%E5%A4%84%E7%90%86-1\"><span class=\"toc-text\">结果处理</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#4-%E6%80%BB%E7%BB%93\"><span class=\"toc-text\">4 总结</span></a></li></ol></li></ol>","author":{"name":"Dxc","slug":"blog-author","avatar":"/images/avatar.png","link":"/","description":"Free will is not free. <br /> @ <b>公众号：精准拔草</b>","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"数据库表设计","uid":"f4ac3a4a311e597d05998bb126be956f","slug":"数据库表设计","date":"2023-06-15T14:09:53.000Z","updated":"2023-06-13T14:09:53.000Z","comments":true,"path":"api/articles/数据库表设计.json","keywords":null,"cover":"/images/database.jpg","text":"数据库表设计...","link":"","photos":[],"count_time":{"symbolsCount":"5.4k","symbolsTime":"5 mins."},"categories":[{"name":"编程","slug":"编程","count":16,"path":"api/categories/编程.json"}],"tags":[{"name":"数据库","slug":"数据库","count":1,"path":"api/tags/数据库.json"}],"author":{"name":"Dxc","slug":"blog-author","avatar":"/images/avatar.png","link":"/","description":"Free will is not free. <br /> @ <b>公众号：精准拔草</b>","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},"next_post":{"title":"Java开发规范","uid":"c1e27a71a1804b0860b5e849cbef0a50","slug":"Java_开发规范","date":"2023-04-28T14:09:53.000Z","updated":"2023-04-28T14:09:53.000Z","comments":true,"path":"api/articles/Java_开发规范.json","keywords":null,"cover":"/images/log.jpg","text":"IDE、插件、阿里黄山版、git提交规范...","link":"","photos":[],"count_time":{"symbolsCount":"2.9k","symbolsTime":"3 mins."},"categories":[{"name":"编程","slug":"编程","count":16,"path":"api/categories/编程.json"}],"tags":[{"name":"Java","slug":"Java","count":9,"path":"api/tags/Java.json"}],"author":{"name":"Dxc","slug":"blog-author","avatar":"/images/avatar.png","link":"/","description":"Free will is not free. <br /> @ <b>公众号：精准拔草</b>","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"feature":true}}