{"title":"《大话数据结构》笔记","uid":"b0474c53e1f198f2627cd8a831a75f0b","slug":"《大话数据结构》笔记","date":"2023-08-12T14:09:53.000Z","updated":"2023-08-12T14:09:53.000Z","comments":true,"path":"api/articles/《大话数据结构》笔记.json","keywords":null,"cover":"/images/dataStructure.jpg","content":"<h2 id=\"绪论\"><a href=\"#绪论\" class=\"headerlink\" title=\"绪论\"></a>绪论</h2><p>程序&#x3D;数据结构+算法</p>\n<p>数据元素：是组成数据的、有一定意义的基本单位，在计算机中通常作为整体处理。也被称为记录。</p>\n<p>数据项：一个数据元素可以由若干个数据项组成。数据项是数据不可分割的最小单位。</p>\n<p>数据对象：是性质相同的数据元素的集合，是数据的子集。</p>\n<p>数据结构：是相互之间存在一种或多种特定关系的数据元素的集合。</p>\n<p>按照视点的不同，我们把数据结构分为逻辑结构和物理结构。</p>\n<p>逻辑结构：是指数据对象中数据元素之间的相互关系。</p>\n<p>逻辑结构分为以下四种：</p>\n<p>1.集合结构：集合结构中的数据元素除了同属于一个集合外，它们之间没有其他关系。各个数据元素是“平等”的，它们的共同属性是“同属于一个集合”，类似于数学中的集合。</p>\n<p>2.线性结构：线性结构中的数据元素之间是一对一的关系。</p>\n<p>3.树形结构：树形结构中的数据元素之间存在一种一对多的层次关系。</p>\n<p>4.图形结构：图形结构的数据元素是多对多的关系。</p>\n<p>物理结构：是指数据的逻辑结构在计算机中的存储形式。</p>\n<p>数据元素的存储结构形式有两种：顺序存储和链式存储。</p>\n<p>1.顺序存储结构：把数据元素存放在地址连续的存储单元里，其数据间的逻辑关系和物理关系是一致。</p>\n<p>2.链式存储结构：把数据元素存放在任意的存储单元里，这组存储单元可以是连续的，也可以是不连续的。</p>\n<p>逻辑结构是面向问题的，而物理结构就是面向计算机的，其基本的目标就是将数据及其逻辑关系存储到计算机的内存中。</p>\n<p>数据类型：是指一组性质相同的值的集合及定义在此集合上的一些操作的总称。</p>\n<p>抽象是指抽取出事物具有的普遍性的本质。它是抽出问题的特征而忽略非本质的细节，是对具体事物的一个概括。抽象是一种思考问题的方式，它隐藏了繁杂的细节，只保留实现目标所必需的信息。</p>\n<p>抽象数据类型体现了程序设计中问题分解、抽象和信息隐藏的特性。</p>\n<h2 id=\"算法\"><a href=\"#算法\" class=\"headerlink\" title=\"算法\"></a>算法</h2><p>算法：算法是解决特定问题求解步骤的描述，在计算机中表现为指令的有限序列，并且每条指令表示一个或多个操作。</p>\n<p>算法是描述解决问题的方法。</p>\n<p>算法具有五个基本特性：输入、输出、有穷性、确定性和可行性。</p>\n<p>算法具有零个或多个输入。算法至少有一个或多个输出。</p>\n<p>有穷性：指算法在执行有限的步骤之后，自动结束而不会出现无限循环，并且每一个步骤在可接受的时间内完成。</p>\n<p>确定性：算法的每一步骤都具有确定的含义，不会出现二义性。</p>\n<p>可行性：算法的每一步都必须是可行的，也就是说，每一步都能够通过执行有限次数完成。</p>\n<h3 id=\"算法设计的要求\"><a href=\"#算法设计的要求\" class=\"headerlink\" title=\"算法设计的要求\"></a>算法设计的要求</h3><p>正确性：算法的正确性是指算法至少应该具有输入、输出和加工处理无歧义性、能正确反映问题的需求、能够得到问题的正确答案。</p>\n<p>可读性：算法设计的另一目的是为了便于阅读、理解和交流。</p>\n<p>健壮性：当输入数据不合法时，算法也能做出相关处理，而不是产生异常或莫名其妙的结果。</p>\n<p>时间效率高和存储量低</p>\n<p>综上，好的算法，应该具有正确性、可读性、健壮性、高效率和低存储量的特征。</p>\n<p>判断一个算法的效率时，函数中的常数和其他次要项常常可以忽略，而更应该关注主项（最高阶项）的阶数。</p>\n<h3 id=\"算法时间复杂度\"><a href=\"#算法时间复杂度\" class=\"headerlink\" title=\"算法时间复杂度\"></a>算法时间复杂度</h3><p>在进行算法分析时，语句总的执行次数T(n)是关于问题规模n的函数，进而分析T(n)随n的变化情况并确定T(n)的数量级。算法的时间复杂度，也就是算法的时间量度，记作：T(n)&#x3D;O(f(n))。它表示随问题规模n的增大，算法执行时间的增长率和f(n)的增长率相同，称作算法的渐近时间复杂度，简称为时间复杂度。其中f(n)是问题规模n的某个函数。</p>\n<p>这样用大写O()来体现算法时间复杂度的记法，我们称之为大0记法。<br>一般情况下，随着n的增大，T(n)增长最慢的算法为最优算法。</p>\n<p>显然，由此算法时间复杂度的定义可知，我们的三个求和算法的时间复杂度分别为0(n),0(1),0(n2)。我们分别给它们取了非官方的名称，0(1)叫常数阶、0(n)叫线性阶、0(n2)叫平方阶。</p>\n<p>所以我们可以总结得出，循环的时间复杂度等于循环体的复杂度乘以该循环运行的次数。</p>\n<p>常用的时间复杂度所耗费的时间从小到大依次是：<br>O(1)&lt;O(logn)&lt;O(n)&lt;O(nlogn)&lt;O(n^2 )&lt;O(n^3 )&lt;O(2^n )&lt;O(n!)&lt;O(n^n)</p>\n<p>最坏情况运行时间是一种保证，那就是运行时间将不会再坏了。在应用中，这是一种最重要的需求，通常，除非特别指定，我们提到的运行时间都是最坏情况的运行时间。</p>\n<p>平均运行时间是所有情况中最有意义的，因为它是期望的运行时间。</p>\n<p>一般在没有特殊说明的情况下，都是指最坏时间复杂度。</p>\n<h3 id=\"算法空间复杂度\"><a href=\"#算法空间复杂度\" class=\"headerlink\" title=\"算法空间复杂度\"></a>算法空间复杂度</h3><p>算法的空间复杂度通过计算算法所需的存储空间实现，算法空间复杂度的计算公式记作：S(n)&#x3D;0(f(n)),其中，n为问题的规模，f(n)为语句关于n所占存储空间的函数。</p>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>算法的定义：算法是解决特定问题求解步骤的描述，在计算机中为指令的有限序列，并且每条指令表示一个或多个操作。<br>算法的特性：有穷性、确定性、可行性、输入、输出。<br>算法的设计的要求：正确性、可读性、健壮性、高效率和低存储量需求。<br>算法特性与算法设计容易混，需要对比记忆。<br>算法的度量方法：事后统计方法（不科学、不准确）、事前分析估算方法。<br>在讲解如何用事前分析估算方法之前，我们先给出了函数渐近增长的定义。<br>函数的渐近增长：给定两个函数f(n)和g(n),如果存在一个整数N,使得对于所有的n&gt;N,f(n)总是比g(n)大，那么，我们说f(n)的增长渐近快于g(n)。于是我们可以得出一个结论，判断一个算法好不好，我们只通过少量的数据是不能做出准确判断的，如果我们可以对比算法的关键执行次数函数的渐近增长性，基本就可以分析出：某个算法，随着n的变大，它会越来越优于另一算法，或者越来越差于另一算法。</p>\n<h2 id=\"线性表\"><a href=\"#线性表\" class=\"headerlink\" title=\"线性表\"></a>线性表</h2><p>线性表：零个或多个数据元素的有限序列。</p>\n<p>线性表元素的个数n(n≥0)定义为线性表的长度，当n&#x3D;0时，称为空表。</p>\n<h3 id=\"线性表的顺序存储结构\"><a href=\"#线性表的顺序存储结构\" class=\"headerlink\" title=\"线性表的顺序存储结构\"></a>线性表的顺序存储结构</h3><p>线性表的顺序存储结构，指的是用一段地址连续的存储单元依次存储线性表的数据元素。</p>\n<p>描述顺序存储结构需要三个属性：<br>· 存储空间的起始位置：数组data,它的存储位置就是存储空间的存储位置。<br>· 线性表的最大存储容量：数组长度MaxSize。<br>· 线性表的当前长度：length。</p>\n<p>数组的长度是存放线性表的存储空间的长度，存储分配后这个量是一般是不变的。</p>\n<p>线性表的长度是线性表中数据元素的个数，随着线性表插入和删除操作的进行，这个量是变化的。</p>\n<p>在任意时刻，线性表的长度应该小于等于数组的长度。</p>\n<p>优点：无须为表示表中元素之间的逻辑关系而增加额外的存储空间，可以快速地存取表中任一位置的元素。</p>\n<p>缺点：插入和删除操作需要移动大量元素，当线性表长度变化较大时，难以确定存储空间的容量，造成存储空间的“碎片”。</p>\n<h3 id=\"线性表的链式存储结构\"><a href=\"#线性表的链式存储结构\" class=\"headerlink\" title=\"线性表的链式存储结构\"></a>线性表的链式存储结构</h3><p>线性表的链式存储结构的特点是用一组任意的存储单元存储线性表的数据元素，这组存储单元可以是连续的，也可以是不连续的。这就意味着，这些数据元素可以存在内存未被占用的任意位置。</p>\n<p>显然，对于插入或删除数据越频繁的操作，单链表的效率优势就越是明显。</p>\n<p><strong>单链表结构与顺序存储结构优缺点</strong></p>\n<ol>\n<li><p>存储分配方式</p>\n<ul>\n<li>顺序存储结构用一段连续的存储单元依次存储线性表的数据元素</li>\n<li>单链表采用链式存储结构，用一组任意的存储单元存放线性表的元素</li>\n</ul>\n</li>\n<li><p>时间性能</p>\n<ul>\n<li>查找：顺序存储结构O(1)，单链表O(n)</li>\n<li>插入和删除<br>顺序存储结构需要平均移动表长一半的元素，时间为O(n)<br>单链表在线出某位置的指针后，插入和删除时间仅为O(1)</li>\n</ul>\n</li>\n<li><p>空间性能</p>\n<ul>\n<li>顺序存储结构需要预分配存储空间，分大了，浪费，分小了易发生上溢</li>\n<li>单链表不需要分配存储空间，只要有就可以分配，元素个数也不受限制</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"静态链表\"><a href=\"#静态链表\" class=\"headerlink\" title=\"静态链表\"></a>静态链表</h3><p>用数组描述的链表叫做静态链表。</p>\n<p>优点：在插入和删除操作时，只需要修改游标，不需要移动元素，从而改进了在顺序存储结构中的插入和删除操作需要移动大量元素的缺点。</p>\n<p>缺点：没有解决连续存储分配带来的表长难以确定的问题。失去了顺序存储结构随机存取的特性</p>\n<h3 id=\"循环链表\"><a href=\"#循环链表\" class=\"headerlink\" title=\"循环链表\"></a>循环链表</h3><p>将单链表中终端结点的指针端由空指针改为指向头结点，就使整个单链表形成一个环，这种头尾相接的单链表称为单循环链表，简称循环链表（circular linkedlist)。</p>\n<h3 id=\"双向链表\"><a href=\"#双向链表\" class=\"headerlink\" title=\"双向链表\"></a>双向链表</h3><p>双向链表(double linked list)是在单链表的每个结点中，再设置一个指向其前驱结点的指针域。所以在双向链表中的结点都有两个指针域，一个指向直接后继，另一个指向直接前驱。</p>\n<h3 id=\"总结-1\"><a href=\"#总结-1\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>线性表是零个或多个具有相同类型的数据元素的有限序列。<br>顺序存储结构，指的是用一段地址连续的存储单元依次存储线性表的数据元素。通常我们都是用数组来实现这一结构。<br>顺序存储结构的插入和删除操作不方便，引出了链式存储结构。它具有不受固定的存储空间限制，可以比较快捷的插入和删除操作的特点。<br>链式存储结构的不同形式，如单链表、循环链表和双向链表。<br>线性表的这两种结构其实是后面其他数据结构的基础。</p>\n<img src=\"D:\\Desktop\\assets\\image-20230718234544677.png\" alt=\"image-20230718234544677\" style=\"zoom:80%;\" />\n\n<h2 id=\"栈与队列\"><a href=\"#栈与队列\" class=\"headerlink\" title=\"栈与队列\"></a>栈与队列</h2><p>栈是限定仅在表尾进行插入和删除操作的线性表。<br>队列是只允许在一端进行插入操作、而在另一端进行删除操作的线性表。</p>\n<h3 id=\"栈\"><a href=\"#栈\" class=\"headerlink\" title=\"栈\"></a>栈</h3><p>栈（stack)是限定仅在表尾进行插入和删除操作的线性表。</p>\n<p>我们把允许插入和删除的一端称为栈顶（top),另一端称为栈底（bottom),不含任何数据元素的栈称为空栈。栈又称为后进先出（Last In First Out)的线性表，简称LIFO结构。</p>\n<p>栈的插入操作，叫作进栈，也称压栈、入栈。</p>\n<p>栈的删除操作，叫作出栈，也有的叫作弹栈。插入和删除操作，对应push和pop,</p>\n<h3 id=\"递归\"><a href=\"#递归\" class=\"headerlink\" title=\"递归\"></a>递归</h3><p>我们把一个直接调用自己或通过一系列的调用语句间接地调用自己的函数，称做递归函数。</p>\n<p>每个递归定义必须至少有一个条件，满足时递归不再进行，即不再引用自身而是返回值退出。</p>\n<h3 id=\"队列\"><a href=\"#队列\" class=\"headerlink\" title=\"队列\"></a>队列</h3><p>队列是只允许在一端进行插入操作、而在另一端进行删除操作的线性表。允许插入的一端称为队尾，允许删除的一端称为队头。</p>\n<p>队列是一种先进先出(First In First Out)的线性表，简称FIFO。</p>\n<p>线性表有顺序存储和链式存储，栈是线性表，所以有这两种存储方式。同样，队列作为一种特殊的线性表，也同样存在这两种存储方式。</p>\n<h3 id=\"循环队列\"><a href=\"#循环队列\" class=\"headerlink\" title=\"循环队列\"></a>循环队列</h3><p>队列头尾相接的顺序存储结构称为循环队列。（避免假溢出）</p>\n<p>队列的链式存储结构，其实就是线性表的单链表，只不过它只能尾进头出而已，我们把它简称为链队列。</p>\n<h3 id=\"总结-2\"><a href=\"#总结-2\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>栈和队列，它们都是特殊的线性表，只不过对插入和删除操作做了限制。<br>栈(stck)是限定仅在表尾进行插入和删除操作的线性表。<br>队列(queue)是只允许在一端进行插入操作，而在另一端进行删除操作的线性表。<br>它们均可以用线性表的顺序存储结构来实现，但都存在着顺序存储的一些弊端。</p>\n<p>对于栈来说，如果是两个相同数据类型的栈，则可以用数组的两端作栈底的方法来让两个栈共享数据，这就可以最大化地利用数组的空间。<br>对于队列来说，为了避免数组插入和删除时需要移动数据，于是就引入了循环队列，使得队头和队尾可以在数组中循环变化。解决了移动数据的时间损耗，使得本来插入和删除是O(n)的时间复杂度变成了O(1)。<br>它们也都可以通过链式存储结构来实现，实现原则上与线性表基本相同。</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">栈\n•顺序栈-两栈共享空间\n•链栈</code></pre>\n\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">队列\n•顺序队列-循环队列\n•链队列</code></pre>\n\n<h2 id=\"串\"><a href=\"#串\" class=\"headerlink\" title=\"串\"></a>串</h2><p>串(string)是由零个或多个字符组成的有限序列，又名叫字符串。</p>\n<p>空格串，是只包含空格的串。注意它与空串的区别，空格串是有内容有长度的，而且可以不止一个空格。<br>子串与主串，串中任意个数的连续字符组成的子序列称为该串的子串，相应地，包含子串的串称为主串。<br>子串在主串中的位置就是子串的第一个字符在主串中的序号。</p>\n<p>串的逻辑结构和线性表很相似，不同之处在于串针对的是字符集，也就是串中的元素都是字符。</p>\n<h3 id=\"串的存储结构\"><a href=\"#串的存储结构\" class=\"headerlink\" title=\"串的存储结构\"></a>串的存储结构</h3><p>串的存储结构与线性表相同，分为两种。顺序存储结构和链式存储结构。</p>\n<p>子串的定位操作通常称做串的模式匹配，应该算是串中最重要的操作之一。</p>\n<h3 id=\"朴素模式匹配算法\"><a href=\"#朴素模式匹配算法\" class=\"headerlink\" title=\"朴素模式匹配算法\"></a>朴素模式匹配算法</h3><p>简单的说，就是对主串的每一个字符作为子串开头，与要匹配的字符串进行匹配。对主串做大循环，每个字符开头做T的长度的小循环，直到匹配成功或全部遍历完成为止。</p>\n<h3 id=\"KMP模式匹配算法\"><a href=\"#KMP模式匹配算法\" class=\"headerlink\" title=\"KMP模式匹配算法\"></a>KMP模式匹配算法</h3><p>让这没必要的回溯不发生。</p>\n<h3 id=\"总结-3\"><a href=\"#总结-3\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>串(string)是由零个或多个字符组成的有限序列，又名叫字符串。本质上，它是一种线性表的扩展，但相对于线性表关注一个个元素来说，我们对串这种结构更多的是关注它子串的应用问题，如查找、替换等操作。</p>\n<h2 id=\"树\"><a href=\"#树\" class=\"headerlink\" title=\"树\"></a>树</h2><h3 id=\"树的定义\"><a href=\"#树的定义\" class=\"headerlink\" title=\"树的定义\"></a>树的定义</h3><p>树(Tree)是n(n≥0)个结点的有限集。n&#x3D;0时称为空树。</p>\n<p>在任意一棵非空树中：</p>\n<p>(1)有且仅有一个特定的称为根(Root)的&#x3D;&#x3D;结点&#x3D;&#x3D;；</p>\n<p>(2)当n&gt;1时，其余结点可分为m(m&gt;0)个互不相交的有限集T1、T2、…、Tn，其中每一个集合本身又是一棵树，并且称为&#x3D;&#x3D;根&#x3D;&#x3D;的子树(SubTree)。</p>\n<ol>\n<li>n&gt;0时根结点是唯一的，不可能存在多个根结点，和现实中的大树不同，现实中的树有很多根须，那是真实的树，数据结构中的树是只能有一个根结点。</li>\n<li>m&gt;0时，子树的个数没有限制，但它们一定是互不相交的。。</li>\n</ol>\n<h4 id=\"结点分类\"><a href=\"#结点分类\" class=\"headerlink\" title=\"结点分类\"></a>结点分类</h4><p>根结点-内部结点-叶结点或终端结点</p>\n<p>树的结点包含一个数据元素及若干指向其子树的分支。结点拥有的子树数称为结点的度(Degree)。度为0的结点称为叶结点(Leaf)或终端结点；度不为0的结点称为非终端结点或分支结点。除根结点之外，分支结点也称为内部结点。树的度是树内各结点的度的最大值。</p>\n<h4 id=\"结点间关系\"><a href=\"#结点间关系\" class=\"headerlink\" title=\"结点间关系\"></a>结点间关系</h4><p>结点的子树的根称为该结点的孩子(Child)，相应地，该结点称为孩子的双亲(Parent)。对于结点来说其父母同体，唯一的一个，所以把它称为双亲了。同一个双亲的孩子之间互称兄弟(Sibling)。结点的祖先是从根到该结点所经分支上的所有结点。反之，以某结点为根的子树中的任一结点都称为该结点的子孙。</p>\n<h4 id=\"层次、深度\"><a href=\"#层次、深度\" class=\"headerlink\" title=\"层次、深度\"></a>层次、深度</h4><p>结点的层次(Level)从根开始定义起，根为第一层，根的孩子为第二层。树中结点的最大层次称为树的深度(Depth)或高度。</p>\n<p>如果将树中结点的各子树从左至右是有次序的，不能互换的，则称该树为有序树，否则称为无序树。</p>\n<p>森林(Forest)是m(m&gt;≥0)棵互不相交的树的集合。</p>\n<h4 id=\"线性结构和树结构对比\"><a href=\"#线性结构和树结构对比\" class=\"headerlink\" title=\"线性结构和树结构对比\"></a>线性结构和树结构对比</h4><table>\n<thead>\n<tr>\n<th>线性结构</th>\n<th>树结构</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>第一个数据元素：无前驱</td>\n<td>根结点：无双亲，唯一</td>\n</tr>\n<tr>\n<td>最后一个数据元素：无后继</td>\n<td>叶结点：无孩子，可以多个</td>\n</tr>\n<tr>\n<td>中间元素：一个前驱一个后继</td>\n<td>中间结点：一个双亲多个孩子</td>\n</tr>\n</tbody></table>\n<h3 id=\"树的存储结构\"><a href=\"#树的存储结构\" class=\"headerlink\" title=\"树的存储结构\"></a>树的存储结构</h3><p>双亲表示法、孩子表示法、孩子兄弟表示法。</p>\n<h3 id=\"二叉树\"><a href=\"#二叉树\" class=\"headerlink\" title=\"二叉树\"></a>二叉树</h3><p>二叉树(Binary Tree)是n(n≥0)个结点的有限集合，该集合或者为空集（称为空二叉树），或者由一个根结点和两棵互不相交的、分别称为根结点的左子树和右子树的二叉树组成。</p>\n<h4 id=\"二叉树特点\"><a href=\"#二叉树特点\" class=\"headerlink\" title=\"二叉树特点\"></a>二叉树特点</h4><p>每个结点最多有两棵子树，所以二叉树中不存在度大于2的结点。注意不是只有两棵子树，而是最多有。没有子树或者有一棵子树都是可以的。<br>左子树和右子树是有顺序的，次序不能任意颠倒。就像人是双手、双脚，但显然左手、左脚和右手、右脚是不一样的，右手戴左手套、右脚穿左鞋都会极其别扭和难受。<br>即使树中某结点只有一棵子树，也要区分它是左子树还是右子树。就好像你一不小心，摔伤了手，伤的是左手还是右手，对你的生活影响度是完全不同的。</p>\n<h4 id=\"二叉树基本形态\"><a href=\"#二叉树基本形态\" class=\"headerlink\" title=\"二叉树基本形态\"></a>二叉树基本形态</h4><p>1.空二叉树。<br>2.只有一个根结点。<br>3.根结点只有左子树。<br>4.根结点只有右子树。<br>5.根结点既有左子树又有右子树。</p>\n<h4 id=\"特殊二叉树\"><a href=\"#特殊二叉树\" class=\"headerlink\" title=\"特殊二叉树\"></a>特殊二叉树</h4><ol>\n<li>斜树</li>\n</ol>\n<p>顾名思义，斜树一定要是斜的，但是往哪斜还是有讲究。所有的结点都只有左子树的二叉树叫左斜树。所有结点都是只有右子树的二叉树叫右斜树。&#x3D;&#x3D;线性表结构就可以理解为是树的一种极其特殊的表现形式。&#x3D;&#x3D;</p>\n<ol start=\"2\">\n<li>满二叉树</li>\n</ol>\n<p>在一棵二叉树中，如果所有分支结点都存在左子树和右子树，并且所有叶子都在同一层上，这样的二叉树称为满二叉树。</p>\n<ol start=\"3\">\n<li>完全二叉树</li>\n</ol>\n<p>对一棵具有n个结点的二叉树按层序编号，如果编号为1(1≤i≤n)的结点与同样深度的满二叉树中编号为1的结点在二叉树中位置完全相同，则这棵二叉树称为完全二叉树。</p>\n<p>满二叉树一定是一棵完全二叉树，但完全二叉树不一定是满的。</p>\n<h4 id=\"二叉树的性质\"><a href=\"#二叉树的性质\" class=\"headerlink\" title=\"二叉树的性质\"></a>二叉树的性质</h4><p>性质1：在二叉树的第i层上至多有2^(i-1)个结点(i&gt;1)。</p>\n<p>性质2：深度为k的二叉树至多有(2^k)-1个结点(k≥1)。</p>\n<p>性质3：对任何一棵二叉树T,如果其终端结点数为n0，度为2的结点数为n2，则n0&#x3D;n2+1。</p>\n<p>性质4：具有n个结点的完全二叉树的深度为[log2n]+1 ([x]表示不大于x的最大整数)。</p>\n<h4 id=\"二叉树的存储结构\"><a href=\"#二叉树的存储结构\" class=\"headerlink\" title=\"二叉树的存储结构\"></a>二叉树的存储结构</h4><p>二叉树的顺序存储结构就是用一维数组存储二叉树中的结点，并且结点的存储位置，也就是数组的下标要能体现结点之间的逻辑关系，比如双亲与孩子的关系，左右兄弟的关系等。</p>\n<p>既然顺序存储适用性不强，我们就要考虑链式存储结构。二叉树每个结点最多有两个孩子，所以为它设计一个数据域和两个指针域是比较自然的想法，我们称这样的链表叫做二叉链表。</p>\n<h4 id=\"遍历二叉树\"><a href=\"#遍历二叉树\" class=\"headerlink\" title=\"遍历二叉树\"></a>遍历二叉树</h4><p>二叉树的遍历(traversing binary tree)是指从根结点出发，按照某种&#x3D;&#x3D;次序&#x3D;&#x3D;依次访问二叉树中所有结点，使得每个结点被&#x3D;&#x3D;访问&#x3D;&#x3D;一次且仅被访问一次。</p>\n<p>二叉树的遍历次序不同于线性结构，最多也就是从头至尾、循环、双向等简单的遍历方式。树的结点之间不存在唯一的前驱和后继关系，在访问一个结点后，下一个被访问的结点面临着不同的选择。就像你人生的道路上，高考填志愿要面临哪个城市、哪所大学、具体专业等选择，由于选择方式的不同，遍历的次序就完全不同了。</p>\n<p>遍历方法：</p>\n<ol>\n<li>前序遍历</li>\n</ol>\n<p>规则是若二叉树为空，则空操作返回，否则先访问根结点，然后前序遍历左子树，再前序遍历右子树。</p>\n<ol start=\"2\">\n<li>中序遍历</li>\n</ol>\n<p>规则是若树为空，则空操作返回，否则从根结点开始（注意并不是先访问根结点)，中序遍历根结点的左子树，然后是访问根结点，最后中序遍历右子树。</p>\n<ol start=\"3\">\n<li>后序遍历</li>\n</ol>\n<p>规则是若树为空，则空操作返回，否则从左到右先叶子后结点的方式遍历访问左右子树，最后是访问根结点。</p>\n<ol start=\"4\">\n<li>层序遍历</li>\n</ol>\n<p>规则是若树为空，则空操作返回，否则从树的第一层，也就是根结点开始访问，从上而下逐层遍历，在同一层中，按从左到右的顺序对结点逐个访问。</p>\n<h4 id=\"二叉树的建立\"><a href=\"#二叉树的建立\" class=\"headerlink\" title=\"二叉树的建立\"></a>二叉树的建立</h4><p>建立二叉树，也是利用了递归的原理。只不过在原来应该是打印结点的地方，改成了生成结点、给结点赋值的操作而已。</p>\n<h4 id=\"线索二叉树\"><a href=\"#线索二叉树\" class=\"headerlink\" title=\"线索二叉树\"></a>线索二叉树</h4><p>指向前驱和后继的指针称为线索，加上线索的二叉链表称为线索链表，相应的二叉树就称为线索二叉树<br>(Threaded Binary Tree)</p>\n<p>其实线索二叉树，等于是把一棵二叉树转变成了一个双向链表，这样对我们的插入删除结点、查找某个结点都带来了方便。所以我们对二叉树以某种次序遍历使其变为线索二叉树的过程称做是线索化。</p>\n<p>所以在实际问题中，如果所用的二叉树需经常遍历或查找结点时需要某种遍历序列中的前驱和后继，那么采用线索二叉链表的存储结构就是非常不错的选择。</p>\n<h4 id=\"树、森林与二叉树的转换\"><a href=\"#树、森林与二叉树的转换\" class=\"headerlink\" title=\"树、森林与二叉树的转换\"></a>树、森林与二叉树的转换</h4><ol>\n<li>树转换为二叉树</li>\n<li>森林转换为二叉树</li>\n<li>二叉树转换为树</li>\n<li>二叉树转换为森林</li>\n</ol>\n<h4 id=\"树与森林的遍历\"><a href=\"#树与森林的遍历\" class=\"headerlink\" title=\"树与森林的遍历\"></a>树与森林的遍历</h4><p>树的遍历分为两种方式。</p>\n<ol>\n<li>一种是先根遍历树，即先访问树的根结点，然后依次先根遍历根的每棵子树。</li>\n<li>另一种是后根遍历，即先依次后根遍历每棵子树，然后再访问根结点。</li>\n</ol>\n<p>森林的遍历也分为两种方式：1.前序遍历\t2.后序遍历</p>\n<h4 id=\"赫夫曼树\"><a href=\"#赫夫曼树\" class=\"headerlink\" title=\"赫夫曼树\"></a>赫夫曼树</h4><p>带权路径长度WPL最小的二叉树称做赫夫曼树，也称为最优二叉树。</p>\n<h3 id=\"总结-4\"><a href=\"#总结-4\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>开头我们提到了树的定义，讲到了递归在树定义中的应用。提到了如子树、结点、度、叶子、分支结点、双亲、孩子、层次、深度、森林等诸多概念。<br>我们谈到了树的存储结构时，讲了双亲表示法、孩子表示法、孩子兄弟表示法等不同的存储结构。并由孩子兄弟表示法引出了我们这章中最重要一种树，二叉树。<br>二叉树每个结点最多两棵子树，有左右之分。提到了斜树，满二叉树、完全二叉树等特殊二叉树的概念。<br>我们接着谈到它的各种性质，这些性质给我们研究二叉树带来了方便。二叉树的存储结构由于其特殊性使得既可以用顺序存储结构又可以用链式存储结构表示。</p>\n<h2 id=\"图\"><a href=\"#图\" class=\"headerlink\" title=\"图\"></a>图</h2><p>图(Graph)是由顶点的有穷非空集合和顶点之间边的集合组成，通常表示为：G(V,E),其中，G表示一个图，V是图G中顶点的集合，E是图G中边的集合。</p>\n<p>线性表中我们把数据元素叫元素，树中将数据元素叫结点，在图中数据元素，我们则称之为顶点(Vertex)。</p>\n<p>在图结构中，不允许没有顶点。在定义中，若V是顶点的集合，则强调了顶点集合V有穷非空。</p>\n<p>线性表中，相邻的数据元素之间具有线性关系，树结构中，相邻两层的结点具有层次关系，而图中，任意两个顶点之间都可能有关系，顶点之间的逻辑关系用边来表示，边集可以是空的。</p>\n<h3 id=\"图的存储结构\"><a href=\"#图的存储结构\" class=\"headerlink\" title=\"图的存储结构\"></a>图的存储结构</h3><ol>\n<li><p>邻接矩阵：图的邻接矩阵(Adjacency Matrix)存储方式是用两个数组来表示图。一个一维数组存储图中顶点信息，一个二维数组（称为邻接矩阵）存储图中的边或弧的信息。</p>\n</li>\n<li><p>邻接表：数组与链表相结合的存储方法称为邻接表(Adjacency List)。</p>\n</li>\n<li><p>十字链表：十字链表的好处就是因为把邻接表和逆邻接表整合在了一起，容易求得顶点的出度和入度。而且它除了结构复杂一点外，其实创建图算法的时间复杂度是和邻接表相同的，因此，在有向<br>图的应用中，十字链表是非常好的数据结构模型。</p>\n</li>\n<li><p>邻接多重表</p>\n</li>\n<li><p>边集数组：边集数组是由两个一维数组构成。一个是存储顶点的信息；另一个是存储边的信息，这个边数组每个数据元素由一条边的起点下标(begin)、终点下标(end)和权(weight)组成。</p>\n</li>\n</ol>\n<h3 id=\"图的遍历\"><a href=\"#图的遍历\" class=\"headerlink\" title=\"图的遍历\"></a>图的遍历</h3><ol>\n<li><p>深度优先遍历：深度优先遍历(Depth_First_Search),也有称为深度优先搜索，简称为DFS。</p>\n</li>\n<li><p>广度优先遍历：广度优先遍历(Breadth_First_Search),又称为广度优先搜索，简称BFS。</p>\n</li>\n</ol>\n<h3 id=\"最小生成树\"><a href=\"#最小生成树\" class=\"headerlink\" title=\"最小生成树\"></a>最小生成树</h3><p>我们把构造连通网的最小代价生成树，称为最小生成树(Minimum Cost Spanning Tree)。</p>\n<ul>\n<li>普里姆(Prim)算法</li>\n<li>克鲁斯卡尔(Kruskal)算法</li>\n</ul>\n<h3 id=\"最短路径\"><a href=\"#最短路径\" class=\"headerlink\" title=\"最短路径\"></a>最短路径</h3><p>在网图和非网图中，最短路径的含义是不同的。由于非网图它没有边上的权值，所谓的最短路径，其实就是指两顶点之间经过的边数最少的路径；而对于网图来说，最短路径，是指两顶点之间经过的边上权值之和最少的路径，并且我们称路径上的第一个顶点是源点，最后一个顶点是终点。显然，我们研究网图更有实际意义，就地图来说，距离就是两顶点间的权值之和。而非网图完全可以理解为所有的边的权值都为1的网。</p>\n<ul>\n<li>迪杰斯特拉(Dijkstra)算法</li>\n<li>弗洛伊德(Floyd)算法</li>\n</ul>\n<h3 id=\"拓扑排序\"><a href=\"#拓扑排序\" class=\"headerlink\" title=\"拓扑排序\"></a>拓扑排序</h3><p>所谓拓扑排序，其实就是对一个有向图构造拓扑序列的过程。</p>\n<h3 id=\"关键路径\"><a href=\"#关键路径\" class=\"headerlink\" title=\"关键路径\"></a>关键路径</h3><p>我们把路径上各个活动所持续的时间之和称为路径长度，从源点到汇点具有最大长度的路径叫关键路径，在关键路径上的活动叫关键活动。</p>\n<h3 id=\"总结-5\"><a href=\"#总结-5\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>图的存储结构我们一共讲了五种，其中比较重要的是邻接矩阵和邻接表，它们分别代表着边集是用数组还是链表的方式存储。十字链表是邻接矩阵的一种升级，而邻接多重表则是邻接表的升级。边集数组更多考虑的是对边的关注。用什么存储结构需要具体问题具体分析，通常稠密图，或读存数据较多，结构修改较少的图，用邻接矩阵要更合适，反之则应该考虑邻接表。</p>\n<h2 id=\"查找\"><a href=\"#查找\" class=\"headerlink\" title=\"查找\"></a>查找</h2><h3 id=\"查找概论\"><a href=\"#查找概论\" class=\"headerlink\" title=\"查找概论\"></a>查找概论</h3><p>查找(Searching)就是根据给定的某个值，在查找表中确定一个其关键字等于给定值的数据元素（或记录）。</p>\n<p>查找表(Search Table)是由同一类型的数据元素(或记录)构成的集合。</p>\n<p>关键字(Key)是数据元素中某个数据项的值，又称为键值，用它可以标识一个数据元素。也可以标识一个记录的某个数据项（字段），我们称为关键码。</p>\n<p>若此关键字可以唯一地标识一个记录，则称此关键字为主关键字(Primary Key)。可以识别多个数据元素（或记录）的关键字，我们称为次关键字。</p>\n<p>查找表按照操作方式来分有两大种：静态查找表和动态查找表。</p>\n<p>静态查找表(Static Search Table):只作查找操作的查找表。它的主要操作有：<br>(1)查询某个“特定的”数据元素是否在查找表中。<br>(2)检素某个“特定的”数据元素和各种属性。</p>\n<p>动态查找表(Dynamic Search Table):在查找过程中同时插入查找表中不存在的数据元素，或者从查找表中删除已经存在的某个数据元素。显然动态查找表的操作就是两个：<br>(1)查找时插入数据元素。<br>(2)查找时删除数据元素。</p>\n<h3 id=\"顺序表查找\"><a href=\"#顺序表查找\" class=\"headerlink\" title=\"顺序表查找\"></a>顺序表查找</h3><p>顺序查找(Sequential Search)又叫线性查找，是最基本的查找技术，它的查找过程是：从表中第一个（或最后一个)记录开始，逐个进行记录的关键字和给定值比较，若某个记录的关键字和给定值相等，则查找成功，找到所查的记录；如果直到最后一个（或第一个）记录，其关键字和给定值比较都不等时，则表中没有所查的记录，查找不成功。</p>\n<h3 id=\"有序表查找\"><a href=\"#有序表查找\" class=\"headerlink\" title=\"有序表查找\"></a>有序表查找</h3><p><strong>二分查找</strong></p>\n<p>折半查找(Binary Search)技术，又称为<strong>二分查找</strong>。它的前提是线性表中的记录必须是关键码有序（通常从小到大有序），线性表必须采用顺序存储。折半查找的基本思想是：在有序表中，取中间记录作为比较对象，若给定值与中间记录的关键字相等，则查找成功；若给定值小于中间记录的关键字，则在中间记录的左半区继续查找；若给定值大于中间记录的关键字，则在中间记录的右半区继续查找。不断重复上述过程，直到查找成功，或所有查找区域无记录，查找失败为止。</p>\n<p><strong>插值查找</strong></p>\n<p>插值查找(Interpolation Search)是根据要查找的关键字ky与查找表中最大最小记录的关键字比较后的查找方法，其核心就在于插值的计算公式</p>\n<p><strong>斐波那契查找</strong></p>\n<p>斐波那契查找(Fibonacci Search),它是利用了黄金分割原理来实现的。</p>\n<h3 id=\"线性索引查找\"><a href=\"#线性索引查找\" class=\"headerlink\" title=\"线性索引查找\"></a>线性索引查找</h3><p>数据结构的最终目的是提高数据的处理速度，索引是为了加快查找速度而设计的一种数据结构。索引就是把一个关键字与它对应的记录相关联的过程，一个索引由若干个索引项构成，每个索引项至少应包含关键字和其对应的记录在存储器中的位置等信息。索引技术是组织大型数据库以及磁盘文件的一种重要技术。<br>索引按照结构可以分为线性索引、树形索引和多级索引。我们这里就只介绍线性索引技术。所谓线性索引就是将索引项集合组织为线性结构，也称为索引表。我们重点介绍三种线性索引：稠密索引、分块索引和倒排索引。</p>\n<p><strong>稠密索引</strong></p>\n<p>稠密索引是指在线性索引中，将数据集中的每个记录对应一个索引项。对于稠密索引这个索引表来说，索引项一定是按照关键码有序的排列。</p>\n<p><strong>分块索引</strong></p>\n<p>稠密索引因为索引项与数据集的记录个数相同，所以空间代价很大。为了减少索引项的个数，我们可以对数据集进行分块，使其分块有序，然后再对每一块建立一个索引项，从而减少索引项的个数。</p>\n<p>分块有序，是把数据集的记录分成了若干块，并且这些块需要满足两个条件：</p>\n<ol>\n<li><p>块内无序，即每一块内的记录不要求有序。当然，你如果能够让块内有序对查找来说更理想，不过这就要付出大量时间和空间的代价，因此通常我们不要求块内有序。</p>\n</li>\n<li><p>块间有序，例如，要求第二块所有记录的关键字均要大于第一块中所有记录的关键字，第三块的所有记录的关键字均要大于第二块的所有记录关键字，因为只有块间有序，才有可能在查找时带来效率。</p>\n</li>\n</ol>\n<p><strong>倒排索引</strong></p>\n<p>其中记录号表存储具有相同次关键字的所有记录的记录号（可以是指向记录的指针或者是该记录的主关键字)。这样的索引方法就是倒排索引(inverted index)。倒排索引源于实际应用中需要根据属性（或字段、次关键码）的值来查找记录。这种索引表中的每一项都包括一个属性值和具有该属性值的各记录的地址。由于不是由记录来确定属性值，而是由属性值来确定记录的位置，因而称为倒排索引。</p>\n<h3 id=\"二叉排序树\"><a href=\"#二叉排序树\" class=\"headerlink\" title=\"二叉排序树\"></a>二叉排序树</h3><p>二叉排序树(Binary Sort Tree),又称为二叉查找树。它或者是一棵空树，或者是具有下列性质的二叉树。</p>\n<p>若它的左子树不空，则左子树上所有结点的值均小于它的根结构的值；<br>若它的右子树不空，则右子树上所有结点的值均大于它的根结点的值；<br>它的左、右子树也分别为二叉排序树。</p>\n<p>构造一棵二叉排序树的目的，其实并不是为了排序，而是为了提高查找和插入删除关键字的速度。不管怎么说，在一个有序数据集上的查找，速度总是要快于无序的数据集的，而二叉排序树这种非线性的结构，也有利于插入和删除的实现。</p>\n<h3 id=\"平衡二叉树-AVL树\"><a href=\"#平衡二叉树-AVL树\" class=\"headerlink\" title=\"平衡二叉树(AVL树)\"></a>平衡二叉树(AVL树)</h3><p>平衡二叉树(Self-Balancing Binary Search Tree或Height-Balanced Binary Search Tree),是一种二叉排序树，其中每一个节点的左子树和右子树的高度差至多等于1。</p>\n<p>距离插入结点最近的，且平衡因子的绝对值大于1的结点为根的子树，我们称为<strong>最小不平衡子树</strong>。</p>\n<h4 id=\"平衡二叉树实现原理\"><a href=\"#平衡二叉树实现原理\" class=\"headerlink\" title=\"平衡二叉树实现原理\"></a>平衡二叉树实现原理</h4><p>平衡二叉树构建的基本思想就是在构建二叉排序树的过程中，每当插入一个结点时，先检查是否因插入而破坏了树的平衡性，若是，则找出最小不平衡子树。在保持二叉排序树特性的前提下，调整最小不平衡子树中各结点之间的链接关系，进行相应的旋转，使之成为新的平衡子树。</p>\n<h3 id=\"多路查找树-B树\"><a href=\"#多路查找树-B树\" class=\"headerlink\" title=\"多路查找树(B树)\"></a>多路查找树(B树)</h3><p>多路查找树(muitl-way search tree),其每一个结点的孩子数可以多于两个，且每一个结点处可以存储多个元素。由于它是查找树，所有元素之间存在某种特定的排序关系。</p>\n<p><strong>2-3树</strong></p>\n<p>2-3树是这样的一棵多路查找树：其中的每一个结点都具有两个孩子（我们称它为2结点)或三个孩子（我们称它为3结点）。</p>\n<p><strong>2-3-4树</strong></p>\n<p>它其实就是2-3树的概念扩展，包括了4结点的使用。一个4结点包含小中大三个元素和四个孩子（或没有孩子），一个4结点要么没有孩子，要么具有4个孩子。如果某个4结点有孩子的话，左子树包含小于最小元素的元素；第二子树包含大于最小元素，小于第二元素的元素；第三子树包含大于第二元素，小于最大元素的元素；右子树包含大于最大元素的元素。</p>\n<p><strong>B树</strong></p>\n<p>B树(B-ree)是一种平衡的多路查找树，2-3树和2-3-4树都是B树的特例。结点最大的孩子数目称为B树的阶(order)，因此，2-3树是3阶B树，2-3-4树是4阶B树。</p>\n<p><strong>B+树</strong></p>\n<p>B+树是应文件系统所需而出的一种B树的变形树，注意严格意义上讲，它其实已经不是第六章定义的树了。在B树中，每一个元素在该树中只出现一次，有可能在叶子结点上，也有可能在分支结点上。而在B+树中，出现在分支结点中的元素会被当作它们在该分支结点位置的中序后继者（叶子结点）中再次列出。另外，每一个叶子结点都会保存一个指向后一叶子结点的指针。</p>\n<h3 id=\"散列表查找（哈希表）概述\"><a href=\"#散列表查找（哈希表）概述\" class=\"headerlink\" title=\"散列表查找（哈希表）概述\"></a>散列表查找（哈希表）概述</h3><p>散列技术是在记录的存储位置和它的关键字之间建立一个确定的对应关系￡，使得每个关键字key对应一个存储位置f(key)。查找时，根据这个确定的对应关系找到给定值key的映射f(key),若查找集合中存在这个记录，则必定在f(key)的位置上。</p>\n<p>这里我们把这种对应关系f称为散列函数，又称为哈希(Hash)函数。按这个思想，采用散列技术将记录存储在一块连续的存储空间中，这块连续存储空间称为散列表或哈希表(Hash table)。那么关键字对应的记录存储位置我们称为散列地址。</p>\n<p>整个散列过程其实就是两步：</p>\n<p>(1)在存储时，通过散列函数计算记录的散列地址，并按此散列地址存储该记录。总之，不管什么记录，我们都需要用同一个散列函数计算出地址再存储。</p>\n<p>(2)当查找记录时，我们通过同样的散列函数计算记录的散列地址，按此散列地址访问该记录。说起来很简单，在哪存的，上哪去找，由于存取用的是同一个散列函数，因此结果当然也是相同的。</p>\n<p>所以说，散列技术既是一种存储方法，也是一种查找方法。</p>\n<p>散列技术最适合的求解问题是查找与给定值相等的记录。</p>\n<h3 id=\"散列函数的构造方法\"><a href=\"#散列函数的构造方法\" class=\"headerlink\" title=\"散列函数的构造方法\"></a>散列函数的构造方法</h3><p>什么才算是好的散列函数呢？1、计算简单；2、散列地址分布均匀</p>\n<ol>\n<li><p>直接定址法</p>\n</li>\n<li><p>数字分析法</p>\n</li>\n<li><p>平方取中法</p>\n</li>\n<li><p>折叠法</p>\n</li>\n<li><p>除留余数法</p>\n</li>\n<li><p>随机数法</p>\n</li>\n</ol>\n<p>总之，现实中，应该视不同的情况采用不同的散列函数。我们只能给出一些考虑的因素来提供参考：<br>1.计算散列地址所需的时间。<br>2.关键字的长度。<br>3.散列表的大小。<br>4.关键字的分布情况。<br>5.记录查找的频率。综合这些因素，才能决策选择哪种散列函数更合适。</p>\n<h3 id=\"处理散列冲突的方法\"><a href=\"#处理散列冲突的方法\" class=\"headerlink\" title=\"处理散列冲突的方法\"></a>处理散列冲突的方法</h3><ol>\n<li>开放定址法</li>\n</ol>\n<p>所谓的开放定址法就是一旦发生了冲突，就去寻找下一个空的散列地址，只要散列表足够大，空的散列地址总能找到，并将记录存入。</p>\n<ol start=\"2\">\n<li>再散列函数法</li>\n</ol>\n<p>事先准备多个散列函数。每当发生散列地址冲突时，就换一个散列函数计算，相信总会有一个可以把冲突解决掉。这种方法能够使得关键字不产生聚集，当然，相应地也增加了计算的时间。</p>\n<ol start=\"3\">\n<li>链地址法</li>\n</ol>\n<p>将所有关键字为同义词的记录存储在一个单链表中，我们称这种表为同义词子表，在散列表中只存储所有同义词子表的头指针。</p>\n<ol start=\"4\">\n<li>公共溢出区法</li>\n</ol>\n<p>为所有冲突的关键字建立了一个公共的溢出区来存放。</p>\n<h3 id=\"散列表查找实现\"><a href=\"#散列表查找实现\" class=\"headerlink\" title=\"散列表查找实现\"></a>散列表查找实现</h3><p>散列表查找性能分析：在实际的应用中，冲突是不可避免的。那么散列查找的平均查找长度取决于哪些因素呢？</p>\n<p>1.散列函数是否均匀</p>\n<p>散列函数的好坏直接影响着出现冲突的频繁程度，不过，由于不同的散列函数对同一组随机的关键字，产生冲突的可能性是相同的，因此我们可以不考虑它对平均查找长度的影响。</p>\n<p>2.处理冲突的方法</p>\n<p>相同的关键字、相同的散列函数，但处理冲突的方法不同，会使得平均查找长度不同。比如线性探测处理冲突可能会产生堆积，显然就没有二次探测法好，而链地址法处理冲突不会产生任何堆积，因而具有更佳的平均查找性能。</p>\n<p>3.散列表的装填因子</p>\n<p>所谓的装填因子α&#x3D;填入表中的记录个数&#x2F;散列表长度。α标志着散列表的装满的程度。当填入表中的记录越多，α就越大，产生冲突的可能性就越大。也就是说，散列表的平均查找长度取决于装填因子，而不是取决于查找集合中的记录个数。</p>\n<p>散列表是一种非常高效的查找数据结构，在原理上也与前面的查找不尽相同，它回避了关键字之间反复比较的烦琐，而是直接一步到位查找结果。当然，这也就带来了记录之间没有任何关联的弊端。应该说，散列表对于那种查找性能要求高，记录之间关系无要求的数据有非常好的适用性。在学习中要注意的是散列函数的选择和处理冲突的方法。</p>\n<h2 id=\"排序\"><a href=\"#排序\" class=\"headerlink\" title=\"排序\"></a>排序</h2><p>假设含有n个记录的序列为{r,r2,…,rn}，其相应的关键字分别为{k1,k2,…,kn},需确定1,2，…，n的一种排列p1,P2,…,pn,使其相应的关键字满足kp1≤kp2≤…≤kpn(非递减或非递增)关系，即使得序列成为一个按关键字有序的序列{r1,r2,…,rn},这样的操作就称为排序。</p>\n<h3 id=\"排序基本概念与分类\"><a href=\"#排序基本概念与分类\" class=\"headerlink\" title=\"排序基本概念与分类\"></a>排序基本概念与分类</h3><h4 id=\"排序的稳定性\"><a href=\"#排序的稳定性\" class=\"headerlink\" title=\"排序的稳定性\"></a>排序的稳定性</h4><p>也正是由于排序不仅是针对主关键字，那么对于次关键字，因为待排序的记录序列中可能存在两个或两个以上的关键字相等的记录，排序结果可能会存在不唯一的情况，我们给出了稳定与不稳定排序的定义。</p>\n<h4 id=\"内外排序\"><a href=\"#内外排序\" class=\"headerlink\" title=\"内外排序\"></a>内外排序</h4><p>内排序是在排序整个过程中，待排序的所有记录全部被放置在内存中。外排序是由于排序的记录个数太多，不能同时放置在内存，整个排序过程需要在内外存之间多次交换数据才能进行。</p>\n<p>对于内排序来说，排序算法的性能主要是受3个方面影响：<br>1.时间性能<br>2.辅助空间<br>3.算法的复杂性</p>\n<p>根据排序过程中借助的主要操作，我们把内排序分为：<strong>插入排序、交换排序、选择排序和归并排序</strong>。</p>\n<h3 id=\"冒泡排序\"><a href=\"#冒泡排序\" class=\"headerlink\" title=\"冒泡排序\"></a>冒泡排序</h3><p>冒泡排序(Bubble Sort)一种交换排序，它的基本思想是：两两比较相邻记录的关键字，如果反序则交换，直到没有反序的记录为止。</p>\n<h3 id=\"简单选择排序\"><a href=\"#简单选择排序\" class=\"headerlink\" title=\"简单选择排序\"></a>简单选择排序</h3><p>简单选择排序法(Simple Selection Sort)就是通过n一i次关键字间的比较，从n-i+1个记录中选出关键字最小的记录，并和第i（1&lt;i&lt;n)个记录交换之。</p>\n<h3 id=\"直接插入排序\"><a href=\"#直接插入排序\" class=\"headerlink\" title=\"直接插入排序\"></a>直接插入排序</h3><p>直接插入排序(Straight Insertion Sort)的基本操作是将一个记录插入到已经排好序的有序表中，从而得到一个新的、记录数增1的有序表。</p>\n<h3 id=\"希尔排序\"><a href=\"#希尔排序\" class=\"headerlink\" title=\"希尔排序\"></a>希尔排序</h3><p>在这之前排序算法的时间复杂度基本都是O(n^2)的，希尔排序算法是突破这个时间复杂度的第一批算法之一。</p>\n<p>所谓的<strong>基本有序</strong>，就是小的关键字基本在前面，大的基本在后面，不大不小的基本在中间，像{2,1,3,6,4,7,5,8,9}这样可以称为基本有序了。但像{1,5,9,3,7,8,2,4,6]这样的9在第三位，2在倒数第三位就谈不上基本有序。问题其实也就在这里，我们分割待排序记录的目的是减少待排序记录的个数，并使整个序列向基本有序发展。而如上面这样分完组后就各自排序的方法达不到我们的要求。因此，我们需要采取跳跃分割的策略：<strong>将相距某个“增量”的记录组成一个子序列，这样才能保证在子序列内分别进行直接插入排序后得到的结果是基本有序而不是局部有序。</strong></p>\n<p>希尔排序的精华所在，它将关键字较小的记录，不是一步一步地往前挪动，而是跳跃式地往前移，从而使得每次完成一轮循环后，整个序列就朝着有序坚实地迈进一步。</p>\n<h3 id=\"堆排序\"><a href=\"#堆排序\" class=\"headerlink\" title=\"堆排序\"></a>堆排序</h3><p>堆是具有下列性质的完全二叉树：每个结点的值都大于或等于其左右孩子结点的值，称为大顶堆；或者每个结点的值都小于或等于其左右孩子结点的值，称为小顶堆</p>\n<p>堆排序(Heap Sort)就是利用堆（假设利用大顶堆）进行排序的方法。它的基本思想是，将待排序的序列构造成一个大顶堆。此时，整个序列的最大值就是堆顶的根结点。将它移走（其实就是将其与堆数组的末尾元素交换，此时末尾元素就是最大值)，然后将剩余的n-1个序列重新构造成一个堆，这样就会得到n个元素中的次小值。如此反复执行，便能得到一个有序序列了。</p>\n<h3 id=\"归并排序\"><a href=\"#归并排序\" class=\"headerlink\" title=\"归并排序\"></a>归并排序</h3><p>归并排序(Merging Sort)就是利用归并的思想实现的排序方法。它的原理是假设初始序列含有n个记录，则可以看成是个有序的子序列，每个子序列的长度为1,然后两两归并，得到<a href=\"%E3%80%8Cx%5D%E8%A1%A8%E7%A4%BA%E4%B8%8D%E5%B0%8F%E4%BA%8Ex%E7%9A%84%E6%9C%80%E5%B0%8F%E6%95%B4%E6%95%B0\">n&#x2F;2</a>个长度为2或1的有序子序列；再两两归并，…，如此重复，直至得到一个长度为的有序序列为止，这种排序方法称为2路归并排序。</p>\n<h3 id=\"快速排序\"><a href=\"#快速排序\" class=\"headerlink\" title=\"快速排序\"></a>快速排序</h3><p>快速排序(Quick Sort)的基本思想是：通过一趟排序将待排记录分割成独立的两部分，其中一部分记录的关键字均比另一部分记录的关键字小，则可分别对这两部分记录继续进行排序，以达到整个序列有序的目的。</p>\n<h4 id=\"快速排序优化\"><a href=\"#快速排序优化\" class=\"headerlink\" title=\"快速排序优化\"></a>快速排序优化</h4><p>快速排序还是有不少可以改进的地方，我们来看一些优化的方案：</p>\n<p>1.优化选取枢轴</p>\n<p>2.优化不必要的交换</p>\n<p>3.优化小数组时的排序方案</p>\n<p>4.优化递归操作</p>\n<h3 id=\"总结-6\"><a href=\"#总结-6\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>根据排序过程中借助的主要操作，我们将内排序分为：插入排序、交换排序、选择排序和归并排序四类。之后介绍的7种排序法，就分别是各种分类的代表算法。</p>\n<img src=\"D:\\Desktop\\assets\\image-20230802231244678.png\" alt=\"image-20230802231244678\" style=\"zoom:80%;\" />\n\n<img src=\"D:\\Desktop\\assets\\image-20230802231558329.png\" alt=\"image-20230802231558329\" style=\"zoom:80%;\" />\n\n<p>最后送大家电影《当幸福来敲门》中的一句话：<br>You got a dream,you gotta protect it.People can’t do something themselves,theywanna tell you you can’t do it.If you want something,go get it.Period<br>(如果你有梦想的话，就要去捍卫它。当别人做不到的时候，他们就想要告诉你，你也不能。如果你想要些什么，就得去努力争取。就这样！)</p>\n","feature":true,"text":"程序 = 数据结构 + 算法...","link":"","photos":[],"count_time":{"symbolsCount":"16k","symbolsTime":"15 mins."},"categories":[{"name":"编程","slug":"编程","count":6,"path":"api/categories/编程.json"}],"tags":[{"name":"数据结构","slug":"数据结构","count":1,"path":"api/tags/数据结构.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E7%BB%AA%E8%AE%BA\"><span class=\"toc-text\">绪论</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E7%AE%97%E6%B3%95\"><span class=\"toc-text\">算法</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E7%9A%84%E8%A6%81%E6%B1%82\"><span class=\"toc-text\">算法设计的要求</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E7%AE%97%E6%B3%95%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6\"><span class=\"toc-text\">算法时间复杂度</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E7%AE%97%E6%B3%95%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6\"><span class=\"toc-text\">算法空间复杂度</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%80%BB%E7%BB%93\"><span class=\"toc-text\">总结</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E7%BA%BF%E6%80%A7%E8%A1%A8\"><span class=\"toc-text\">线性表</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E7%BA%BF%E6%80%A7%E8%A1%A8%E7%9A%84%E9%A1%BA%E5%BA%8F%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84\"><span class=\"toc-text\">线性表的顺序存储结构</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E7%BA%BF%E6%80%A7%E8%A1%A8%E7%9A%84%E9%93%BE%E5%BC%8F%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84\"><span class=\"toc-text\">线性表的链式存储结构</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E9%9D%99%E6%80%81%E9%93%BE%E8%A1%A8\"><span class=\"toc-text\">静态链表</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A8\"><span class=\"toc-text\">循环链表</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8\"><span class=\"toc-text\">双向链表</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%80%BB%E7%BB%93-1\"><span class=\"toc-text\">总结</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97\"><span class=\"toc-text\">栈与队列</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%A0%88\"><span class=\"toc-text\">栈</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E9%80%92%E5%BD%92\"><span class=\"toc-text\">递归</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E9%98%9F%E5%88%97\"><span class=\"toc-text\">队列</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%BE%AA%E7%8E%AF%E9%98%9F%E5%88%97\"><span class=\"toc-text\">循环队列</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%80%BB%E7%BB%93-2\"><span class=\"toc-text\">总结</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%B8%B2\"><span class=\"toc-text\">串</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%B8%B2%E7%9A%84%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84\"><span class=\"toc-text\">串的存储结构</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%9C%B4%E7%B4%A0%E6%A8%A1%E5%BC%8F%E5%8C%B9%E9%85%8D%E7%AE%97%E6%B3%95\"><span class=\"toc-text\">朴素模式匹配算法</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#KMP%E6%A8%A1%E5%BC%8F%E5%8C%B9%E9%85%8D%E7%AE%97%E6%B3%95\"><span class=\"toc-text\">KMP模式匹配算法</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%80%BB%E7%BB%93-3\"><span class=\"toc-text\">总结</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%A0%91\"><span class=\"toc-text\">树</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%A0%91%E7%9A%84%E5%AE%9A%E4%B9%89\"><span class=\"toc-text\">树的定义</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E7%BB%93%E7%82%B9%E5%88%86%E7%B1%BB\"><span class=\"toc-text\">结点分类</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E7%BB%93%E7%82%B9%E9%97%B4%E5%85%B3%E7%B3%BB\"><span class=\"toc-text\">结点间关系</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E5%B1%82%E6%AC%A1%E3%80%81%E6%B7%B1%E5%BA%A6\"><span class=\"toc-text\">层次、深度</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E7%BA%BF%E6%80%A7%E7%BB%93%E6%9E%84%E5%92%8C%E6%A0%91%E7%BB%93%E6%9E%84%E5%AF%B9%E6%AF%94\"><span class=\"toc-text\">线性结构和树结构对比</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%A0%91%E7%9A%84%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84\"><span class=\"toc-text\">树的存储结构</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%BA%8C%E5%8F%89%E6%A0%91\"><span class=\"toc-text\">二叉树</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%89%B9%E7%82%B9\"><span class=\"toc-text\">二叉树特点</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E4%BA%8C%E5%8F%89%E6%A0%91%E5%9F%BA%E6%9C%AC%E5%BD%A2%E6%80%81\"><span class=\"toc-text\">二叉树基本形态</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E7%89%B9%E6%AE%8A%E4%BA%8C%E5%8F%89%E6%A0%91\"><span class=\"toc-text\">特殊二叉树</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%80%A7%E8%B4%A8\"><span class=\"toc-text\">二叉树的性质</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84\"><span class=\"toc-text\">二叉树的存储结构</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E9%81%8D%E5%8E%86%E4%BA%8C%E5%8F%89%E6%A0%91\"><span class=\"toc-text\">遍历二叉树</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%BB%BA%E7%AB%8B\"><span class=\"toc-text\">二叉树的建立</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E7%BA%BF%E7%B4%A2%E4%BA%8C%E5%8F%89%E6%A0%91\"><span class=\"toc-text\">线索二叉树</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E6%A0%91%E3%80%81%E6%A3%AE%E6%9E%97%E4%B8%8E%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E8%BD%AC%E6%8D%A2\"><span class=\"toc-text\">树、森林与二叉树的转换</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E6%A0%91%E4%B8%8E%E6%A3%AE%E6%9E%97%E7%9A%84%E9%81%8D%E5%8E%86\"><span class=\"toc-text\">树与森林的遍历</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E8%B5%AB%E5%A4%AB%E6%9B%BC%E6%A0%91\"><span class=\"toc-text\">赫夫曼树</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%80%BB%E7%BB%93-4\"><span class=\"toc-text\">总结</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%9B%BE\"><span class=\"toc-text\">图</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%9B%BE%E7%9A%84%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84\"><span class=\"toc-text\">图的存储结构</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%9B%BE%E7%9A%84%E9%81%8D%E5%8E%86\"><span class=\"toc-text\">图的遍历</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91\"><span class=\"toc-text\">最小生成树</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84\"><span class=\"toc-text\">最短路径</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F\"><span class=\"toc-text\">拓扑排序</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%85%B3%E9%94%AE%E8%B7%AF%E5%BE%84\"><span class=\"toc-text\">关键路径</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%80%BB%E7%BB%93-5\"><span class=\"toc-text\">总结</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%9F%A5%E6%89%BE\"><span class=\"toc-text\">查找</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%9F%A5%E6%89%BE%E6%A6%82%E8%AE%BA\"><span class=\"toc-text\">查找概论</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E9%A1%BA%E5%BA%8F%E8%A1%A8%E6%9F%A5%E6%89%BE\"><span class=\"toc-text\">顺序表查找</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%9C%89%E5%BA%8F%E8%A1%A8%E6%9F%A5%E6%89%BE\"><span class=\"toc-text\">有序表查找</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E7%BA%BF%E6%80%A7%E7%B4%A2%E5%BC%95%E6%9F%A5%E6%89%BE\"><span class=\"toc-text\">线性索引查找</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%BA%8C%E5%8F%89%E6%8E%92%E5%BA%8F%E6%A0%91\"><span class=\"toc-text\">二叉排序树</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91-AVL%E6%A0%91\"><span class=\"toc-text\">平衡二叉树(AVL树)</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86\"><span class=\"toc-text\">平衡二叉树实现原理</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%A4%9A%E8%B7%AF%E6%9F%A5%E6%89%BE%E6%A0%91-B%E6%A0%91\"><span class=\"toc-text\">多路查找树(B树)</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%95%A3%E5%88%97%E8%A1%A8%E6%9F%A5%E6%89%BE%EF%BC%88%E5%93%88%E5%B8%8C%E8%A1%A8%EF%BC%89%E6%A6%82%E8%BF%B0\"><span class=\"toc-text\">散列表查找（哈希表）概述</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%95%A3%E5%88%97%E5%87%BD%E6%95%B0%E7%9A%84%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95\"><span class=\"toc-text\">散列函数的构造方法</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%A4%84%E7%90%86%E6%95%A3%E5%88%97%E5%86%B2%E7%AA%81%E7%9A%84%E6%96%B9%E6%B3%95\"><span class=\"toc-text\">处理散列冲突的方法</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%95%A3%E5%88%97%E8%A1%A8%E6%9F%A5%E6%89%BE%E5%AE%9E%E7%8E%B0\"><span class=\"toc-text\">散列表查找实现</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%8E%92%E5%BA%8F\"><span class=\"toc-text\">排序</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%8E%92%E5%BA%8F%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%E4%B8%8E%E5%88%86%E7%B1%BB\"><span class=\"toc-text\">排序基本概念与分类</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E6%8E%92%E5%BA%8F%E7%9A%84%E7%A8%B3%E5%AE%9A%E6%80%A7\"><span class=\"toc-text\">排序的稳定性</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E5%86%85%E5%A4%96%E6%8E%92%E5%BA%8F\"><span class=\"toc-text\">内外排序</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F\"><span class=\"toc-text\">冒泡排序</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E7%AE%80%E5%8D%95%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F\"><span class=\"toc-text\">简单选择排序</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E7%9B%B4%E6%8E%A5%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F\"><span class=\"toc-text\">直接插入排序</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F\"><span class=\"toc-text\">希尔排序</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%A0%86%E6%8E%92%E5%BA%8F\"><span class=\"toc-text\">堆排序</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F\"><span class=\"toc-text\">归并排序</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F\"><span class=\"toc-text\">快速排序</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F%E4%BC%98%E5%8C%96\"><span class=\"toc-text\">快速排序优化</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%80%BB%E7%BB%93-6\"><span class=\"toc-text\">总结</span></a></li></ol></li></ol>","author":{"name":"Dxc","slug":"blog-author","avatar":"/images/avatar.png","link":"/","description":"Free will is not free. <br /> @ <b>公众号：精准拔草</b>","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"定投改变命运","uid":"36e36a9eaf0d14bae53980c65f21589f","slug":"定投改变命运","date":"2023-08-13T14:09:53.000Z","updated":"2023-08-23T14:09:53.000Z","comments":true,"path":"api/articles/定投改变命运.json","keywords":null,"cover":"/images/dingtou.jpg","text":"让时间陪你慢慢变富...","link":"","photos":[],"count_time":{"symbolsCount":"57k","symbolsTime":"52 mins."},"categories":[{"name":"投资","slug":"投资","count":2,"path":"api/categories/投资.json"}],"tags":[{"name":"定投","slug":"定投","count":1,"path":"api/tags/定投.json"}],"author":{"name":"Dxc","slug":"blog-author","avatar":"/images/avatar.png","link":"/","description":"Free will is not free. <br /> @ <b>公众号：精准拔草</b>","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"feature":true},"next_post":{}}