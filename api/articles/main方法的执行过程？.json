{"title":"main方法的执行过程","uid":"65b687dd3d4339b7fde24382cc20cfcd","slug":"main方法的执行过程？","date":"2023-08-13T14:09:53.000Z","updated":"2023-08-13T14:09:53.000Z","comments":true,"path":"api/articles/main方法的执行过程？.json","keywords":null,"cover":"/images/log.jpg","content":"<h1 id=\"main方法的执行过程\"><a href=\"#main方法的执行过程\" class=\"headerlink\" title=\"main方法的执行过程\"></a><strong>main方法的执行过程</strong></h1><p>示例代码：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class Application &#123;   \n    public static void main(String[] args) &#123;     \n        Person p &#x3D; new Person(&quot;大&quot;);     \n        p.getName();   \n    &#125; \n&#125; \n\nclass Person &#123;   \n    public String name;    \n    public Person(String name) &#123;     \n        this.name &#x3D; name;   \n    &#125;    \n    public String getName() &#123;     \n        return this.name;   \n    &#125; \n&#125;</code></pre>\n\n\n\n<p>执行方法的过程如下:</p>\n<ol>\n<li>编译Application.java后得到 Application.class 后，执行这个class文件，系统会启动一个 JVM 进程，从类路径中找到一个名为 Application.class 的二进制文件，将 Application 类信息加载到运行时数据区的方法区内，这个过程叫做类的加载。</li>\n<li>JVM 找到 Application 的主程序入口，执行main方法。</li>\n<li>main方法的第一条语句为 Person p &#x3D; new Person(“大彬”)，就是让 JVM 创建一个Person对象，但是这个时候方法区中是没有 Person 类的信息的，所以 JVM 马上加载 Person 类，把 Person 类的信息放到方法区中。</li>\n<li>加载完 Person 类后，JVM 在堆中分配内存给 Person 对象，然后调用构造函数初始化 Person 对象，这个 Person 对象持有<strong>指向方法区中的 Person 类的类型信息</strong>的引用。</li>\n<li>执行p.getName()时，JVM 根据 p 的引用找到 p 所指向的对象，然后根据此对象持有的引用定位到方法区中 Person 类的类型信息的方法表，获得 getName() 的字节码地址。</li>\n<li>执行getName()方法。</li>\n</ol>\n","feature":true,"text":"当执行Java程序时，JVM通过类加载将类信息存入方法区，在堆中实例化对象，并通过对象的方法表动态分派方法调用，最终执行目标方法的字节码指令。...","link":"","photos":[],"count_time":{"symbolsCount":990,"symbolsTime":"1 mins."},"categories":[{"name":"编程","slug":"编程","count":17,"path":"api/categories/编程.json"}],"tags":[{"name":"Java","slug":"Java","count":9,"path":"api/tags/Java.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#main%E6%96%B9%E6%B3%95%E7%9A%84%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B\"><span class=\"toc-text\">main方法的执行过程</span></a></li></ol>","author":{"name":"Dxc","slug":"blog-author","avatar":"/images/avatar.png","link":"/","description":"Free will is not free. <br /> @ <b>公众号：精准拔草</b>","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"Hexo搭建教程","uid":"df1735ddd145ba1e06d4d73a3e7ead6d","slug":"hexo","date":"2023-08-15T14:09:53.000Z","updated":"2023-08-13T14:09:53.000Z","comments":true,"path":"api/articles/hexo.json","keywords":null,"cover":"/images/hexo&github.jpg","text":"Hexo食用指南，搭建博客，看这一篇就够了。...","link":"","photos":[],"count_time":{"symbolsCount":"3.2k","symbolsTime":"3 mins."},"categories":[{"name":"博客","slug":"博客","count":1,"path":"api/categories/博客.json"}],"tags":[{"name":"hexo","slug":"hexo","count":1,"path":"api/tags/hexo.json"}],"author":{"name":"Dxc","slug":"blog-author","avatar":"/images/avatar.png","link":"/","description":"Free will is not free. <br /> @ <b>公众号：精准拔草</b>","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"feature":true},"next_post":{"title":"日志打印规范","uid":"c485bd4f49932d84ed7995b0e167ee8b","slug":"日志打印","date":"2023-07-15T14:09:53.000Z","updated":"2023-07-15T14:09:53.000Z","comments":true,"path":"api/articles/日志打印.json","keywords":null,"cover":"/images/log.jpg","text":"打印日志最佳实践...","link":"","photos":[],"count_time":{"symbolsCount":"16k","symbolsTime":"14 mins."},"categories":[{"name":"编程","slug":"编程","count":17,"path":"api/categories/编程.json"}],"tags":[{"name":"日志","slug":"日志","count":1,"path":"api/tags/日志.json"}],"author":{"name":"Dxc","slug":"blog-author","avatar":"/images/avatar.png","link":"/","description":"Free will is not free. <br /> @ <b>公众号：精准拔草</b>","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}}}