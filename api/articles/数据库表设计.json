{"title":"数据库表设计","uid":"f4ac3a4a311e597d05998bb126be956f","slug":"数据库表设计","date":"2023-09-15T14:09:53.000Z","updated":"2023-09-13T14:09:53.000Z","comments":true,"path":"api/articles/数据库表设计.json","keywords":null,"cover":"/images/database.jpg","content":"<h3 id=\"命名规范\"><a href=\"#命名规范\" class=\"headerlink\" title=\"命名规范\"></a>命名规范</h3><p>数据库表名、字段名、索引名等都需要命名规范，可读性高(一般要求用英文)，让别人一看命名，就知道这个字段表示什么意思。</p>\n<ul>\n<li><p>表名、字段名必须使用小写字母或者数字，禁止使用数字开头，禁止使用拼音，并且一般不使用英文缩写。</p>\n</li>\n<li><p>主键索引名为pk_字段名；唯一索引名为uk_字段名；普通索引名则为idx_字段名。</p>\n</li>\n</ul>\n<h3 id=\"选择合适的字段类型\"><a href=\"#选择合适的字段类型\" class=\"headerlink\" title=\"选择合适的字段类型\"></a>选择合适的字段类型</h3><p>设计表时，我们需要选择合适的字段类型，比如：</p>\n<ul>\n<li><p>尽可能选择存储空间小的字段类型，就好像数字类型的，从tinyint、smallint、int、bigint从左往右开始选择</p>\n</li>\n<li><p>小数类型如金额，则选择 decimal，禁止使用 float 和 double。</p>\n</li>\n<li><p>如果存储的字符串长度几乎相等，使用 char 定长字符串类型。</p>\n</li>\n<li><p>varchar是可变长字符串，不预先分配存储空间，长度不要超过5000。</p>\n</li>\n<li><p>如果存储的值太大，建议字段类型修改为text，同时抽出单独一张表，用主键与之对应。</p>\n</li>\n<li><p>同一表中，所有varchar字段的长度加起来，不能大于65535. 如果有这样的需求，请使用TEXT&#x2F;LONGTEXT 类型。</p>\n</li>\n</ul>\n<h3 id=\"主键设计要合理\"><a href=\"#主键设计要合理\" class=\"headerlink\" title=\"主键设计要合理\"></a>主键设计要合理</h3><p>主键设计的话，最好不要与业务逻辑有所关联。有些业务上的字段，比如身份证，虽然是唯一的，一些开发者喜欢用它来做主键，但是不是很建议哈。主键最好是毫无意义的一串独立不重复的数字，比如UUID，又或者Auto_increment自增的主键，或者是雪花算法生成的主键等等;</p>\n<h3 id=\"选择合适的字段长度\"><a href=\"#选择合适的字段长度\" class=\"headerlink\" title=\"选择合适的字段长度\"></a>选择合适的字段长度</h3><p>先问大家一个问题，大家知道数据库字段长度表示字符长度还是字节长度嘛？</p>\n<p>其实在mysql中，varchar和char类型表示字符长度，而其他类型表示的长度都表示字节长度。比如char(10)表示字符长度是10，而bigint（4）表示显示长度是4个字节，但是因为bigint实际长度是8个字节，所以bigint（4）的实际长度就是8个字节。</p>\n<p>我们在设计表的时候，需要充分考虑一个字段的长度，比如一个用户名字段（它的长度5~20个字符），你觉得应该设置多长呢？可以考虑设置为 username varchar（32）。字段长度一般设置为2的幂哈（也就是2的n次方）。</p>\n<h3 id=\"优先考虑逻辑删除，而不是物理删除\"><a href=\"#优先考虑逻辑删除，而不是物理删除\" class=\"headerlink\" title=\"优先考虑逻辑删除，而不是物理删除\"></a>优先考虑逻辑删除，而不是物理删除</h3><p>什么是物理删除？什么是逻辑删除？</p>\n<ul>\n<li>物理删除：把数据从硬盘中删除，可释放存储空间</li>\n<li>逻辑删除：给数据添加一个字段，比如is_deleted，以标记该数据已经逻辑删除。</li>\n</ul>\n<p>物理删除就是执行delete语句。</p>\n<p>逻辑删除：每个表都需要添加这几个通用字段。如主键、create_time、modifed_time等</p>\n<p>表必备一般来说，或具备这几个字段：</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>id：主键，一个表必须得有主键，必须</p>\n<p>create_time：创建时间，必须</p>\n<p>modifed_time: 修改时间，必须，更新记录时，需要更新它</p>\n<p>version : 数据记录的版本号，用于乐观锁，非必须</p>\n<p>remark ：数据记录备注，非必须</p>\n<p>modified_by :修改人，非必须</p>\n<p>creator ：创建人，非必须</p></blockquote>\n<h3 id=\"一张表的字段不宜过多\"><a href=\"#一张表的字段不宜过多\" class=\"headerlink\" title=\"一张表的字段不宜过多\"></a>一张表的字段不宜过多</h3><p>我们建表的时候，要牢记，一张表的字段不宜过多哈，一般尽量不要超过20个字段哈。</p>\n<p>如果一张表的字段过多，表中保存的数据可能就会很大，查询效率就会很低。因此，一张表不要设计太多字段哈，如果业务需求，实在需要很多字段，可以把一张大的表，拆成多张小的表，它们的主键相同即可。</p>\n<p>当表的字段数非常多时，可以将表分成两张表，一张作为条件查询表，一张作为详细内容表 (主要是为了性能考虑)。</p>\n<h3 id=\"尽可能使用not-null定义字段\"><a href=\"#尽可能使用not-null定义字段\" class=\"headerlink\" title=\"尽可能使用not null定义字段\"></a>尽可能使用not null定义字段</h3><p>如果没有特殊的理由， 一般都建议将字段定义为 NOT NULL 。为什么呢？</p>\n<p>首先， NOT NULL 可以防止出现空指针问题。</p>\n<p>其次，NULL值存储也需要额外的空间的，它也会导致比较运算更为复杂，使优化器难以优化SQL。</p>\n<p>NULL值有可能会导致索引失效</p>\n<p>如果将字段默认设置成一个空字符串或常量值并没有什么不同，且都不会影响到应用逻辑，那就可以将这个字段设置为NOT NULL。</p>\n<h3 id=\"设计表时，评估哪些字段需要加索引\"><a href=\"#设计表时，评估哪些字段需要加索引\" class=\"headerlink\" title=\"设计表时，评估哪些字段需要加索引\"></a>设计表时，评估哪些字段需要加索引</h3><p>首先，评估你的表数据量。如果你的表数据量只有一百几十行，就没有必要加索引。否则设计表的时候，如果有查询条件的字段，一般就需要建立索引。但是索引也不能滥用：</p>\n<ul>\n<li><p>索引也不要建得太多，一般单表索引个数不要超过5个。因为创建过多的索引，会降低写得速度。</p>\n</li>\n<li><p>区分度不高的字段，不能加索引，如性别等</p>\n</li>\n<li><p>索引创建完后，还是要注意避免索引失效的情况，如使用mysql的内置函数，会导致索引失效的</p>\n</li>\n<li><p>索引过多的话，可以通过联合索引的话方式来优化。然后的话，索引还有一些规则，如覆盖索引，最左匹配原则等等。</p>\n</li>\n</ul>\n<p>假设你新建一张用户表，如下：对于这张表，很可能会有根据user_id或者name查询用户信息，并且，user_id是唯一的。因此，你是可以给user_id加上唯一索引，name加上普通索引。</p>\n<h3 id=\"不需要严格遵守-3NF\"><a href=\"#不需要严格遵守-3NF\" class=\"headerlink\" title=\"不需要严格遵守 3NF\"></a>不需要严格遵守 3NF</h3><p>不需要严格遵守 3NF，通过业务字段冗余来减少表关联 </p>\n<ul>\n<li><p>第一范式：对属性的原子性，要求属性具有原子性，不可再分解；</p>\n</li>\n<li><p>第二范式：对记录的唯一性，要求记录有唯一标识，即实体的唯一性，即不存在部分依赖；</p>\n</li>\n<li><p>第三方式：对字段的冗余性，要求任何字段不能由其他字段派生出来，它要求字段没有冗余，即不存在传递依赖；</p>\n</li>\n</ul>\n<p>我们设计表及其字段之间的关系, 应尽量满足第三范式。但是有时候，可以适当冗余，来提高效率。比如以下这张表</p>\n<table>\n<thead>\n<tr>\n<th>商品名称</th>\n<th>商品型号</th>\n<th>单价</th>\n<th>数量</th>\n<th>总金额</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>手机</td>\n<td>华为</td>\n<td>8000</td>\n<td>5</td>\n<td>40000</td>\n</tr>\n</tbody></table>\n<p>以上这张存放商品信息的基本表。总金额这个字段的存在，表明该表的设计不满足第三范式，因为总金额可以由单价*数量得到，说明总金额是冗余字段。但是，增加总金额这个冗余字段，可以提高查询统计的速度，这就是以空间换时间的作法。</p>\n<h3 id=\"避免使用MySQL保留字\"><a href=\"#避免使用MySQL保留字\" class=\"headerlink\" title=\"避免使用MySQL保留字\"></a>避免使用MySQL保留字</h3><p>如果库名、表名、字段名等属性含有保留字时，SQL语句必须用反引号来引用属性名称，这将使得SQL语句书写、SHELL脚本中变量的转义等变得非常复杂。</p>\n<p>因此，我们一般避免使用MySQL保留字，如select、interval、desc等等</p>\n<h3 id=\"不搞外键关联，一般都在代码维护\"><a href=\"#不搞外键关联，一般都在代码维护\" class=\"headerlink\" title=\"不搞外键关联，一般都在代码维护\"></a>不搞外键关联，一般都在代码维护</h3><p>什么是外键呢？外键，也叫FOREIGN KEY，它是用于将两个表连接在一起的键。FOREIGN KEY是一个表中的一个字段（或字段集合），它引用另一个表中的PRIMARY KEY。它是用来保证数据的一致性和完整性的。</p>\n<p>阿里的Java规范也有这么一条：</p>\n<p>【强制】不得使用外键与级联，一切外键概念必须在应用层解决。</p>\n<p>我们为什么不推荐使用外键呢？</p>\n<ul>\n<li><p>使用外键存在性能问题、并发死锁问题、使用起来不方便等等。每次做DELETE或者UPDATE都必须考虑外键约束，会导致开发的时候很难受,测试数据造数据也不方便。</p>\n</li>\n<li><p>还有一个场景不能使用外键，就是分库分表。</p>\n</li>\n</ul>\n<h3 id=\"一般都选择INNODB存储引擎\"><a href=\"#一般都选择INNODB存储引擎\" class=\"headerlink\" title=\"一般都选择INNODB存储引擎\"></a>一般都选择INNODB存储引擎</h3><p>建表是需要选择存储引擎的，我们一般都选择INNODB存储引擎，除非读写比率小于1%, 才考虑使用MyISAM 。</p>\n<p>有些小伙伴可能会有疑惑，不是还有MEMORY等其他存储引擎吗？什么时候使用它呢？其实其他存储引擎一般除了都建议在DBA的指导下使用。</p>\n<p>我们来复习一下这MySQL这三种存储引擎的对比区别吧：</p>\n<table>\n<thead>\n<tr>\n<th>特性</th>\n<th>INNODB</th>\n<th>MyISAM</th>\n<th>MEMORY</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>事务安全</td>\n<td>支持</td>\n<td>无</td>\n<td>无</td>\n</tr>\n<tr>\n<td>存储限制</td>\n<td>64TB</td>\n<td>有</td>\n<td>有</td>\n</tr>\n<tr>\n<td>空间使用</td>\n<td>高</td>\n<td>低</td>\n<td>低</td>\n</tr>\n<tr>\n<td>内存使用</td>\n<td>高</td>\n<td>低</td>\n<td>高</td>\n</tr>\n<tr>\n<td>插入数据速度</td>\n<td>低</td>\n<td>高</td>\n<td>高</td>\n</tr>\n<tr>\n<td>是否支持外键</td>\n<td>支持</td>\n<td>无</td>\n<td>无</td>\n</tr>\n</tbody></table>\n<h3 id=\"选择合适统一的字符集。\"><a href=\"#选择合适统一的字符集。\" class=\"headerlink\" title=\"选择合适统一的字符集。\"></a>选择合适统一的字符集。</h3><p>数据库库、表、开发程序等都需要统一字符集，通常中英文环境用utf8。</p>\n<p>MySQL支持的字符集有utf8、utf8mb4、GBK、latin1等。</p>\n<ul>\n<li><p>utf8：支持中英文混合场景，国际通过，3个字节长度</p>\n</li>\n<li><p>utf8mb4:完全兼容utf8，4个字节长度，一般存储emoji表情需要用到它。</p>\n</li>\n<li><p>GBK ：支持中文，但是不支持国际通用字符集，2个字节长度</p>\n</li>\n<li><p>latin1：MySQL默认字符集，1个字节长度</p>\n</li>\n</ul>\n<p>如果你的数据库字段是枚举类型的，需要在comment注释清楚 </p>\n<p>如果你设计的数据库字段是枚举类型的话，就需要在comment后面注释清楚每个枚举的意思，以便于维护。</p>\n<h3 id=\"时间的类型选择\"><a href=\"#时间的类型选择\" class=\"headerlink\" title=\"时间的类型选择\"></a>时间的类型选择</h3><p>我们设计表的时候，一般都需要加通用时间的字段，如create_time、modified_time等等。那对于时间的类型，我们该如何选择呢？</p>\n<p>对于MySQL来说，主要有date、datetime、time、timestamp 和 year。</p>\n<ul>\n<li><p>date ：表示的日期值, 格式yyyy-mm-dd,范围1000-01-01 到 9999-12-31，3字节</p>\n</li>\n<li><p>time ：表示的时间值，格式 hh:mm:ss，范围-838:59:59 到 838:59:59，3字节</p>\n</li>\n<li><p>datetime：表示的日期时间值，格式yyyy-mm-dd hh:mm:ss，范围1000-01-01 00:00:00到9999-12-31 23:59:59&#96;&#96;&#96;,8字节，跟时区无关</p>\n</li>\n<li><p>timestamp：表示的时间戳值，格式为yyyymmddhhmmss，范围1970-01-01 00:00:01到2038-01-19 03:14:07，4字节，跟时区有关</p>\n</li>\n<li><p>year：年份值，格式为yyyy。范围1901到2155，1字节</p>\n</li>\n</ul>\n<p>推荐优先使用datetime类型来保存日期和时间，因为存储范围更大，且跟时区无关。</p>\n<h3 id=\"不建议使用存储过程，触发器\"><a href=\"#不建议使用存储过程，触发器\" class=\"headerlink\" title=\"不建议使用存储过程，触发器\"></a>不建议使用存储过程，触发器</h3><p>存储过程：已预编译为一个可执行过程的一个或多个SQL语句。</p>\n<p>触发器，指一段代码，当触发某个事件时，自动执行这些代码。使用场景：</p>\n<ul>\n<li><p>可以通过数据库中的相关表实现级联更改。</p>\n</li>\n<li><p>实时监控某张表中的某个字段的更改而需要做出相应的处理。例如可以生成某些业务的编号。</p>\n</li>\n</ul>\n<p>注意不要滥用，否则会造成数据库及应用程序的维护困难。</p>\n<p>对于MYSQL来说，存储过程、触发器等还不是很成熟，并没有完善的出错记录处理，不建议使用。</p>\n<h3 id=\"1-N-关系的设计\"><a href=\"#1-N-关系的设计\" class=\"headerlink\" title=\"1:N 关系的设计\"></a>1:N 关系的设计</h3><p>日常开发中，1对多的关系应该是非常常见的。比如一个班级有多个学生，一个部门有多个员工等等。这种的建表原则就是：在从表（N的这一方）创建一个字段，以字段作为外键指向主表（1的这一方）的主键。</p>\n<p>学生表是多（N）的一方，会有个字段class_id保存班级表的主键。当然，一班不加外键约束哈，只是单纯保存这个关系而已。</p>\n<p>有时候两张表存在N:N关系时，我们应该消除这种关系。通过增加第三张表，把N:N修改为两个 1:N。比如图书和读者，是一个典型的多对多的关系。一本书可以被多个读者借，一个读者又可以借多本书。我们就可以设计一个借书表，包含图书表的主键，以及读者的主键，以及借还标记等字段。</p>\n<h3 id=\"大字段\"><a href=\"#大字段\" class=\"headerlink\" title=\"大字段\"></a>大字段</h3><p>设计表的时候，我们尤其需要关注一些大字段，即占用较多存储空间的字段。比如用来记录用户评论的字段，又或者记录博客内容的字段，又或者保存合同数据的字段。如果直接把表字段设计成text类型的话，就会浪费存储空间，查询效率也不好。</p>\n<p>在MySQl中，这种方式保存的设计方案，其实是不太合理的。这种非常大的数据，可以保存到mongodb中，然后，在业务表保存对应mongodb的id即可。</p>\n<p>这种设计思想类似于，我们表字段保存图片时，为什么不是保存图片内容，而是直接保存图片url即可。</p>\n<h3 id=\"考虑是否需要分库分表\"><a href=\"#考虑是否需要分库分表\" class=\"headerlink\" title=\"考虑是否需要分库分表\"></a>考虑是否需要分库分表</h3><p>什么是分库分表呢？</p>\n<p>分库：就是一个数据库分成多个数据库，部署到不同机器。</p>\n<p>分表：就是一个数据库表分成多个表。</p>\n<p>我们在设计表的时候，其实可以提前估算一下，是否需要做分库分表。比如一些用户信息，未来可能数据量到达百万设置千万的话，就可以提前考虑分库分表。</p>\n<p>为什么需要分库分表: 数据量太大的话，SQL的查询就会变慢。如果一个查询SQL没命中索引，千百万数据量级别的表可能会拖垮整个数据库。即使SQL命中了索引，如果表的数据量超过一千万的话，查询也是会明显变慢的。这是因为索引一般是B+树结构，数据千万级别的话，B+树的高度会增高，查询就变慢啦。</p>\n<p>分库分表主要有水平拆分、垂直拆分的说法，拆分策略有range范围、hash取模。而分库分表主要有这些问题：</p>\n<ul>\n<li><p>事务问题</p>\n</li>\n<li><p>跨库关联</p>\n</li>\n<li><p>排序问题</p>\n</li>\n<li><p>分页问题</p>\n</li>\n<li><p>分布式ID</p>\n</li>\n</ul>\n<h3 id=\"sqL-编写的一些优化经验\"><a href=\"#sqL-编写的一些优化经验\" class=\"headerlink\" title=\"sqL 编写的一些优化经验\"></a>sqL 编写的一些优化经验</h3><p>最后的话，跟大家聊来一些写SQL的经验吧：</p>\n<ul>\n<li><p>查询SQL尽量不要使用select *，而是select具体字段</p>\n</li>\n<li><p>如果知道查询结果只有一条或者只要最大&#x2F;最小一条记录，建议用limit 1</p>\n</li>\n<li><p>应尽量避免在where子句中使用or来连接条件</p>\n</li>\n<li><p>注意优化limit深分页问题</p>\n</li>\n<li><p>使用where条件限定要查询的数据，避免返回多余的行</p>\n</li>\n<li><p>尽量避免在索引列上使用mysql的内置函数</p>\n</li>\n<li><p>应尽量避免在 where子句中对字段进行表达式操作</p>\n</li>\n<li><p>应尽量避免在where 子句中使用!&#x3D;或&lt;&gt;操作符</p>\n</li>\n<li><p>使用联合索引时，注意索引列的顺序，一般遵循最左匹配原则。</p>\n</li>\n<li><p>对查询进行优化，应考虑在where 及 order by涉及的列上建立索引</p>\n</li>\n<li><p>如果插入数据过多，考虑批量插入</p>\n</li>\n<li><p>在适当的时候，使用覆盖索引</p>\n</li>\n<li><p>使用explain分析你SQL的计划</p>\n</li>\n</ul>\n","text":"数据库表设计...","link":"","photos":[],"count_time":{"symbolsCount":"5.4k","symbolsTime":"5 mins."},"categories":[{"name":"编程","slug":"编程","count":6,"path":"api/categories/编程.json"}],"tags":[{"name":"数据库","slug":"数据库","count":1,"path":"api/tags/数据库.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%91%BD%E5%90%8D%E8%A7%84%E8%8C%83\"><span class=\"toc-text\">命名规范</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E9%80%89%E6%8B%A9%E5%90%88%E9%80%82%E7%9A%84%E5%AD%97%E6%AE%B5%E7%B1%BB%E5%9E%8B\"><span class=\"toc-text\">选择合适的字段类型</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%B8%BB%E9%94%AE%E8%AE%BE%E8%AE%A1%E8%A6%81%E5%90%88%E7%90%86\"><span class=\"toc-text\">主键设计要合理</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E9%80%89%E6%8B%A9%E5%90%88%E9%80%82%E7%9A%84%E5%AD%97%E6%AE%B5%E9%95%BF%E5%BA%A6\"><span class=\"toc-text\">选择合适的字段长度</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%BC%98%E5%85%88%E8%80%83%E8%99%91%E9%80%BB%E8%BE%91%E5%88%A0%E9%99%A4%EF%BC%8C%E8%80%8C%E4%B8%8D%E6%98%AF%E7%89%A9%E7%90%86%E5%88%A0%E9%99%A4\"><span class=\"toc-text\">优先考虑逻辑删除，而不是物理删除</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%B8%80%E5%BC%A0%E8%A1%A8%E7%9A%84%E5%AD%97%E6%AE%B5%E4%B8%8D%E5%AE%9C%E8%BF%87%E5%A4%9A\"><span class=\"toc-text\">一张表的字段不宜过多</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%B0%BD%E5%8F%AF%E8%83%BD%E4%BD%BF%E7%94%A8not-null%E5%AE%9A%E4%B9%89%E5%AD%97%E6%AE%B5\"><span class=\"toc-text\">尽可能使用not null定义字段</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E8%AE%BE%E8%AE%A1%E8%A1%A8%E6%97%B6%EF%BC%8C%E8%AF%84%E4%BC%B0%E5%93%AA%E4%BA%9B%E5%AD%97%E6%AE%B5%E9%9C%80%E8%A6%81%E5%8A%A0%E7%B4%A2%E5%BC%95\"><span class=\"toc-text\">设计表时，评估哪些字段需要加索引</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%B8%8D%E9%9C%80%E8%A6%81%E4%B8%A5%E6%A0%BC%E9%81%B5%E5%AE%88-3NF\"><span class=\"toc-text\">不需要严格遵守 3NF</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E9%81%BF%E5%85%8D%E4%BD%BF%E7%94%A8MySQL%E4%BF%9D%E7%95%99%E5%AD%97\"><span class=\"toc-text\">避免使用MySQL保留字</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%B8%8D%E6%90%9E%E5%A4%96%E9%94%AE%E5%85%B3%E8%81%94%EF%BC%8C%E4%B8%80%E8%88%AC%E9%83%BD%E5%9C%A8%E4%BB%A3%E7%A0%81%E7%BB%B4%E6%8A%A4\"><span class=\"toc-text\">不搞外键关联，一般都在代码维护</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%B8%80%E8%88%AC%E9%83%BD%E9%80%89%E6%8B%A9INNODB%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E\"><span class=\"toc-text\">一般都选择INNODB存储引擎</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E9%80%89%E6%8B%A9%E5%90%88%E9%80%82%E7%BB%9F%E4%B8%80%E7%9A%84%E5%AD%97%E7%AC%A6%E9%9B%86%E3%80%82\"><span class=\"toc-text\">选择合适统一的字符集。</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%97%B6%E9%97%B4%E7%9A%84%E7%B1%BB%E5%9E%8B%E9%80%89%E6%8B%A9\"><span class=\"toc-text\">时间的类型选择</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%B8%8D%E5%BB%BA%E8%AE%AE%E4%BD%BF%E7%94%A8%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B%EF%BC%8C%E8%A7%A6%E5%8F%91%E5%99%A8\"><span class=\"toc-text\">不建议使用存储过程，触发器</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-N-%E5%85%B3%E7%B3%BB%E7%9A%84%E8%AE%BE%E8%AE%A1\"><span class=\"toc-text\">1:N 关系的设计</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%A4%A7%E5%AD%97%E6%AE%B5\"><span class=\"toc-text\">大字段</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E8%80%83%E8%99%91%E6%98%AF%E5%90%A6%E9%9C%80%E8%A6%81%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8\"><span class=\"toc-text\">考虑是否需要分库分表</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#sqL-%E7%BC%96%E5%86%99%E7%9A%84%E4%B8%80%E4%BA%9B%E4%BC%98%E5%8C%96%E7%BB%8F%E9%AA%8C\"><span class=\"toc-text\">sqL 编写的一些优化经验</span></a></li></ol>","author":{"name":"Dxc","slug":"blog-author","avatar":"/images/avatar.png","link":"/","description":"Free will is not free. <br /> @ <b>公众号：精准拔草</b>","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"日志打印规范","uid":"c485bd4f49932d84ed7995b0e167ee8b","slug":"日志打印","date":"2023-09-15T14:09:53.000Z","updated":"2023-09-13T14:09:53.000Z","comments":true,"path":"api/articles/日志打印.json","keywords":null,"cover":"/images/log.jpg","text":"打印日志最佳实践...","link":"","photos":[],"count_time":{"symbolsCount":"16k","symbolsTime":"14 mins."},"categories":[{"name":"编程","slug":"编程","count":6,"path":"api/categories/编程.json"}],"tags":[{"name":"日志","slug":"日志","count":1,"path":"api/tags/日志.json"}],"author":{"name":"Dxc","slug":"blog-author","avatar":"/images/avatar.png","link":"/","description":"Free will is not free. <br /> @ <b>公众号：精准拔草</b>","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},"next_post":{"title":"《SQL必知必会》笔记","uid":"b1ee10c76787892cad9c78ea248d0ee5","slug":"SQL必知必会","date":"2023-08-21T14:09:53.000Z","updated":"2023-08-21T14:09:53.000Z","comments":true,"path":"api/articles/SQL必知必会.json","keywords":null,"cover":"/images/sql.jpg","text":"《SQL必知必会》笔记...","link":"","photos":[],"count_time":{"symbolsCount":"8.6k","symbolsTime":"8 mins."},"categories":[{"name":"编程","slug":"编程","count":6,"path":"api/categories/编程.json"}],"tags":[{"name":"SQL","slug":"SQL","count":1,"path":"api/tags/SQL.json"}],"author":{"name":"Dxc","slug":"blog-author","avatar":"/images/avatar.png","link":"/","description":"Free will is not free. <br /> @ <b>公众号：精准拔草</b>","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}}}