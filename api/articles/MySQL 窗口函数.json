{"title":"MySQL 窗口函数","uid":"dbefc43bced81fc187b5f397d9f0c92a","slug":"MySQL 窗口函数","date":"2023-12-28T14:09:53.000Z","updated":"2023-12-28T14:09:53.000Z","comments":true,"path":"api/articles/MySQL 窗口函数.json","keywords":null,"cover":"/images/sql.jpg","content":"<h1 id=\"MySQL-窗口函数\"><a href=\"#MySQL-窗口函数\" class=\"headerlink\" title=\"MySQL 窗口函数\"></a>MySQL 窗口函数</h1><p>先看这段像天书一样的 SQL ,看着就头疼。</p>\n<pre class=\"line-numbers language-mysql\" data-language=\"mysql\"><code class=\"language-mysql\">SELECT\n  s1.name,\n  s1.subject,\n  s1.score,\n  sub.avg_score AS average_score_per_subject,\n  (SELECT COUNT(DISTINCT s2.score) + 1 FROM scores s2 WHERE s2.score &gt; s1.score) AS score_rank\nFROM scores s1\nJOIN (\n  SELECT subject, AVG(score) AS avg_score\n  FROM scores\n  GROUP BY subject\n) sub ON s1.subject &#x3D; sub.subject\nORDER BY s1.score DESC;  </code></pre>\n\n<p>这段SQL是干什么用的呢，就是为了计算一个成绩排名，简直大动干戈啊。</p>\n<p>那有没有简化的方法呢?有的。</p>\n<p>简化后的版本就是利用今天说的窗口函数。</p>\n<pre class=\"line-numbers language-mysql\" data-language=\"mysql\"><code class=\"language-mysql\">SELECT\n  name,\n  subject,\n  score,\n  AVG(score) OVER (PARTITION BY subject) AS average_score_per_subject,\n  RANK() OVER (ORDER BY score DESC) AS score_rank\nFROM scores\nORDER BY score DESC;</code></pre>\n\n<p>是不是看上去就简洁清晰多了。</p>\n<p><strong>下面我们看看是什么样的功能。</strong></p>\n<p>首先创建一个表，包含姓名、学科、分数三个字段，用于后面功能的演示。</p>\n<pre class=\"line-numbers language-mysql\" data-language=\"mysql\"><code class=\"language-mysql\">CREATE TABLE &#96;scores&#96; (\n  &#96;name&#96; varchar(20) COLLATE utf8_bin NOT NULL,\n  &#96;subject&#96; varchar(20) COLLATE utf8_bin NOT NULL,\n  &#96;score&#96; int(3) NOT NULL\n) ENGINE&#x3D;InnoDB DEFAULT CHARSET&#x3D;utf8 COLLATE&#x3D;utf8_bin;</code></pre>\n\n<p>然后向表中插入一些随机记录。</p>\n<pre class=\"line-numbers language-mysql\" data-language=\"mysql\"><code class=\"language-mysql\">INSERT INTO scores (name, subject, score) VALUES (&#39;Student1&#39;, &#39;化学&#39;, 75);\nINSERT INTO scores (name, subject, score) VALUES (&#39;Student2&#39;, &#39;生物&#39;, 92);\nINSERT INTO scores (name, subject, score) VALUES (&#39;Student3&#39;, &#39;物理&#39;, 87);\nINSERT INTO scores (name, subject, score) VALUES (&#39;Student4&#39;, &#39;数学&#39;, 68);\nINSERT INTO scores (name, subject, score) VALUES (&#39;Student5&#39;, &#39;英语&#39;, 91);\nINSERT INTO scores (name, subject, score) VALUES (&#39;Student6&#39;, &#39;化学&#39;, 58);\nINSERT INTO scores (name, subject, score) VALUES (&#39;Student7&#39;, &#39;物理&#39;, 79);\nINSERT INTO scores (name, subject, score) VALUES (&#39;Student8&#39;, &#39;数学&#39;, 90);\nINSERT INTO scores (name, subject, score) VALUES (&#39;Student9&#39;, &#39;数学&#39;, 45);</code></pre>\n\n<h2 id=\"什么是窗口函数\"><a href=\"#什么是窗口函数\" class=\"headerlink\" title=\"什么是窗口函数\"></a>什么是窗口函数</h2><p>在 MySQL 8.x 版本中，MySQL 提供了窗口函数，窗口函数是一种在查询结果的特定窗口范围内进行计算的函数。</p>\n<p>很早以前用 Oracle 和 MS SQL 的时候会用到里面的窗口函数，但是用 MySQL 后才发现，MySQL 竟然没有窗口函数，以至于一些负责的统计查询都要用各种子查询、join，层层嵌套，看上去很简单的需求，结果搞得 SQL 语句写的是龙飞凤舞，别人一看跟天书似的。就一个字儿，<strong>懵</strong>。</p>\n<p>窗口函数主要的应用场景是统计和计算，例如对查询结果进行分组、排序和计算聚合，通过各个函数的组合，可以实现各种复杂的逻辑，而且比起 MySQL 8.0之前用子查询、join 的方式，性能上要好得多。</p>\n<h2 id=\"OVER\"><a href=\"#OVER\" class=\"headerlink\" title=\"OVER()\"></a>OVER()</h2><p>OVER() 是用于定义窗口函数的子句，它必须结合其他的函数才有意义，比如求和、求平均数。而它只用于指定要计算的数据范围和排序方式。</p>\n<pre class=\"line-numbers language-mysql\" data-language=\"mysql\"><code class=\"language-mysql\">function_name(...) OVER (\n    [PARTITION BY expr_list] \n    [ORDER BY expr_list] \n    [range]\n)</code></pre>\n\n<h3 id=\"PARTITION-BY\"><a href=\"#PARTITION-BY\" class=\"headerlink\" title=\"PARTITION BY\"></a>PARTITION BY</h3><p>用于指定分区字段,对不同分区进行分析计算，分区其实就列，可以指定一个列，也可以指定多个列。</p>\n<h3 id=\"ORDER-BY\"><a href=\"#ORDER-BY\" class=\"headerlink\" title=\"ORDER BY\"></a>ORDER BY</h3><p>用于对分区内记录进行排序,排序后可以与「范围和滚动窗口」一起使用。</p>\n<h3 id=\"范围和滚动窗口\"><a href=\"#范围和滚动窗口\" class=\"headerlink\" title=\"范围和滚动窗口\"></a>范围和滚动窗口</h3><p>用于指定分析函数的窗口,包括范围和滚动窗口。</p>\n<h3 id=\"范围窗口-Range-window\"><a href=\"#范围窗口-Range-window\" class=\"headerlink\" title=\"范围窗口(Range window)\"></a>范围窗口(Range window)</h3><p>指定窗口的起止行号,使用UNBOUNDED PRECEDING表示起点,UNBOUNDED FOLLOWING表示终点。</p>\n<p>例如:</p>\n<pre class=\"line-numbers language-mysql\" data-language=\"mysql\"><code class=\"language-mysql\">SUM(salary) OVER (ORDER BY id  \n                   RANGE BETWEEN 5 PRECEDING AND 5 FOLLOWING)</code></pre>\n\n<p>这会计算当前行及之前5行和之后5行的salary总和。</p>\n<h3 id=\"滚动窗口-Row-window\"><a href=\"#滚动窗口-Row-window\" class=\"headerlink\" title=\"滚动窗口(Row window)\"></a>滚动窗口(Row window)</h3><p>使用了基于当前行的滚动窗口</p>\n<p>例如:</p>\n<pre class=\"line-numbers language-mysql\" data-language=\"mysql\"><code class=\"language-mysql\">SUM(salary) OVER (ORDER BY id  \n                   ROWS BETWEEN 2 PRECEDING AND 2 FOLLOWING)</code></pre>\n\n<p>这会计算当前行及之前2行和之后2行的salary总和。</p>\n<h3 id=\"OVER-可搭配的函数：\"><a href=\"#OVER-可搭配的函数：\" class=\"headerlink\" title=\"OVER()可搭配的函数：\"></a>OVER()可搭配的函数：</h3><p><strong>聚合函数</strong></p>\n<p>MAX(),MIN(),COUNT(),SUM()等，用于生成每个分区的聚合结果。</p>\n<p><strong>排序相关</strong></p>\n<p>ROW_NUMBER(),RANK(),DENSE_RANK()等，用于生成每个分区的行号或排名。</p>\n<p><strong>窗口函数</strong></p>\n<p>LAG(),LEAD(),FIRST_VALUE(),LAST_VALUE()等，用于基于窗口框生成结果。</p>\n<h2 id=\"搭配聚合函数\"><a href=\"#搭配聚合函数\" class=\"headerlink\" title=\"搭配聚合函数\"></a>搭配聚合函数</h2><p>1、按<code>subject</code>列进行分区，并求出某学科的最大最小值</p>\n<p>获取分数和此学科最高分</p>\n<pre class=\"line-numbers language-mysql\" data-language=\"mysql\"><code class=\"language-mysql\">SELECT subject,score, MAX(score) OVER (PARTITION  BY subject) as &#96;此学科最高分&#96; FROM scores;</code></pre>\n\n<p>得出的结果是:</p>\n<table>\n<thead>\n<tr>\n<th>subject</th>\n<th>score</th>\n<th>此学科最高分</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>化学</td>\n<td>75</td>\n<td>75</td>\n</tr>\n<tr>\n<td>化学</td>\n<td>58</td>\n<td>75</td>\n</tr>\n<tr>\n<td>数学</td>\n<td>68</td>\n<td>90</td>\n</tr>\n<tr>\n<td>数学</td>\n<td>90</td>\n<td>90</td>\n</tr>\n<tr>\n<td>数学</td>\n<td>45</td>\n<td>90</td>\n</tr>\n<tr>\n<td>物理</td>\n<td>87</td>\n<td>87</td>\n</tr>\n<tr>\n<td>物理</td>\n<td>79</td>\n<td>87</td>\n</tr>\n<tr>\n<td>生物</td>\n<td>92</td>\n<td>92</td>\n</tr>\n<tr>\n<td>英语</td>\n<td>91</td>\n<td>91</td>\n</tr>\n</tbody></table>\n<p>2、获取学科的报名人数</p>\n<pre class=\"line-numbers language-mysql\" data-language=\"mysql\"><code class=\"language-mysql\">SELECT subject,score, count(name) OVER (PARTITION  BY subject) as &#96;报名此学科人数&#96; FROM scores;</code></pre>\n\n<p>得到的结果为:</p>\n<table>\n<thead>\n<tr>\n<th>subject</th>\n<th>score</th>\n<th>报名此学科人数</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>化学</td>\n<td>75</td>\n<td>2</td>\n</tr>\n<tr>\n<td>化学</td>\n<td>58</td>\n<td>2</td>\n</tr>\n<tr>\n<td>数学</td>\n<td>68</td>\n<td>3</td>\n</tr>\n<tr>\n<td>数学</td>\n<td>90</td>\n<td>3</td>\n</tr>\n<tr>\n<td>数学</td>\n<td>45</td>\n<td>3</td>\n</tr>\n<tr>\n<td>物理</td>\n<td>87</td>\n<td>2</td>\n</tr>\n<tr>\n<td>物理</td>\n<td>79</td>\n<td>2</td>\n</tr>\n<tr>\n<td>生物</td>\n<td>92</td>\n<td>1</td>\n</tr>\n<tr>\n<td>英语</td>\n<td>91</td>\n<td>1</td>\n</tr>\n</tbody></table>\n<p>3、求学科的总分</p>\n<pre class=\"line-numbers language-mysql\" data-language=\"mysql\"><code class=\"language-mysql\">SELECT subject, SUM(score) OVER (PARTITION  BY subject) as &#96;此学科总分&#96; FROM scores;</code></pre>\n\n<p>得到的结果:</p>\n<table>\n<thead>\n<tr>\n<th>subject</th>\n<th>此学科总分</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>化学</td>\n<td>133</td>\n</tr>\n<tr>\n<td>化学</td>\n<td>133</td>\n</tr>\n<tr>\n<td>数学</td>\n<td>203</td>\n</tr>\n<tr>\n<td>数学</td>\n<td>203</td>\n</tr>\n<tr>\n<td>数学</td>\n<td>203</td>\n</tr>\n<tr>\n<td>物理</td>\n<td>166</td>\n</tr>\n<tr>\n<td>物理</td>\n<td>166</td>\n</tr>\n<tr>\n<td>生物</td>\n<td>92</td>\n</tr>\n<tr>\n<td>英语</td>\n<td>91</td>\n</tr>\n</tbody></table>\n<p>4、使用 order by 求累加分数</p>\n<pre class=\"line-numbers language-mysql\" data-language=\"mysql\"><code class=\"language-mysql\">SELECT name,subject,score, SUM(score) OVER (order  BY score) as &#96;累加分数&#96; FROM scores;</code></pre>\n\n<p>得到的结果：</p>\n<table>\n<thead>\n<tr>\n<th>name</th>\n<th>subject</th>\n<th>score</th>\n<th>累加分数</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Student9</td>\n<td>数学</td>\n<td>45</td>\n<td>45</td>\n</tr>\n<tr>\n<td>Student6</td>\n<td>化学</td>\n<td>58</td>\n<td>103</td>\n</tr>\n<tr>\n<td>Student4</td>\n<td>数学</td>\n<td>68</td>\n<td>171</td>\n</tr>\n</tbody></table>\n<p>我们看这是怎么算出来的，OVER 函数里面是 order by 。</p>\n<p>首先根据分数排序（默认升序），得到第一行分数是45，所以累加分数就是它自己，也就是45。</p>\n<p>然后排序得到第二行 58，然后将第一行和第二行相加，这样得到累加分数就是45+58&#x3D;103。</p>\n<p>同理，第三行就是前三行的总和，也就是45+58+68&#x3D;171。</p>\n<p>以此类推，第 N 行就是1~N的累加和。</p>\n<p>5、使用 order by + 范围</p>\n<p>前面因为没有限定范围，所以就是前 N 行的累加，还可以限定范围。</p>\n<pre class=\"line-numbers language-mysql\" data-language=\"mysql\"><code class=\"language-mysql\">SELECT name,subject,score, SUM(score) OVER (order BY &#96;score&#96; ROWS BETWEEN 1 PRECEDING AND 1 FOLLOWING) as &#96;累加分数&#96; FROM scores;</code></pre>\n\n<p>这里的累加分数是指当前行+前一行+后一行的和。</p>\n<p>获取的结果为：</p>\n<table>\n<thead>\n<tr>\n<th>name</th>\n<th>subject</th>\n<th>score</th>\n<th>累加分数</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Student9</td>\n<td>数学</td>\n<td>45</td>\n<td>103</td>\n</tr>\n<tr>\n<td>Student6</td>\n<td>化学</td>\n<td>58</td>\n<td>171</td>\n</tr>\n<tr>\n<td>Student4</td>\n<td>数学</td>\n<td>68</td>\n<td>201</td>\n</tr>\n<tr>\n<td>Student1</td>\n<td>化学</td>\n<td>75</td>\n<td>222</td>\n</tr>\n<tr>\n<td>Student7</td>\n<td>物理</td>\n<td>79</td>\n<td>241</td>\n</tr>\n<tr>\n<td>Student3</td>\n<td>物理</td>\n<td>87</td>\n<td>256</td>\n</tr>\n<tr>\n<td>Student8</td>\n<td>数学</td>\n<td>90</td>\n<td>268</td>\n</tr>\n<tr>\n<td>Student5</td>\n<td>英语</td>\n<td>91</td>\n<td>273</td>\n</tr>\n</tbody></table>\n<p>第一行 103，是当前行 45+后一行（58）的和，等于103，因为没有前一行。</p>\n<p>第二行171，是当前行58+前一行（45）+后一行（68）的和，等于171。</p>\n<p>以此类型，后面的累加分数都是这样算出来的。</p>\n<h2 id=\"搭配排序相关函数\"><a href=\"#搭配排序相关函数\" class=\"headerlink\" title=\"搭配排序相关函数\"></a>搭配排序相关函数</h2><h3 id=\"ROW-NUMBER\"><a href=\"#ROW-NUMBER\" class=\"headerlink\" title=\"ROW_NUMBER()\"></a>ROW_NUMBER()</h3><p>ROW_NUMBER() 函数用于为结果集中的每一行分配一个唯一的排序。</p>\n<p>如下，对成绩进行排名，分数高的排在前面，如果有两个人分数相同，那仍然是一个第一，另一个第二。</p>\n<pre class=\"line-numbers language-sql\" data-language=\"sql\"><code class=\"language-sql\">SELECT name,subject,score, ROW_NUMBER() OVER (order BY &#96;score&#96; desc) as &#96;排名&#96; FROM scores;</code></pre>\n\n<p>查询结果为：</p>\n<table>\n<thead>\n<tr>\n<th>name</th>\n<th>subject</th>\n<th>score</th>\n<th>排名</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Student2</td>\n<td>生物</td>\n<td>92</td>\n<td>1</td>\n</tr>\n<tr>\n<td>Student5</td>\n<td>英语</td>\n<td>91</td>\n<td>2</td>\n</tr>\n<tr>\n<td>Student8</td>\n<td>数学</td>\n<td>90</td>\n<td>3</td>\n</tr>\n<tr>\n<td>Student3</td>\n<td>物理</td>\n<td>87</td>\n<td>4</td>\n</tr>\n<tr>\n<td>Student7</td>\n<td>物理</td>\n<td>79</td>\n<td>5</td>\n</tr>\n</tbody></table>\n<p>如果不用 <code>ROW_NUMBER()</code>,比如在 MySQL 5.7的版本中，就会像下面这样:</p>\n<pre class=\"line-numbers language-mysql\" data-language=\"mysql\"><code class=\"language-mysql\">SELECT s1.name, s1.subject, s1.score, COUNT(s2.score) + 1 AS &#96;排名&#96;\nFROM scores s1\nLEFT JOIN scores s2 ON s1.score &lt; s2.score\nGROUP BY s1.name, s1.subject, s1.score\nORDER BY s1.score DESC;</code></pre>\n\n<p>是不是比使用 <code>ROW_NUMBER()</code>复杂的多。</p>\n<h3 id=\"RANK\"><a href=\"#RANK\" class=\"headerlink\" title=\"RANK()\"></a>RANK()</h3><p>RANK() 函数用于为结果集中的每一行分配一个排名值，它也是排名的，但是它和 <code>ROW_NUMBER()</code>有，<code>RANK()</code>函数在遇到相同值的行会将排名设置为相同的，就像是并列排名。</p>\n<p>就像是奥运比赛，如果有两个人都是相同的高分，那可能就是并列金牌，但是这时候就没有银牌了，仅次于这两个人的排名就会变成铜牌。</p>\n<pre class=\"line-numbers language-sql\" data-language=\"sql\"><code class=\"language-sql\">SELECT name,subject,score, RANK() OVER (order BY &#96;score&#96; desc) as &#96;排名&#96; FROM scores;</code></pre>\n\n<p>查询结果为：</p>\n<table>\n<thead>\n<tr>\n<th>name</th>\n<th>subject</th>\n<th>score</th>\n<th>排名</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Student1</td>\n<td>化学</td>\n<td>92</td>\n<td>1</td>\n</tr>\n<tr>\n<td>Student2</td>\n<td>生物</td>\n<td>92</td>\n<td>1</td>\n</tr>\n<tr>\n<td>Student5</td>\n<td>英语</td>\n<td>91</td>\n<td>3</td>\n</tr>\n<tr>\n<td>Student8</td>\n<td>数学</td>\n<td>90</td>\n<td>4</td>\n</tr>\n<tr>\n<td>Student3</td>\n<td>物理</td>\n<td>87</td>\n<td>5</td>\n</tr>\n</tbody></table>\n<h3 id=\"DENSE-RANK\"><a href=\"#DENSE-RANK\" class=\"headerlink\" title=\"DENSE_RANK()\"></a>DENSE_RANK()</h3><p>DENSE_RANK() 也是用作排名的，和 <code>RANK()</code>函数的差别就是遇到相同值的时候，不会跳过排名，比如两个人是并列金牌，排名都是1，那仅次于这两个人的排名就是2，而不像 <code>RANK()</code>那样是3。</p>\n<pre class=\"line-numbers language-sql\" data-language=\"sql\"><code class=\"language-sql\">SELECT name,subject,score, DENSE_RANK() OVER (order BY &#96;score&#96; desc) as &#96;排名&#96; FROM scores;</code></pre>\n\n<p>查询结果为：</p>\n<table>\n<thead>\n<tr>\n<th>name</th>\n<th>subject</th>\n<th>score</th>\n<th>排名</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Student1</td>\n<td>化学</td>\n<td>92</td>\n<td>1</td>\n</tr>\n<tr>\n<td>Student2</td>\n<td>生物</td>\n<td>92</td>\n<td>1</td>\n</tr>\n<tr>\n<td>Student5</td>\n<td>英语</td>\n<td>91</td>\n<td>2</td>\n</tr>\n<tr>\n<td>Student8</td>\n<td>数学</td>\n<td>90</td>\n<td>3</td>\n</tr>\n</tbody></table>\n<h2 id=\"配合其他窗口函数\"><a href=\"#配合其他窗口函数\" class=\"headerlink\" title=\"配合其他窗口函数\"></a>配合其他窗口函数</h2><h3 id=\"NTILE\"><a href=\"#NTILE\" class=\"headerlink\" title=\"NTILE()\"></a>NTILE()</h3><p>NTILE() 函数用于将结果集划分为指定数量的组，并为每个组分配一个编号。例如，将分数倒序排序并分成4个组，相当于有了4个梯队。</p>\n<pre class=\"line-numbers language-sql\" data-language=\"sql\"><code class=\"language-sql\">SELECT name,subject,score, NTILE(4) OVER (order BY &#96;score&#96; desc) as &#96;组&#96; FROM scores;</code></pre>\n\n<p>查询结果为：</p>\n<table>\n<thead>\n<tr>\n<th>name</th>\n<th>subject</th>\n<th>score</th>\n<th>组</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Student1</td>\n<td>化学</td>\n<td>92</td>\n<td>1</td>\n</tr>\n<tr>\n<td>Student2</td>\n<td>生物</td>\n<td>92</td>\n<td>1</td>\n</tr>\n<tr>\n<td>Student5</td>\n<td>英语</td>\n<td>91</td>\n<td>1</td>\n</tr>\n<tr>\n<td>Student8</td>\n<td>数学</td>\n<td>90</td>\n<td>2</td>\n</tr>\n<tr>\n<td>Student3</td>\n<td>物理</td>\n<td>87</td>\n<td>2</td>\n</tr>\n<tr>\n<td>Student7</td>\n<td>物理</td>\n<td>79</td>\n<td>3</td>\n</tr>\n<tr>\n<td>Student4</td>\n<td>数学</td>\n<td>68</td>\n<td>3</td>\n</tr>\n<tr>\n<td>Student6</td>\n<td>化学</td>\n<td>58</td>\n<td>4</td>\n</tr>\n<tr>\n<td>Student9</td>\n<td>数学</td>\n<td>45</td>\n<td>4</td>\n</tr>\n</tbody></table>\n<h3 id=\"LAG\"><a href=\"#LAG\" class=\"headerlink\" title=\"LAG()\"></a>LAG()</h3><p>LAG() 函数用于在查询结果中访问当前行之前的行的数据。它允许您检索前一行的值，并将其与当前行的值进行比较或计算差异。<code>LAG()</code>函数对于处理时间序列数据或比较相邻行的值非常有用。</p>\n<p><code>LAG()</code>函数完整的表达式为 <code>LAG(column, offset, default_value)</code>，包含三个参数：</p>\n<p>column：就是列名，获取哪个列的值就是哪个列名，很好理解。</p>\n<p>offset: 就是向前的偏移量，取当前行的前一行就是1，前前两行就是2。</p>\n<p>default_value：是可选值，如果向前偏移的行不存在，就取这个默认值。</p>\n<p>例如比较相邻两个排名的分数差，可以这样写：</p>\n<pre class=\"line-numbers language-sql\" data-language=\"sql\"><code class=\"language-sql\">SELECT\n  name,\n  subject,\n  score,\n  ABS(score - LAG(score, 1,score) OVER (ORDER BY score DESC)) AS &#96;分值差&#96;\nFROM\n  scores;</code></pre>\n\n<p>得到的结果为：</p>\n<table>\n<thead>\n<tr>\n<th>name</th>\n<th>subject</th>\n<th>score</th>\n<th>分值差</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Student1</td>\n<td>化学</td>\n<td>92</td>\n<td>0</td>\n</tr>\n<tr>\n<td>Student2</td>\n<td>生物</td>\n<td>92</td>\n<td>0</td>\n</tr>\n<tr>\n<td>Student5</td>\n<td>英语</td>\n<td>91</td>\n<td>1</td>\n</tr>\n<tr>\n<td>Student8</td>\n<td>数学</td>\n<td>90</td>\n<td>1</td>\n</tr>\n<tr>\n<td>Student3</td>\n<td>物理</td>\n<td>87</td>\n<td>3</td>\n</tr>\n<tr>\n<td>Student7</td>\n<td>物理</td>\n<td>79</td>\n<td>8</td>\n</tr>\n<tr>\n<td>Student4</td>\n<td>数学</td>\n<td>68</td>\n<td>11</td>\n</tr>\n</tbody></table>\n<h3 id=\"LEAD\"><a href=\"#LEAD\" class=\"headerlink\" title=\"LEAD()\"></a>LEAD()</h3><p><code>LEAD()</code> 函数和<code> LAG()</code>的功能一致，只不过它的偏移量是向后偏移，也就是取当前行的后 N 行。</p>\n<p>所以前面的比较相邻两行差值的逻辑，也可以向后比较。</p>\n<pre class=\"line-numbers language-mysql\" data-language=\"mysql\"><code class=\"language-mysql\">SELECT\n  name,\n  subject,\n  score,\n  score - LEAD(score, 1,score) OVER (ORDER BY score DESC) AS &#96;分值差&#96;\nFROM\n  scores;</code></pre>\n\n<p>得到的结果：</p>\n<table>\n<thead>\n<tr>\n<th>name</th>\n<th>subject</th>\n<th>score</th>\n<th>分值差</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Student1</td>\n<td>化学</td>\n<td>92</td>\n<td>0</td>\n</tr>\n<tr>\n<td>Student2</td>\n<td>生物</td>\n<td>92</td>\n<td>1</td>\n</tr>\n<tr>\n<td>Student5</td>\n<td>英语</td>\n<td>91</td>\n<td>1</td>\n</tr>\n<tr>\n<td>Student8</td>\n<td>数学</td>\n<td>90</td>\n<td>3</td>\n</tr>\n<tr>\n<td>Student3</td>\n<td>物理</td>\n<td>87</td>\n<td>8</td>\n</tr>\n<tr>\n<td>Student7</td>\n<td>物理</td>\n<td>79</td>\n<td>11</td>\n</tr>\n<tr>\n<td>Student4</td>\n<td>数学</td>\n<td>68</td>\n<td>10</td>\n</tr>\n</tbody></table>\n","feature":true,"text":"主要的应用场景是统计和计算，例如对查询结果进行分组、排序和计算聚合...","link":"","photos":[],"count_time":{"symbolsCount":"7.3k","symbolsTime":"7 mins."},"categories":[{"name":"编程","slug":"编程","count":16,"path":"api/categories/编程.json"}],"tags":[{"name":"Java","slug":"Java","count":9,"path":"api/tags/Java.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#MySQL-%E7%AA%97%E5%8F%A3%E5%87%BD%E6%95%B0\"><span class=\"toc-text\">MySQL 窗口函数</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%BB%80%E4%B9%88%E6%98%AF%E7%AA%97%E5%8F%A3%E5%87%BD%E6%95%B0\"><span class=\"toc-text\">什么是窗口函数</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#OVER\"><span class=\"toc-text\">OVER()</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#PARTITION-BY\"><span class=\"toc-text\">PARTITION BY</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#ORDER-BY\"><span class=\"toc-text\">ORDER BY</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E8%8C%83%E5%9B%B4%E5%92%8C%E6%BB%9A%E5%8A%A8%E7%AA%97%E5%8F%A3\"><span class=\"toc-text\">范围和滚动窗口</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E8%8C%83%E5%9B%B4%E7%AA%97%E5%8F%A3-Range-window\"><span class=\"toc-text\">范围窗口(Range window)</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%BB%9A%E5%8A%A8%E7%AA%97%E5%8F%A3-Row-window\"><span class=\"toc-text\">滚动窗口(Row window)</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#OVER-%E5%8F%AF%E6%90%AD%E9%85%8D%E7%9A%84%E5%87%BD%E6%95%B0%EF%BC%9A\"><span class=\"toc-text\">OVER()可搭配的函数：</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%90%AD%E9%85%8D%E8%81%9A%E5%90%88%E5%87%BD%E6%95%B0\"><span class=\"toc-text\">搭配聚合函数</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%90%AD%E9%85%8D%E6%8E%92%E5%BA%8F%E7%9B%B8%E5%85%B3%E5%87%BD%E6%95%B0\"><span class=\"toc-text\">搭配排序相关函数</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#ROW-NUMBER\"><span class=\"toc-text\">ROW_NUMBER()</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#RANK\"><span class=\"toc-text\">RANK()</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#DENSE-RANK\"><span class=\"toc-text\">DENSE_RANK()</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E9%85%8D%E5%90%88%E5%85%B6%E4%BB%96%E7%AA%97%E5%8F%A3%E5%87%BD%E6%95%B0\"><span class=\"toc-text\">配合其他窗口函数</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#NTILE\"><span class=\"toc-text\">NTILE()</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#LAG\"><span class=\"toc-text\">LAG()</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#LEAD\"><span class=\"toc-text\">LEAD()</span></a></li></ol></li></ol></li></ol>","author":{"name":"Dxc","slug":"blog-author","avatar":"/images/avatar.png","link":"/","description":"Free will is not free. <br /> @ <b>公众号：精准拔草</b>","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"文案整理","uid":"3ede5db1f2dfd6645b710a2389815e97","slug":"文章整理","date":"2024-08-14T14:09:53.000Z","updated":"2025-03-02T13:05:01.020Z","comments":true,"path":"api/articles/文章整理.json","keywords":null,"cover":"/images/ziranshengzhang.jpg","text":"回头看，轻舟已过万重山；向前看，前路漫漫亦灿灿。...","link":"","photos":[],"count_time":{"symbolsCount":"24k","symbolsTime":"22 mins."},"categories":[{"name":"成长","slug":"成长","count":2,"path":"api/categories/成长.json"}],"tags":[{"name":"文章整理","slug":"文章整理","count":2,"path":"api/tags/文章整理.json"}],"author":{"name":"Dxc","slug":"blog-author","avatar":"/images/avatar.png","link":"/","description":"Free will is not free. <br /> @ <b>公众号：精准拔草</b>","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"feature":true},"next_post":{"title":"《SQL必知必会》笔记","uid":"b1ee10c76787892cad9c78ea248d0ee5","slug":"SQL必知必会","date":"2023-08-21T14:09:53.000Z","updated":"2023-08-21T14:09:53.000Z","comments":true,"path":"api/articles/SQL必知必会.json","keywords":null,"cover":"/images/sql.jpg","text":"《SQL必知必会》笔记...","link":"","photos":[],"count_time":{"symbolsCount":"8.6k","symbolsTime":"8 mins."},"categories":[{"name":"编程","slug":"编程","count":16,"path":"api/categories/编程.json"}],"tags":[{"name":"SQL","slug":"SQL","count":1,"path":"api/tags/SQL.json"}],"author":{"name":"Dxc","slug":"blog-author","avatar":"/images/avatar.png","link":"/","description":"Free will is not free. <br /> @ <b>公众号：精准拔草</b>","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}}}