{"title":"日志打印规范","uid":"c485bd4f49932d84ed7995b0e167ee8b","slug":"日志打印","date":"2023-09-15T14:09:53.000Z","updated":"2023-09-13T14:09:53.000Z","comments":true,"path":"api/articles/日志打印.json","keywords":null,"cover":"/images/log.jpg","content":"<p>不知道大家有没有经历过这样的场景，线上出了问题，着急火燎地去排查：</p>\n<p>唉，问题可能出在这个地方，捞个日志看下，卧槽，怎么找不到……哪个**不打日志，啊，原来是我自己。</p>\n<p>日志这东西，平时看不出来什么，真要出了问题，那就是救命的稻草。这期就给大家分享一些日志相关的东西。</p>\n<h1 id=\"弄懂日志\"><a href=\"#弄懂日志\" class=\"headerlink\" title=\"弄懂日志\"></a>弄懂日志</h1><h2 id=\"什么是日志？\"><a href=\"#什么是日志？\" class=\"headerlink\" title=\"什么是日志？\"></a>什么是日志？</h2><p>日志，维基百科中对其的定义是<strong>一个或多个由服务器自动创建和维护的日志文件，其中包含其所执行活动的列表。</strong></p>\n<p>作为开发，我们都熟悉日志的重要性，良好的日志，能帮助我们快速定位到错误发生的详情和原因，并快速解决问题。</p>\n<h2 id=\"为什么要打日志？\"><a href=\"#为什么要打日志？\" class=\"headerlink\" title=\"为什么要打日志？\"></a>为什么要打日志？</h2><p>前面提到日志可以提供精准的系统记录方便根因分析，那为什么要记录日志，记录日志有哪些作用呢？</p>\n<ul>\n<li><strong>调试和排查问题</strong>：通过记录日志，可以在程序运行时打印关键变量、逻辑和流程，方便我们进行调试和排查问题。</li>\n<li><strong>监控和告警</strong>：通过对日志进行监控和分析，可以及时发现系统的异常行为和潜在问题。通过设置合适的告警规则，可以在系统发生异常或达到预警条件时及时通知开发，以便采取相应的措施。</li>\n<li><strong>用户行为审计</strong>：记录和采集用户的操作行为以及事件可以用于审计和安全监控。通过分析用户行为日志，可以了解用户的操作习惯、需求和偏好。</li>\n<li><strong>问题原因分析（甩锅）</strong>：在关键地方记录日志。方便和其它业务方解决问题的时候，获取问题的根源，及时甩锅。</li>\n</ul>\n<h2 id=\"什么时候打日志？\"><a href=\"#什么时候打日志？\" class=\"headerlink\" title=\"什么时候打日志？\"></a>什么时候打日志？</h2><p>那么一般会在什么时候打日志呢？下面列举了一些常见的场景：</p>\n<ul>\n<li><strong>系统初始化</strong>：在系统或服务的启动过程中，记录一些关键配置参数和启动完成状态，以便于排查问题和了解系统的运行情况。通常使用 INFO 级别记录。</li>\n<li><strong>异常情况</strong>：当系统遇到编程语言的异常或业务流程不符合预期时，记录日志以便于追踪和调试。根据异常的严重程度，可以使用 WARN 或 ERROR 级别记录。</li>\n<li><strong>业务流程的关键点</strong>：对于业务流程中的关键点或核心角色的动作，建议记录日志以监控系统的运行情况。比如用户从登录到下单的整个流程，微服务之间的交互，核心数据表的增删改等。通常使用 INFO 级别记录。</li>\n<li><strong>第三方服务远程调用</strong>：在微服务架构中，第三方服务的可靠性是一个重要的问题。建议记录第三方服务的请求和响应参数，以便于排查问题和定位故障。通常使用 INFO 级别记录。</li>\n</ul>\n<p>需要注意的是，日志记录的频率和打印量应根据具体情况进行评估和调整，避免日志过于频繁或过于庞大。</p>\n<h2 id=\"怎么打日志？\"><a href=\"#怎么打日志？\" class=\"headerlink\" title=\"怎么打日志？\"></a>怎么打日志？</h2><p>大家都知道，Java别的不多，就是轮子多，在Java程序里，打印日志，可以选择的方法和轮子也不少：</p>\n<ol>\n<li><code>System.out.println()</code>：将日志信息打印到标准输出流（控制台），最简单的方式，但是不灵活。</li>\n<li><code>java.util.logging</code>：Java自带的日志框架，提供了一套API用于记录日志，可以控制日志级别和输出目标。</li>\n<li>Log4j：流行的开源日志框架，提供了丰富的功能和配置选项，支持异步输出和滚动日志文件等特性。</li>\n<li>SLF4J：日志门面框架，提供了统一的API，可以与不同的日志实现进行适配。</li>\n<li>Logback：由Log4j的创始人开发的高性能日志框架，可作为SLF4J的实现。</li>\n</ol>\n<p>在项目中，一般推荐用SLF4J作为日志门面框架，和不同的日志框架进行适配，如果因为某些原因，比如前两年，Log4j曝出了大漏洞，需要进行替换和升级的时候，只需要修改相应的依赖和配置即可，而不需要修改项目里的日志记录代码。</p>\n<h2 id=\"怎么查日志？\"><a href=\"#怎么查日志？\" class=\"headerlink\" title=\"怎么查日志？\"></a>怎么查日志？</h2><p>日志打完了就得用，用就得查，那么我们打印的日志怎么查询呢？</p>\n<h3 id=\"日志文件\"><a href=\"#日志文件\" class=\"headerlink\" title=\"日志文件\"></a>日志文件</h3><p>一般通过日志框架打印日志的时候，都会配置日志输出的路径：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">&lt;appender name&#x3D;&quot;FILE&quot; class&#x3D;&quot;ch.qos.logback.core.FileAppender&quot;&gt;\n    &lt;file&gt;&#x2F;path&#x2F;to&#x2F;logs&#x2F;myapp.log&lt;&#x2F;file&gt;\n    &lt;encoder&gt;\n        &lt;pattern&gt;%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125; [%thread] %-5level %logger&#123;36&#125; - %msg%n&lt;&#x2F;pattern&gt;\n    &lt;&#x2F;encoder&gt;\n&lt;&#x2F;appender&gt;</code></pre>\n\n<p>查看日志最简单直接的方法，就是在对应的目录下，去寻找相应的日志，在Linux系统中，可以通过这些命令去查看日志文件：</p>\n<ol>\n<li><p><code>cat</code>：可以使用<code>cat</code>命令来查看日志文件的内容。</p>\n<p>例如，使用<code>cat /var/log/syslog</code>命令可以查看系统日志文件的内容。</p>\n</li>\n<li><p><code>tail</code>：<code>tail</code>命令可以用来显示文件的末尾内容，常用于实时查看日志文件的更新。</p>\n<p>使用<code>tail -f /var/log/syslog</code>命令可以实时查看系统日志文件的更新内容。</p>\n</li>\n<li><p><code>less</code>：<code>less</code>命令可以用来浏览文件的内容，并且支持向上和向下滚动。</p>\n<p>例如，使用<code>less /var/log/syslog</code>命令可以打开系统日志文件，并通过上下箭头键来滚动浏览文件内容。</p>\n</li>\n<li><p><code>grep</code>：<code>grep</code>命令可以用来在文件中搜索指定的关键字或模式。</p>\n<p>例如，使用<code>grep &quot;error&quot; /var/log/syslog</code>命令可以查找系统日志文件中包含”error”关键字的行。</p>\n</li>\n</ol>\n<p>除了命令行工具，还可以使用一些图形化的日志查看工具来浏览和分析日志文件，例如logrotate、journalctl等。</p>\n<p>现在的服务，一般都是容器化部署，可以通过容器的日志命令来查看日志：</p>\n<ol>\n<li>Docker：如果用的是Docker管理容器，可以使用<code>docker logs</code>命令来查看容器的日志。例如，使用<code>docker logs </code>命令可以查看指定容器的日志内容。</li>\n<li>Kubernetes：如果用的是Kubernetes管理容器，可以使用<code>kubectl logs</code>命令来查看容器的日志。例如，使用<code>kubectl logs </code>命令可以查看指定Pod中容器的日志内容。</li>\n</ol>\n<h3 id=\"ELK\"><a href=\"#ELK\" class=\"headerlink\" title=\"ELK\"></a>ELK</h3><p>直接通过日志文件查询日志可能会比较繁琐，效率比较低，可以使用一些日志聚合工具来收集和管理日志。例如使用使用ELK Stack（Elasticsearch, Logstash, Kibana）来集中管理和可视化日志。</p>\n<ul>\n<li>Elasticsearch：用于存储和索引日志数据，提供高效的搜索和分析功能。</li>\n<li>Logstash：用于收集、过滤和转发日志数据，可以从多个来源（如文件、网络等）收集日志，并将其发送到Elasticsearch进行存储和索引。</li>\n<li>Kibana：用于可视化和分析日志数据，提供灵活的查询和可视化工具，可以创建仪表板、图表和报表来展示日志数据的统计和趋势。</li>\n</ul>\n<h3 id=\"SLS\"><a href=\"#SLS\" class=\"headerlink\" title=\"SLS\"></a>SLS</h3><p>SLS（阿里云日志服务）是由阿里云提供的商业化日志收集解决方案，它提供了一站式的日志数据采集、消费和查询分析功能，无需开发即可使用。</p>\n<p>通过SLS，可以方便地收集、存储和查询日志数据，进行实时监控、故障排查和业务分析。同时，SLS还提供了丰富的查询和分析功能，如日志关键词搜索、日志分析报表等，整体功能还是非常强大的——毕竟要氪金。</p>\n<p>更多关于SLS阿里云日志服务的详细信息，大家可以搜索相关文档或访问阿里云官方网站进行了解，这里就不展开更多了。</p>\n<h1 id=\"打印日志最佳实践\"><a href=\"#打印日志最佳实践\" class=\"headerlink\" title=\"打印日志最佳实践\"></a>打印日志最佳实践</h1><p>打日志这件事情，说起来很简单，有手就行，但是想要打良好的日志，就没那么那么简单。</p>\n<p>那么，怎样才算是一份良好的日志呢？应该具备这些特点：</p>\n<ol>\n<li><strong>详细和准确</strong>：日志应该记录足够详细的信息，包括时间、触发事件、相关参数和上下文等，方便我们快速理解时间的发生和上下文。</li>\n<li><strong>可读性强</strong>：日志应该使用易于阅读和理解的格式，日志信息能够被其它开发人员快速理解，而不需要费力解析复杂的日志内容。</li>\n<li><strong>可配置性</strong>：日志系统应该具备可配置的选项，以便开发人员可以根据需要调整日志级别、输出目标和格式等。</li>\n<li><strong>性能高效</strong>：日志记录应该对系统性能的影响尽可能小，避免对应用程序的正常运行造成明显的延迟。</li>\n<li><strong>安全性</strong>：日志应该保护敏感信息的安全性，避免将敏感数据记录在日志中，以防止信息泄露的风险。</li>\n</ol>\n<p>那么接下来，围绕这些要点，我们来看看打印日志的最佳实践。</p>\n<h2 id=\"1-选择合适的日志级别\"><a href=\"#1-选择合适的日志级别\" class=\"headerlink\" title=\"1.选择合适的日志级别\"></a>1.选择合适的日志级别</h2><p>在选择日志级别时，需要根据不同的场景和需求来确定合适的级别。</p>\n<p>以下是常见的日志级别及其适用场景：</p>\n<ul>\n<li><strong>Error（错误）</strong>：表示比较严重的问题，可能会导致业务运行异常或失败。这些错误可能需要立即处理，来保证业务的正常运行。例如，数据库连接失败、关键功能异常等。</li>\n<li><strong>Warn（警告）</strong>：表示一些不太严重的问题，对业务的影响不大，但需要开发人员注意。这些警告可能是一些潜在的问题或异常情况，需要及时关注和处理。例如，接口请求超时、配置项缺失等。</li>\n<li><strong>Info（信息）</strong>：用于记录日常排查问题的关键信息，如接口的入参和出参、关键业务操作的结果等。这些信息对于了解系统运行状态和分析问题非常有帮助，但不会对业务流程造成直接影响。</li>\n<li><strong>Trace（详细信息）</strong>：提供更详细的日志信息，通常用于调试和排查问题。这些日志包含了更详细的上下文信息，可以用来追踪代码执行路径和查看具体的变量值。由于详细程度较高，一般在开发和测试环境中使用，不适合线上环境。</li>\n<li><strong>Debug（调试）</strong>：仅用于开发或测试阶段，用于查看重要的内部逻辑细节。这些日志级别通常和线上业务关系不密切，主要用于开发人员进行代码调试和问题排查。</li>\n</ul>\n<p>在实际应用中，可以根据具体需求和系统特点，选择合适的日志级别来平衡日志的详细程度和性能开销。通常建议在生产环境中使用较高级别的日志级别（如Error、Warn、Info），而在开发和测试环境中可以使用更详细的级别（如Trace、Debug）来辅助调试和排查问题。</p>\n<h2 id=\"2-选择适当的日志格式\"><a href=\"#2-选择适当的日志格式\" class=\"headerlink\" title=\"2.选择适当的日志格式\"></a>2.选择适当的日志格式</h2><p>在实际的开发中，可能会打印不同种类的日志，常见的日志种类包括：<strong>摘要日志、详细日志、业务执行日志</strong></p>\n<p>日志打印的时候，日志格式要尽量兼顾完备性、可读性和性能。</p>\n<h4 id=\"摘要日志\"><a href=\"#摘要日志\" class=\"headerlink\" title=\"摘要日志\"></a>摘要日志</h4><p>摘要日志是一种标准化的日志文件，主要用于监控系统配置和进行离线日志分析。它通常包含以下关键信息：</p>\n<ul>\n<li>调用时间：记录了日志产生的具体时间。</li>\n<li>日志链路 id：包括traceId和rpcId，用于追踪请求的完整路径。</li>\n<li>线程名：记录了产生日志的线程名称。</li>\n<li>接口名：记录了被调用的接口名称。</li>\n<li>方法名：记录了被调用的方法名称。</li>\n<li>调用耗时：记录了方法调用的耗时。</li>\n<li>调用是否成功：记录了方法调用是否成功，通常用Y&#x2F;N表示。</li>\n<li>错误码：如果方法调用失败，会记录相应的错误码。</li>\n<li>系统上下文信息：包括调用系统名、调用系统ip、调用时间戳、是否压测等。</li>\n</ul>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">2022-12-12 06:05:05,129 [0b26053315407142451016402xxxxx 0.3 - &#x2F;&#x2F;&#x2F; - ] INFO [SofaBizProcessor-4-thread-333] - [(interfaceName,methodName,1ms,Y,SUCCESS)(appName,ip地址,时间戳,Y)</code></pre>\n\n<p>在Java中，通常可以通过配置日志框架来定义一些通用信息的打印，比如调用时间、日志链路id、方法名等。具体的配置方式取决于所选择的日志框架。</p>\n<p>例如使用Logback作为日志框架：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">&lt;configuration&gt;\n  &lt;appender name&#x3D;&quot;CONSOLE&quot; class&#x3D;&quot;ch.qos.logback.core.ConsoleAppender&quot;&gt;\n    &lt;encoder&gt;\n      &lt;pattern&gt;%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125; [%X&#123;traceId&#125;] [%thread] [%logger&#123;0&#125;] - %msg%n&lt;&#x2F;pattern&gt;\n    &lt;&#x2F;encoder&gt;\n  &lt;&#x2F;appender&gt;\n  \n  &lt;root level&#x3D;&quot;INFO&quot;&gt;\n    &lt;appender-ref ref&#x3D;&quot;CONSOLE&quot; &#x2F;&gt;\n  &lt;&#x2F;root&gt;\n&lt;&#x2F;configuration&gt;</code></pre>\n\n<h4 id=\"详细日志\"><a href=\"#详细日志\" class=\"headerlink\" title=\"详细日志\"></a>详细日志</h4><p>详细日志是一种补充摘要日志中的业务参数的日志文件，主要用于问题排查。除了包含摘要日志的所有信息，详细日志还会记录请求的入参和出参。</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">2022-12-12 06:05:05,129 [0b26053315407142451016402xxxxx 0.3 - &#x2F;&#x2F;&#x2F; - ] INFO [SofaBizProcessor-4-thread-333] - [(interfaceName,methodName,1ms,Y,SUCCESS)(appName,ip地址,时间戳,Y)(参数1,参数2)(xxxx)</code></pre>\n\n<h4 id=\"业务执行日志\"><a href=\"#业务执行日志\" class=\"headerlink\" title=\"业务执行日志\"></a>业务执行日志</h4><p>业务执行日志主要记录系统执行过程，用于跟踪代码执行逻辑。在打印业务执行日志时，需要考虑以下几个因素：</p>\n<ul>\n<li>必要性：考虑是否真的需要打印这个日志，如果不打印是否会影响后续问题排查，如果打印这个日志后续输出频率是否会太高，造成线上日志打印过多。</li>\n<li>辨识度：考虑日志格式是否具有辨识度，如果后续对该条日志进行监控或清洗，是否存在无法与其他日志区分或者每次打印的日志格式都不一致的问题。</li>\n<li>关键步骤和参数：日志中需包含明确的打印意义，当前执行步骤的关键参数。</li>\n</ul>\n<p>建议的格式是：[日志场景][日志含义]带业务参数的具体信息。这种格式可以清晰地表述出打印该条日志的作用，方便后续维护人员阅读。</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">[scene_bind_feature][feature_exists]feature xxx exists[tagSource&#x3D;&#39;MIF_TAG&#39;,tagValue&#x3D;&#39;123&#39;]</code></pre>\n\n<h2 id=\"3-建议入参出参打印日志\"><a href=\"#3-建议入参出参打印日志\" class=\"headerlink\" title=\"3.建议入参出参打印日志\"></a>3.建议入参出参打印日志</h2><p>建议在与接口相关的日志以及关键方法的入参和返回值中添加日志，以便更好地追踪和调试代码。</p>\n<p><strong>正例：</strong></p>\n<pre class=\"line-numbers language-Java\" data-language=\"Java\"><code class=\"language-Java\">public String myMethod(String param1, int param2) &#123;\n    logger.info(&quot;Entering myMethod. Param1: &#123;&#125;, Param2: &#123;&#125;&quot;, param1, param2);\n\n    &#x2F;&#x2F; 方法逻辑\n    String result &#x3D; &quot;some result&quot;;\n    logger.info(&quot;Exiting myMethod. Result: &#123;&#125;&quot;, result);\n    return result;\n&#125;</code></pre>\n\n<h2 id=\"4-使用占位符-而不是拼接\"><a href=\"#4-使用占位符-而不是拼接\" class=\"headerlink\" title=\"4.使用占位符{}而不是拼接+\"></a>4.使用占位符{}而不是拼接+</h2><p>使用占位符{}而不是+号进行字符串拼接，更加优雅和高效。使用占位符{}的方式可以提高代码的可读性，并且避免了使用+号进行字符串拼接时可能出现的性能损耗。</p>\n<p><strong>反例：</strong></p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">logger.info(&quot;Processing trade with id: &quot; + id + &quot; and symbol: &quot; + symbol);</code></pre>\n\n<p><strong>正例：</strong></p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">logger.info(&quot;Processing trade with id: &#123;&#125; and symbol : &#123;&#125; &quot;, id, symbol);</code></pre>\n\n<h2 id=\"5-建议日志要打英文\"><a href=\"#5-建议日志要打英文\" class=\"headerlink\" title=\"5.建议日志要打英文\"></a>5.建议日志要打英文</h2><p>建议在打印日志时使用英文，因为使用中文，可能会有两个问题：</p>\n<ul>\n<li>中文日志可能会导致编码问题，在日志文件里出现乱码。</li>\n<li>大多数日志分析工具都是基于英文字符进行匹配和检索的，使用中文可能影响日志的查询和分析。</li>\n</ul>\n<p><strong>反例：</strong></p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">logger.info(&quot;用户登录成功，用户名：&#123;&#125;&quot;,&quot;张三&quot;);</code></pre>\n\n<p><strong>正例：</strong></p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">logger.info(&quot;User login successful. Username:&#123;&#125; &quot;,&quot;Zhang San&quot;);</code></pre>\n\n<h2 id=\"6-日志要打印关键参数\"><a href=\"#6-日志要打印关键参数\" class=\"headerlink\" title=\"6.日志要打印关键参数\"></a>6.日志要打印关键参数</h2><p>日志最重要的作用是用于排查问题和追踪代码执行过程，因此建议在日志中打印关键的公共参数或业务参数，如Trace ID、Order ID等。</p>\n<p><strong>正例：</strong></p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">logger.info(&quot;Placing order, Order ID: &#123;&#125;, Customer ID: &#123;&#125;, Amount: &#123;&#125;&quot;,  orderId, customerId, amount);\n&#x2F;&#x2F; 下单逻辑\nString result &#x3D; &quot;Order placed successfully&quot;;\nlogger.info(&quot;Order placed. Order ID: &#123;&#125;, Result: &#123;&#125;&quot;,  orderId, result);</code></pre>\n\n<h2 id=\"7-建议多分支首行打印日志\"><a href=\"#7-建议多分支首行打印日志\" class=\"headerlink\" title=\"7.建议多分支首行打印日志\"></a>7.建议多分支首行打印日志</h2><p>在条件分支比较复杂的情况下，建议在进入分支的首行打印相关信息，方便在调试，或者出现问题的时候，知道我们的代码进入的是哪一个分支。</p>\n<p><strong>正例：</strong></p>\n<pre class=\"line-numbers language-Java\" data-language=\"Java\"><code class=\"language-Java\">public void process(String type) &#123;\n    if (&quot;xxx&quot;.equals(type)) &#123;\n        logger.debug(&quot;Current branch type: xxx&quot;);\n        &#x2F;&#x2F; Branch xxx logic\n    &#125; else if (&quot;aaa&quot;.equals(type)) &#123;\n        logger.debug(&quot;Current branch type: aaa&quot;);\n        &#x2F;&#x2F; Branch aaa logic\n    &#125; else &#123;\n        logger.debug(&quot;Current branch type: other&quot;);\n        &#x2F;&#x2F; Default branch logic\n    &#125;\n&#125;</code></pre>\n\n<h2 id=\"8-不要直接使用日志系统-Log4j、Logback-中的-API\"><a href=\"#8-不要直接使用日志系统-Log4j、Logback-中的-API\" class=\"headerlink\" title=\"8.不要直接使用日志系统(Log4j、Logback)中的 API\"></a>8.不要直接使用日志系统(Log4j、Logback)中的 API</h2><p>在应用中，应该依赖日志框架（如SLF4J、JCL）的API，而不是直接使用具体的日志系统（如Log4j、Logback）的API。</p>\n<p>直接使用Log4j或Logback等日志系统的API会导致系统代码与具体的日志实现强耦合，当需要切换日志实现时，会带来较大的改造成本。而使用日志框架的API，如SLF4J或JCL，它们是使用门面模式的日志框架，可以实现解耦具体的日志实现，有利于后续的维护，并确保各个类的日志处理方式保持统一。</p>\n<p><strong>正例：</strong></p>\n<pre class=\"line-numbers language-Java\" data-language=\"Java\"><code class=\"language-Java\">&#x2F;&#x2F; 使用SLF4J:\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nprivate static final Logger logger &#x3D; LoggerFactory.getLogger(MyClass.class);\n\n&#x2F;&#x2F; 使用JCL:\nimport org.apache.commons.logging.Log;\nimport org.apache.commons.logging.LogFactory;\n\nprivate static final Log log &#x3D; LogFactory.getLog(MyClass.class);</code></pre>\n\n<h2 id=\"9-日志工具对象-Logger-应声明为-private-static-final\"><a href=\"#9-日志工具对象-Logger-应声明为-private-static-final\" class=\"headerlink\" title=\"9.日志工具对象 Logger 应声明为 private static final\"></a>9.日志工具对象 Logger 应声明为 private static final</h2><p>在声明日志工具对象Logger时，应该将其修饰符设置为private static final。</p>\n<ul>\n<li>声明为private可以防止Logger对象被其他类非法使用，保证日志的访问权限。</li>\n<li>声明为static可以避免重复创建Logger对象，节省资源开销。</li>\n<li>声明为final可以确保Logger对象在类的生命周期内不会被修改，保持一致性。</li>\n</ul>\n<p><strong>正例：</strong></p>\n<pre class=\"line-numbers language-Java\" data-language=\"Java\"><code class=\"language-Java\">private static final Logger LOGGER &#x3D; LoggerFactory.getLogger(MyClass.class);</code></pre>\n\n<h2 id=\"10-建议不要直接用-JSON-工具将对象转换成-String\"><a href=\"#10-建议不要直接用-JSON-工具将对象转换成-String\" class=\"headerlink\" title=\"10.建议不要直接用 JSON 工具将对象转换成 String\"></a>10.建议不要直接用 JSON 工具将对象转换成 String</h2><p><strong>反例：</strong></p>\n<pre class=\"line-numbers language-Java\" data-language=\"Java\"><code class=\"language-Java\">public void doSomeThing() &#123;\n    log.info(&quot;doSomeThing and print log, data&#x3D;&#123;&#125;&quot;, JSON.toJSONString(data));\n    &#x2F;&#x2F; 业务逻辑\n    ...\n&#125;</code></pre>\n\n<p>在日志打印过程中，建议不要直接使用JSON工具将对象转换成String。</p>\n<ul>\n<li>使用JSON工具（如fastjson）将对象转换成String时，会调用对象的get方法进行序列化。如果对象中的某些get方法被覆写，并且可能会抛出异常，那么在打印日志时可能会影响正常的业务流程执行。</li>\n<li>对象的序列化过程本身是一个计算密集型的过程，会消耗CPU资源。此外，序列化过程还会产生许多中间对象，对内存也不友好。</li>\n</ul>\n<p><strong>正例：</strong></p>\n<p>可以使用 apache 的 ToStringBulider 工具，或者自定义toString方法。</p>\n<pre class=\"line-numbers language-Java\" data-language=\"Java\"><code class=\"language-Java\">public void doSomeThing() &#123;\n    log.info(&quot;doSomeThing and print log, data&#x3D;&#123;&#125;&quot;, ToStringBuilder.reflectionToString(data, ToStringStyle.SHORT_PREFIX_STYLE));\n&#125;</code></pre>\n\n<h2 id=\"11-日志打印不能出现异常\"><a href=\"#11-日志打印不能出现异常\" class=\"headerlink\" title=\"11.日志打印不能出现异常\"></a>11.日志打印不能出现异常</h2><p>在日志打印过程中，应该避免出现异常，以免影响正常的业务流程。</p>\n<p><strong>反例：</strong></p>\n<p>这个反例里直接调用了<code>data.toString()</code>方法来打印日志。如果<code>data</code>对象为<code>null</code>，那么在调用<code>toString()</code>方法时会抛出空指针异常，影响正常的业务流程。</p>\n<pre class=\"line-numbers language-Java\" data-language=\"Java\"><code class=\"language-Java\">public void doSomeThing() &#123;\n    log.info(&quot;doSomeThing and print log, data&#x3D;&#123;&#125;&quot;, data.toString());\n    &#x2F;&#x2F; 业务逻辑\n    ...\n&#125;</code></pre>\n\n<p><strong>正例：</strong></p>\n<p>在打印之前需要判空，或者使用Apache的ToStringBuilder工具，或者自定义<code>toString()</code>方法。</p>\n<pre class=\"line-numbers language-Java\" data-language=\"Java\"><code class=\"language-Java\">public void doSomeThing() &#123;\n    log.info(&quot;doSomeThing and print log, data&#x3D;&#123;&#125;&quot;, ToStringBuilder.reflectionToString(data, ToStringStyle.SHORT_PREFIX_STYLE));\n    &#x2F;&#x2F; 业务逻辑\n    ...\n&#125;\npublic class Data &#123;\n    private String field1;\n    private int field2;\n    \n    &#x2F;&#x2F; 省略构造方法和其他方法\n    \n    @Override\n    public String toString() &#123;\n        return &quot;Data&#123;&quot; +\n                &quot;field1&#x3D;&#39;&quot; + field1 + &#39;\\&#39;&#39; +\n                &quot;, field2&#x3D;&quot; + field2 +\n                &#39;&#125;&#39;;\n    &#125;\n&#125;\n\npublic void doSomeThing() &#123;\n    log.info(&quot;doSomeThing and print log, data&#x3D;&#123;&#125;&quot;, data);\n    &#x2F;&#x2F; 业务逻辑\n    ...\n&#125;</code></pre>\n\n<h2 id=\"12-敏感信息需要脱敏\"><a href=\"#12-敏感信息需要脱敏\" class=\"headerlink\" title=\"12.敏感信息需要脱敏\"></a>12.敏感信息需要脱敏</h2><p>为了保护用户的隐私和防止敏感信息泄露，对于一些敏感的数据，如身份证号、银行卡号等，应该进行脱敏处理，而不是明文打印。</p>\n<p><strong>反例：</strong></p>\n<p>反例里直接将身份证号<code>idCard</code>明文打印到日志中，这样会导致敏感信息暴露的风险。</p>\n<pre class=\"line-numbers language-Java\" data-language=\"Java\"><code class=\"language-Java\">public void doSomeThing() &#123;\n    log.info(&quot;doSomeThing and print log, idCard&#x3D;&#123;&#125;&quot;, idCard);\n    &#x2F;&#x2F; 业务逻辑\n    ...\n&#125;</code></pre>\n\n<p><strong>正例：</strong></p>\n<p>可以使用脱敏方法对敏感信息进行处理，来防止敏感信息泄露。</p>\n<pre class=\"line-numbers language-Java\" data-language=\"Java\"><code class=\"language-Java\">public void doSomeThing() &#123;\n    String maskedIdCard &#x3D; maskIdCard(idCard);\n    log.info(&quot;do something and print log, idCard&#x3D;&#123;&#125;&quot;, maskedIdCard);\n    &#x2F;&#x2F; 业务逻辑\n    ...\n&#125;\n\nprivate String maskIdCard(String idCard) &#123;\n    &#x2F;&#x2F; 实现脱敏算法，将身份证号进行脱敏处理\n    &#x2F;&#x2F; 例如：将前四位和后四位保留，中间的数字用*代替\n    if (idCard.length() &gt;&#x3D; 8) &#123;\n        String prefix &#x3D; idCard.substring(0, 4);\n        String suffix &#x3D; idCard.substring(idCard.length() - 4);\n        String maskedIdCard &#x3D; prefix + &quot;****&quot; + suffix;\n        return maskedIdCard;\n    &#125;\n    return idCard;\n&#125;</code></pre>\n\n<h2 id=\"13-建议使用异步的方式来输出日志\"><a href=\"#13-建议使用异步的方式来输出日志\" class=\"headerlink\" title=\"13.建议使用异步的方式来输出日志\"></a>13.建议使用异步的方式来输出日志</h2><p>为了提升日志的输出性能，特别是在涉及到IO操作的情况下，建议使用异步方式来输出日志。这样可以减少IO操作的阻塞时间，提升系统的整体性能。</p>\n<p>以logback为例，可以使用<code>AsyncAppender</code>来配置异步输出日志。</p>\n<pre class=\"line-numbers language-markup\" data-language=\"markup\"><code class=\"language-markup\">&lt;appender name&#x3D;&quot;FILE_ASYNC&quot; class&#x3D;&quot;ch.qos.logback.classic.AsyncAppender&quot;&gt;\n    &lt;appender-ref ref&#x3D;&quot;ASYNC&quot;&#x2F;&gt;\n&lt;&#x2F;appender&gt;</code></pre>\n\n<h2 id=\"14-不要使用e-printStackTrace\"><a href=\"#14-不要使用e-printStackTrace\" class=\"headerlink\" title=\"14.不要使用e.printStackTrace()\"></a>14.不要使用e.printStackTrace()</h2><p>使用<code>e.printStackTrace()</code>存在两个问题：</p>\n<ul>\n<li><code>e.printStackTrace()</code>打印出的堆栈日志跟业务代码日志是交错混合在一起的，通常排查异常日志不太方便。</li>\n<li><code>e.printStackTrace()</code>语句产生的字符串记录的是堆栈信息，如果信息太长太多，字符串常量池所在的内存块没有空间了，即内存满了，那么用户的请求就可能被阻塞。</li>\n</ul>\n<p><strong>正例：</strong></p>\n<p>应该使用日志记录框架，如logback或log4j，来打印异常信息。</p>\n<pre class=\"line-numbers language-Java\" data-language=\"Java\"><code class=\"language-Java\">try &#123;\n    &#x2F;&#x2F; 业务代码处理\n&#125; catch (Exception e) &#123;\n    log.error(&quot;An error occurred:&quot;, e);\n&#125;</code></pre>\n\n<h2 id=\"15-异常日志打印完整堆栈\"><a href=\"#15-异常日志打印完整堆栈\" class=\"headerlink\" title=\"15.异常日志打印完整堆栈\"></a>15.异常日志打印完整堆栈</h2><p><strong>反例：</strong></p>\n<p>异常日志没有打印完整的堆栈信息，无法提供足够的信息来排查问题。</p>\n<pre class=\"line-numbers language-Java\" data-language=\"Java\"><code class=\"language-Java\">try &#123;\n    &#x2F;&#x2F; 业务代码处理\n&#125; catch (Exception e) &#123;\n    &#x2F;&#x2F; 错误\n    LOG.error(&quot;An error occurred:&quot;);\n&#125;</code></pre>\n\n<p><strong>正例：</strong></p>\n<p>为了打印完整的堆栈信息，我们可以使用日志记录框架提供的方法，将异常对象作为参数传递给日志记录方法。</p>\n<pre class=\"line-numbers language-Java\" data-language=\"Java\"><code class=\"language-Java\">try &#123;\n    &#x2F;&#x2F; 业务代码处理\n&#125; catch (Exception e) &#123;\n    log.error(&quot;An error occurred:&quot;, e);\n&#125;</code></pre>\n\n<p>另外，需要注意的是，使用<code>e.getMessage()</code>方法只能获取到异常的基本描述信息，而无法获取到完整的堆栈信息。如果需要打印完整的堆栈信息，应该使用日志记录框架提供的方法。</p>\n<h2 id=\"16-不要嵌套异常\"><a href=\"#16-不要嵌套异常\" class=\"headerlink\" title=\"16.不要嵌套异常\"></a>16.不要嵌套异常</h2><p>嵌套异常会导致异常的捕获和处理变得混乱，增加问题排查的难度。在编写方法或类之前，需要提前考虑异常的处理方式，并及时回顾代码以确保异常的正确处理。</p>\n<p><strong>反例：</strong></p>\n<p>异常被嵌套捕获，导致外层的异常无法获取到真正的异常信息。</p>\n<pre class=\"line-numbers language-Java\" data-language=\"Java\"><code class=\"language-Java\">try &#123;\n    &#x2F;&#x2F; 业务代码处理\n    try &#123;\n        &#x2F;&#x2F; 业务代码处理\n    &#125; catch (Exception e) &#123;\n        log.error(&quot;Your program has an exception&quot;, e);\n    &#125;\n&#125; catch (Exception e) &#123;\n    log.error(&quot;Your program has an exception&quot;, e);\n&#125;</code></pre>\n\n<p><strong>正例：</strong></p>\n<p>为了避免嵌套异常，我们应该在合适的地方捕获和处理异常，并将异常信息记录下来。</p>\n<pre class=\"line-numbers language-Java\" data-language=\"Java\"><code class=\"language-Java\">try &#123;\n    &#x2F;&#x2F; 业务代码处理\n&#125; catch (Exception e) &#123;\n    log.error(&quot;Your program has an exception&quot;, e);\n&#125;</code></pre>\n\n<h2 id=\"17-不要记录异常又抛出\"><a href=\"#17-不要记录异常又抛出\" class=\"headerlink\" title=\"17.不要记录异常又抛出\"></a>17.不要记录异常又抛出</h2><p>记录异常后又抛出异常是一种危险的做法。外层可能不会再次处理内层抛出的异常，导致问题无法得到正确的处理。此外，这样做还会导致堆栈信息被重复打印，浪费系统性能。</p>\n<p><strong>反例:</strong></p>\n<p>下面的反例中，异常被记录后又抛出了自定义异常。这样做的问题在于，外层可能不会再次处理内层抛出的异常，导致问题得不到正确的处理。</p>\n<pre class=\"line-numbers language-Java\" data-language=\"Java\"><code class=\"language-Java\">try &#123;\n    &#x2F;&#x2F; 业务代码处理\n&#125; catch (Exception e) &#123;\n    log.error(&quot;IO exception&quot;, e);\n    throw new MyException(e);\n&#125;</code></pre>\n\n<h2 id=\"18-建议对日志配置告警\"><a href=\"#18-建议对日志配置告警\" class=\"headerlink\" title=\"18.建议对日志配置告警\"></a>18.建议对日志配置告警</h2><p>如果接入了日志分析工具，建议对日志进行告警配置。当错误日志数量超过设定的阈值时，可以及时发送告警通知，方便及时感知和排查问题。这样可以帮助我们快速发现和解决潜在的系统问题。</p>\n<h2 id=\"19-避免重复打印日志\"><a href=\"#19-避免重复打印日志\" class=\"headerlink\" title=\"19.避免重复打印日志\"></a>19.避免重复打印日志</h2><p>为了提高日志的可读性和简洁性，应尽量避免重复打印日志。如果多个日志可以合并为一行来表示，可以将它们合并在一起，以减少冗余的日志输出。</p>\n<p><strong>反例：</strong></p>\n<pre class=\"line-numbers language-Java\" data-language=\"Java\"><code class=\"language-Java\">log.info(&quot;User is vip, Id: &#123;&#125;&quot;, user);\n&#x2F;&#x2F; 冗余，可以跟前面的日志合并一起\nlog.info(&quot;Start solve vip, Id: &#123;&#125;&quot;, user);</code></pre>\n\n<h2 id=\"20-不要打印无意义的日志\"><a href=\"#20-不要打印无意义的日志\" class=\"headerlink\" title=\"20.不要打印无意义的日志\"></a>20.不要打印无意义的日志</h2><p>为了提高日志的可读性和实用性，应避免打印无意义的日志信息。无意义的日志指的是缺乏业务上下文或无关联日志链路ID的日志。</p>\n<p><strong>反例：</strong></p>\n<pre class=\"line-numbers language-Java\" data-language=\"Java\"><code class=\"language-Java\">public void doSomeThing() &#123;\n    log.info(&quot;doSomeThing and print log&quot;); &#x2F;&#x2F; 无业务信息的日志\n    &#x2F;&#x2F; 业务逻辑\n    ...\n&#125;\n\npublic void doSomeThing() &#123;\n    doIt1();\n    log.info(&quot;doSomeThing 111&quot;); &#x2F;&#x2F; 无关联日志链路ID的日志\n    doIt2();\n    log.info(&quot;doSomeThing 222&quot;); &#x2F;&#x2F; 无关联日志链路ID的日志\n&#125;</code></pre>\n\n<p><strong>正例：</strong></p>\n<p>下面是一个正例，展示了有意义的日志打印情况：</p>\n<pre class=\"line-numbers language-Java\" data-language=\"Java\"><code class=\"language-Java\">public void doSomeThing() &#123;\n    log.info(&quot;doSomeThing and print log, id&#x3D;&#123;&#125;&quot;, id); &#x2F;&#x2F; 带有相关的业务信息的日志\n    &#x2F;&#x2F; 业务逻辑\n    ...\n&#125;</code></pre>\n\n<p>在打印日志时，需要注意：</p>\n<ol>\n<li>确保日志信息具有实际的业务意义，能够帮助理解和定位问题。</li>\n<li>如果存在大量无意义的日志信息，可以考虑删除或以debug级别打印，以避免日志过于冗杂。</li>\n</ol>\n<h2 id=\"21-不要在循环中打印-INFO-级别日志\"><a href=\"#21-不要在循环中打印-INFO-级别日志\" class=\"headerlink\" title=\"21.不要在循环中打印 INFO 级别日志\"></a>21.不要在循环中打印 INFO 级别日志</h2><p>在循环中打印 INFO 级别的日志可能会导致日志输出过于冗杂，影响系统性能。因此，应避免在循环中打印大量的 INFO 级别日志。</p>\n<p><strong>反例：</strong></p>\n<p>下面是一个反例，展示了在循环中打印 INFO 级别日志的情况：</p>\n<pre class=\"line-numbers language-Java\" data-language=\"Java\"><code class=\"language-Java\">public void doSomeThing() &#123;\n    for(String s : strList) &#123;\n        log.info(&quot;doSomeThing and print log: &#123;&#125;&quot;, s);\n        &#x2F;&#x2F; 业务逻辑\n        ...\n    &#125;\n&#125;</code></pre>\n\n<h2 id=\"22-对于-trace-x2F-debug-级别的日志输出，必须要有开关\"><a href=\"#22-对于-trace-x2F-debug-级别的日志输出，必须要有开关\" class=\"headerlink\" title=\"22.对于 trace&#x2F;debug 级别的日志输出，必须要有开关\"></a>22.对于 trace&#x2F;debug 级别的日志输出，必须要有开关</h2><p>为了避免在配置了较高日志级别时产生不必要的日志输出，应在输出 trace&#x2F;debug级别的日志之前进行相应级别的日志开关判断。</p>\n<p><strong>反例：</strong></p>\n<p>下面是一个反例，展示了没有进行日志级别开关判断的情况：</p>\n<pre class=\"line-numbers language-Java\" data-language=\"Java\"><code class=\"language-Java\">public void doSomeThing() &#123;\n    String name &#x3D; &quot;xxx&quot;;\n    logger.trace(&quot;print debug log&quot; + name);\n    logger.debug(&quot;print debug log&quot; + name);\n    &#x2F;&#x2F; 业务逻辑\n    ...\n&#125;</code></pre>\n\n<p><strong>正例：</strong></p>\n<p>为了避免不必要的日志输出，应在输出 trace&#x2F;debug&#x2F;info 级别的日志之前进行相应级别的日志开关判断。通常，可以将开关判断逻辑封装在日志工具类中，以实现统一的处理。</p>\n<pre class=\"line-numbers language-Java\" data-language=\"Java\"><code class=\"language-Java\">public void doSomeThing() &#123;\n    String name &#x3D; &quot;xxx&quot;;\n    \n    if (logger.isTraceEnabled()) &#123;\n        logger.trace(&quot;print trace log &#123;&#125;&quot;, name); \n    &#125;\n    \n    if (logger.isDebugEnabled()) &#123;\n        logger.debug(&quot;print debug log &#123;&#125;&quot;, name); \n    &#125;\n    \n    &#x2F;&#x2F; 业务逻辑\n    ...\n&#125;</code></pre>\n\n<hr>\n<p>好了，这就是本期的全部内容了，希望大家在工作中一定要好好打日志，宁愿多打，也不要少打，毕竟省的日志那一星半点，还不够一次事故的损失。</p>\n","text":"打印日志最佳实践...","link":"","photos":[],"count_time":{"symbolsCount":"16k","symbolsTime":"14 mins."},"categories":[{"name":"编程","slug":"编程","count":6,"path":"api/categories/编程.json"}],"tags":[{"name":"日志","slug":"日志","count":1,"path":"api/tags/日志.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E5%BC%84%E6%87%82%E6%97%A5%E5%BF%97\"><span class=\"toc-text\">弄懂日志</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%BB%80%E4%B9%88%E6%98%AF%E6%97%A5%E5%BF%97%EF%BC%9F\"><span class=\"toc-text\">什么是日志？</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E6%89%93%E6%97%A5%E5%BF%97%EF%BC%9F\"><span class=\"toc-text\">为什么要打日志？</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E6%89%93%E6%97%A5%E5%BF%97%EF%BC%9F\"><span class=\"toc-text\">什么时候打日志？</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%80%8E%E4%B9%88%E6%89%93%E6%97%A5%E5%BF%97%EF%BC%9F\"><span class=\"toc-text\">怎么打日志？</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%80%8E%E4%B9%88%E6%9F%A5%E6%97%A5%E5%BF%97%EF%BC%9F\"><span class=\"toc-text\">怎么查日志？</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%97%A5%E5%BF%97%E6%96%87%E4%BB%B6\"><span class=\"toc-text\">日志文件</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#ELK\"><span class=\"toc-text\">ELK</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#SLS\"><span class=\"toc-text\">SLS</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E6%89%93%E5%8D%B0%E6%97%A5%E5%BF%97%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5\"><span class=\"toc-text\">打印日志最佳实践</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#1-%E9%80%89%E6%8B%A9%E5%90%88%E9%80%82%E7%9A%84%E6%97%A5%E5%BF%97%E7%BA%A7%E5%88%AB\"><span class=\"toc-text\">1.选择合适的日志级别</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#2-%E9%80%89%E6%8B%A9%E9%80%82%E5%BD%93%E7%9A%84%E6%97%A5%E5%BF%97%E6%A0%BC%E5%BC%8F\"><span class=\"toc-text\">2.选择适当的日志格式</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E6%91%98%E8%A6%81%E6%97%A5%E5%BF%97\"><span class=\"toc-text\">摘要日志</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E8%AF%A6%E7%BB%86%E6%97%A5%E5%BF%97\"><span class=\"toc-text\">详细日志</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E4%B8%9A%E5%8A%A1%E6%89%A7%E8%A1%8C%E6%97%A5%E5%BF%97\"><span class=\"toc-text\">业务执行日志</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#3-%E5%BB%BA%E8%AE%AE%E5%85%A5%E5%8F%82%E5%87%BA%E5%8F%82%E6%89%93%E5%8D%B0%E6%97%A5%E5%BF%97\"><span class=\"toc-text\">3.建议入参出参打印日志</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#4-%E4%BD%BF%E7%94%A8%E5%8D%A0%E4%BD%8D%E7%AC%A6-%E8%80%8C%E4%B8%8D%E6%98%AF%E6%8B%BC%E6%8E%A5\"><span class=\"toc-text\">4.使用占位符{}而不是拼接+</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#5-%E5%BB%BA%E8%AE%AE%E6%97%A5%E5%BF%97%E8%A6%81%E6%89%93%E8%8B%B1%E6%96%87\"><span class=\"toc-text\">5.建议日志要打英文</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#6-%E6%97%A5%E5%BF%97%E8%A6%81%E6%89%93%E5%8D%B0%E5%85%B3%E9%94%AE%E5%8F%82%E6%95%B0\"><span class=\"toc-text\">6.日志要打印关键参数</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#7-%E5%BB%BA%E8%AE%AE%E5%A4%9A%E5%88%86%E6%94%AF%E9%A6%96%E8%A1%8C%E6%89%93%E5%8D%B0%E6%97%A5%E5%BF%97\"><span class=\"toc-text\">7.建议多分支首行打印日志</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#8-%E4%B8%8D%E8%A6%81%E7%9B%B4%E6%8E%A5%E4%BD%BF%E7%94%A8%E6%97%A5%E5%BF%97%E7%B3%BB%E7%BB%9F-Log4j%E3%80%81Logback-%E4%B8%AD%E7%9A%84-API\"><span class=\"toc-text\">8.不要直接使用日志系统(Log4j、Logback)中的 API</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#9-%E6%97%A5%E5%BF%97%E5%B7%A5%E5%85%B7%E5%AF%B9%E8%B1%A1-Logger-%E5%BA%94%E5%A3%B0%E6%98%8E%E4%B8%BA-private-static-final\"><span class=\"toc-text\">9.日志工具对象 Logger 应声明为 private static final</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#10-%E5%BB%BA%E8%AE%AE%E4%B8%8D%E8%A6%81%E7%9B%B4%E6%8E%A5%E7%94%A8-JSON-%E5%B7%A5%E5%85%B7%E5%B0%86%E5%AF%B9%E8%B1%A1%E8%BD%AC%E6%8D%A2%E6%88%90-String\"><span class=\"toc-text\">10.建议不要直接用 JSON 工具将对象转换成 String</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#11-%E6%97%A5%E5%BF%97%E6%89%93%E5%8D%B0%E4%B8%8D%E8%83%BD%E5%87%BA%E7%8E%B0%E5%BC%82%E5%B8%B8\"><span class=\"toc-text\">11.日志打印不能出现异常</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#12-%E6%95%8F%E6%84%9F%E4%BF%A1%E6%81%AF%E9%9C%80%E8%A6%81%E8%84%B1%E6%95%8F\"><span class=\"toc-text\">12.敏感信息需要脱敏</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#13-%E5%BB%BA%E8%AE%AE%E4%BD%BF%E7%94%A8%E5%BC%82%E6%AD%A5%E7%9A%84%E6%96%B9%E5%BC%8F%E6%9D%A5%E8%BE%93%E5%87%BA%E6%97%A5%E5%BF%97\"><span class=\"toc-text\">13.建议使用异步的方式来输出日志</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#14-%E4%B8%8D%E8%A6%81%E4%BD%BF%E7%94%A8e-printStackTrace\"><span class=\"toc-text\">14.不要使用e.printStackTrace()</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#15-%E5%BC%82%E5%B8%B8%E6%97%A5%E5%BF%97%E6%89%93%E5%8D%B0%E5%AE%8C%E6%95%B4%E5%A0%86%E6%A0%88\"><span class=\"toc-text\">15.异常日志打印完整堆栈</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#16-%E4%B8%8D%E8%A6%81%E5%B5%8C%E5%A5%97%E5%BC%82%E5%B8%B8\"><span class=\"toc-text\">16.不要嵌套异常</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#17-%E4%B8%8D%E8%A6%81%E8%AE%B0%E5%BD%95%E5%BC%82%E5%B8%B8%E5%8F%88%E6%8A%9B%E5%87%BA\"><span class=\"toc-text\">17.不要记录异常又抛出</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#18-%E5%BB%BA%E8%AE%AE%E5%AF%B9%E6%97%A5%E5%BF%97%E9%85%8D%E7%BD%AE%E5%91%8A%E8%AD%A6\"><span class=\"toc-text\">18.建议对日志配置告警</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#19-%E9%81%BF%E5%85%8D%E9%87%8D%E5%A4%8D%E6%89%93%E5%8D%B0%E6%97%A5%E5%BF%97\"><span class=\"toc-text\">19.避免重复打印日志</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#20-%E4%B8%8D%E8%A6%81%E6%89%93%E5%8D%B0%E6%97%A0%E6%84%8F%E4%B9%89%E7%9A%84%E6%97%A5%E5%BF%97\"><span class=\"toc-text\">20.不要打印无意义的日志</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#21-%E4%B8%8D%E8%A6%81%E5%9C%A8%E5%BE%AA%E7%8E%AF%E4%B8%AD%E6%89%93%E5%8D%B0-INFO-%E7%BA%A7%E5%88%AB%E6%97%A5%E5%BF%97\"><span class=\"toc-text\">21.不要在循环中打印 INFO 级别日志</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#22-%E5%AF%B9%E4%BA%8E-trace-x2F-debug-%E7%BA%A7%E5%88%AB%E7%9A%84%E6%97%A5%E5%BF%97%E8%BE%93%E5%87%BA%EF%BC%8C%E5%BF%85%E9%A1%BB%E8%A6%81%E6%9C%89%E5%BC%80%E5%85%B3\"><span class=\"toc-text\">22.对于 trace&#x2F;debug 级别的日志输出，必须要有开关</span></a></li></ol></li></ol>","author":{"name":"Dxc","slug":"blog-author","avatar":"/images/avatar.png","link":"/","description":"Free will is not free. <br /> @ <b>公众号：精准拔草</b>","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"永远相信美好的事情即将发生","uid":"20138ddfa2031d87ee9d776ece211245","slug":"永远相信美好的事情即将发生-雷军","date":"2023-08-13T14:09:53.000Z","updated":"2023-08-13T14:09:53.000Z","comments":true,"path":"api/articles/永远相信美好的事情即将发生-雷军.json","keywords":null,"cover":"/images/meihao.jpg","text":"永远相信美好的事情即将发生...","link":"","photos":[],"count_time":{"symbolsCount":"7k","symbolsTime":"6 mins."},"categories":[{"name":"成长","slug":"成长","count":2,"path":"api/categories/成长.json"}],"tags":[{"name":"雷军","slug":"雷军","count":1,"path":"api/tags/雷军.json"}],"author":{"name":"Dxc","slug":"blog-author","avatar":"/images/avatar.png","link":"/","description":"Free will is not free. <br /> @ <b>公众号：精准拔草</b>","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"feature":true},"next_post":{"title":"数据库表设计","uid":"f4ac3a4a311e597d05998bb126be956f","slug":"数据库表设计","date":"2023-09-15T14:09:53.000Z","updated":"2023-09-13T14:09:53.000Z","comments":true,"path":"api/articles/数据库表设计.json","keywords":null,"cover":"/images/database.jpg","text":"数据库表设计...","link":"","photos":[],"count_time":{"symbolsCount":"5.4k","symbolsTime":"5 mins."},"categories":[{"name":"编程","slug":"编程","count":6,"path":"api/categories/编程.json"}],"tags":[{"name":"数据库","slug":"数据库","count":1,"path":"api/tags/数据库.json"}],"author":{"name":"Dxc","slug":"blog-author","avatar":"/images/avatar.png","link":"/","description":"Free will is not free. <br /> @ <b>公众号：精准拔草</b>","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}}}