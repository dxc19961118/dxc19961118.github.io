{"title":"Java整理汇总","uid":"d321013777ddb01d6888d36204d6bd46","slug":"java整理2022","date":"2021-05-28T14:09:53.000Z","updated":"2021-05-28T14:09:53.000Z","comments":true,"path":"api/articles/java整理2022.json","keywords":null,"cover":"/images/log.jpg","content":"<h2 id=\"JAVASE\"><a href=\"#JAVASE\" class=\"headerlink\" title=\"JAVASE\"></a>JAVASE</h2><p>在命令窗口中输入“java HelloWorld”回车，先启动的是类加载器（类加载器 ClassLoader 主要的作用是将类名所对应的 class 文件装载到 JVM 当中，类加载器从硬盘上查找 HelloWorld.class 字节码文件（命令中指定的是 HelloWorld 类，则类加载器查找的就是HelloWorld.class 文件），<strong>默认情况下类加载器只从当前路径下查找</strong>，查找到之后则将 HelloWorld.class 文件加载到 JVM 并执行。</p>\n<p>当环境变量 classpath 设置为固定的 E:\\路径之后，类加载器只会从 E:\\路径下查找字节码文件，不再从当前路径下加载。</p>\n<p>JDK 常用的基本组件包括：javac（编译器）、java（运行 java 程序）、javadoc（提取 java 程序的注释信息并生成帮助文档）、jar（打 jar 包）、jdb（查错工具）、javap（反编译器）、 jconsole（系统调试和内存监控工具）等。</p>\n<p>标识符只能由数字、字母、下划线“_”、美元符号“$”组成。<strong>不能以数字开始。</strong></p>\n<p>① 见名知意：增强程序的可读性； </p>\n<p>② 驼峰命名：每个单词之间划清界限，增强程序可读性； </p>\n<p>③ 类名、接口名：首字母大写，后面每个单词首字母大写； </p>\n<p>④ 变量名、方法名：首字母小写，后面每个单词首字母大写； </p>\n<p>⑤ 常量名全部大写，使用“_”衔接。</p>\n<p>Java 中所有的关键字都是小写的英语单词。</p>\n<p>变量是内存当中存储数据最基本的单元。将数据（字面量）放到内存当中，给这块内存空间起一个名字。</p>\n<p>程序在运行的过程中会通过不同的数据类型给数据分配不同大小的空间。</p>\n<p>变量要求必须先声明，再赋值，才能访问。</p>\n<p>当一个整数型的字面量没有超出 byte,short,char 的取值范围，可以直接赋值。</p>\n<p>在 Java 中布尔类型的变量值不能使用 1 和 0，只能使用 true和 false。</p>\n<p>所有的扩展赋值运算符，最终都不会改变运算的结果类型。</p>\n<p>当一个表达式当中有多个“+”，并且在没有小括号的前提下，遵循自左向右的顺序依次执行。</p>\n<p>需要注意初始化变量的作用域，在 for 循环当中声明的变量只在for 循环中有效，当 for 循环结束之后，初始化变量的内存就释放了&#x2F;消失了，所以在 for 循环之外是无法访问该变量的。</p>\n<p>当多层循环嵌套的时候，可以给每个循环设置标识，例如：first:for…、second:for…，当某个条件成立时，想终止指定循环的话，可以这样做：break first;或者 break second;，这样指定的循环就结束了。 </p>\n<p><strong>continue 语句也有这种语法机制的。</strong></p>\n<p>switch的default 可以写在任何位置。</p>\n<p>带有 return 关键字的语句只要执行，所在的方法则执行结束。</p>\n<p>在同一个“域”中，“return”语句后面是<strong>不能</strong>写任何代码的，因为它无法执行到。</p>\n<p>break 用来终止循环，return 用来终止一个方法的执行。</p>\n<img src=\"C:\\Users\\hp\\AppData\\Roaming\\Typora\\typora-user-images\\image-20220106125306441.png\" alt=\"image-20220106125306441\" style=\"zoom:80%;\" />\n\n<p>方法重载（overload）是指在一个类中定义多个<strong>同名的方法</strong>，但要求每个方法具有不同的参数的<strong>类型</strong>或参数的<strong>个数</strong>。常用于创建完成一组任务相似但<strong>参数的类型或个数</strong>不同的方法。</p>\n<p>须满足以下三个条件：① 在同一个类当中。② 方法名相同。③ &#x3D;&#x3D;参数列表&#x3D;&#x3D;不同。与<strong>返回值</strong>无关。</p>\n<p>方法自身调用自身，这就是方法递归调用。出递归必须要有合法的结束条件，没有结束条件就一定会发生 StackOverflowError。</p>\n<p>一个递归程序有的时候存在合法有效的终止条件，但由于递归的太深，在还没有等到条件成立的时候，栈内存已经发生了溢出，这种情况也是存在的，所以实际开发中我们&#x3D;&#x3D;尽可能使用循环来代替递归&#x3D;&#x3D;算法，原则是：能不用递归尽量不用，能用循环代替的尽可能使用循环。当然，如果在开发中遇到了由于使用递归导致栈内存溢出错误的发生，首先，我们要检查递归的终止条件是否合法，如果是合法的还是发生栈内存溢出错误，那么我们可以尝试调整堆栈空间的大小。</p>\n<h3 id=\"面向对象\"><a href=\"#面向对象\" class=\"headerlink\" title=\"面向对象\"></a>面向对象</h3><p>面向对象：”<strong>可维护性</strong>“比较好。面向对象的好处之一就是显著的改善了软件系统的&#x3D;&#x3D;可维护性&#x3D;&#x3D;。</p>\n<p>软件工程追求的目标之一就是可维护性，可维护性主要表现在3个方面：可理解性、可测试性和可修改性。</p>\n<p>垃圾回收器主要针对的是<strong>堆内存</strong>。方法区中最先有数据，因为程序执行之前会先进行类加载。栈内存活动最频繁，因为方法不断的执行并结束，不断的进行压栈、弹栈操作。</p>\n<p>对于Student s1 &#x3D; new Student()代码来说，s1不是对象，是一个引用，对象实际上是在堆区当中，s1变量持有这个对象的<strong>内存地址</strong>。引用就是一个变量，只不过该变量中存储的是java对象的内存地址。</p>\n<p>任何“引用”当中存储一定是对象的内存地址。</p>\n<p>private修饰的数据表示私有的，私有的数据只能在<strong>本类</strong>当中访问。</p>\n<h3 id=\"“-x3D-x3D-”和equals\"><a href=\"#“-x3D-x3D-”和equals\" class=\"headerlink\" title=\"“&#x3D;&#x3D;”和equals\"></a>“&#x3D;&#x3D;”和equals</h3><ul>\n<li>“&#x3D;&#x3D;”是运算符，如果是基本数据类型，则比较<strong>存储的值</strong>；如果是引用数据类型，则比较<strong>所指向对象的地址值</strong>。</li>\n<li>equals是Object的方法，比较的是<strong>所指向的对象的地址值</strong>，一般情况下，重写之后比较的是<strong>对象的值</strong>。</li>\n</ul>\n<h2 id=\"MYSQL\"><a href=\"#MYSQL\" class=\"headerlink\" title=\"MYSQL\"></a>MYSQL</h2><p>表的关联关系：一对一、一对多、多对多、自我引用。</p>\n<p>SQL分类：</p>\n<p>DDL数据定义语言</p>\n<p>DML数据操作语言</p>\n<p>DCL数据控制语言</p>\n<p>导入现有数据表：source  文件的全路径名</p>\n<p>as：alias别名，可省略。别名可加” ”双引号。别名中含空格时必须加” ”。</p>\n<p>去重：distinct</p>\n<p>空值null参与运算：结果也为空。</p>\n<p>ifnull(  ,  )</p>\n<p>着重号&#96;&#96;：字段名与保留字重复时使用。</p>\n<p>查询常数：</p>\n<p>显示表结构：desc&#x2F;describe+表名。</p>\n<p>where，声明在from后面。</p>\n<p>运算符：mod、%：取模。模数的符号与被模数相同。</p>\n<p>&#x2F;、div：除以</p>\n<p>+：SQL中无连接作用，只表示加法。</p>\n<p>&lt;&#x3D;&gt;\t安全等于，可以与null进行比较。都为null则返回1。和is  null相同。</p>\n<p>&lt;&gt;\t！&#x3D;\t不等于</p>\n<p>isnull(  )</p>\n<p>least(  )\t最小\tgreatest(  )\t最大</p>\n<p>%\t不确定个数的字符\t_\t代表一个不确定的字符</p>\n<p>like\t模糊查询</p>\n<p>xor\t异或：相异为1</p>\n<p>and优先级高于or</p>\n<p>order  by\t默认升序，asc（ascend）；desc（descend）降序</p>\n<p>二级排序</p>\n<p><strong>列的别名</strong>只能在order  by中使用，不能再where中使用。</p>\n<p>limit  偏移量（0开始），显示的条目数。</p>\n<p>offset偏移量</p>\n<p>limit  31,2；   limit  2  offset  31；</p>\n<p>多表连接：等值连接&#x2F;非等值连接</p>\n<p>自连接&#x2F;非自连接</p>\n<p>内连接&#x2F;外连接（左外连接、右外连接、满外连接）inner&#x2F;outer</p>\n<p>union合并结果集，去重</p>\n<p>union  all合并结果集</p>\n<p>自然连接natural  join：自动查询两张表所有相同字段，并进行等值连接。</p>\n<p>using：替换连接条件，填入两表同名的字段。</p>\n<p>单行函数&#x2F;多行函数</p>\n<p>case  when  then  else  end</p>\n<p>加密函数：MD5（）\tsha（）</p>\n<p>聚合函数：MySQL的聚合函数<strong>不能嵌套</strong>使用</p>\n<p>avg\tsum\tmax\tmin\t自动过滤空值null</p>\n<p>count( )的结果不包含null值</p>\n<p>having：无聚合函数时，where效率更高</p>\n<p>单行子查询&#x2F;多行子查询</p>\n<p>是否被查询多次：相关子查询&#x2F;不相关子查询</p>\n<p>多行子查询：in、any、all、some</p>\n<p>除了group   by，其他位置都可以声明子查询。</p>\n<p>group  by  XX  with  Rollup；显示总量</p>\n<p>exist（）\tnot  exist（）</p>\n<p>修改表：alter  table</p>\n<p>alter  table  emp  add salary  double(10,2);</p>\n<p>modify&#x2F;change(字段重命名)&#x2F;drop  column  </p>\n<p>rename  to</p>\n<p>drop  table  if  exists\t删除表，不能回滚。</p>\n<p>truncate  table\t清空数据，结构保留</p>\n<p>commit和rollback</p>\n<p>一旦commit，数据永久保存在数据库中，数据不可回滚。</p>\n<p>rollback：回滚至最近一次commit之后</p>\n<p>truncate  table和delete  from</p>\n<p>相同点：都可以实现对表中所有数据的删除，同时保留表结构。</p>\n<p>truncate  table一旦执行，不支持回滚。</p>\n<p>delete  from可以全部&#x2F;部分清除，数据可以支持回滚。</p>\n<p>DDL操作一旦执行，不可回滚，自动提交。</p>\n<p>DML的默认情况，一旦执行，也是不能回滚的。set- autocommit&#x3D;FALSE，则DML可以实现回滚。</p>\n<p>增删改：</p>\n<p><strong>插入数据：</strong>逐条添加&#x2F;将查询结果插入表中</p>\n<p>逐条：insert  into  emp  values（）;需按声明顺序添加数据。</p>\n<p>insert  into  emp（指定字段）  values（）；</p>\n<p><strong>更新数据</strong>：update ..set…where</p>\n<p>MySQL8新特性：计算列generated  always  as  （）virtual</p>\n<p>decimal\t定点数</p>\n<h3 id=\"char和varchar区别\"><a href=\"#char和varchar区别\" class=\"headerlink\" title=\"char和varchar区别\"></a>char和varchar区别</h3><pre class=\"line-numbers language-txt\" data-language=\"txt\"><code class=\"language-txt\">1、最大长度：\nchar最大长度是255字符，varchar最大长度是65535个字节。\n\n2、定长：\nchar是定长的，不足的部分用隐藏空格填充，varchar是不定长的。\n\n3、空间使用：\nchar会浪费空间，varchar会更加节省空间。\n\n4、查找效率：\nchar查找效率会很高，varchar查找效率会更低。\n\n5、尾部空格：\nchar插入时可省略，varchar插入时不会省略，查找时省略。</code></pre>\n\n<h3 id=\"char比varchar效率更快的原因\"><a href=\"#char比varchar效率更快的原因\" class=\"headerlink\" title=\"char比varchar效率更快的原因\"></a><strong>char比varchar效率更快的原因</strong></h3><img src=\"https://img-blog.csdnimg.cn/01cdbbd3d5364a15825b5afb5b4ed282.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5oiR5LiN5piv56CB56WeaQ==,size_15,color_FFFFFF,t_70,g_se,x_16\" alt=\"img\" style=\"zoom:67%;\" />\n\n<pre class=\"line-numbers language-txt\" data-language=\"txt\"><code class=\"language-txt\">我们可以看到char类型在存放数据的时候，中间是没有间隔的，数据本身是有空格的，但是数据段之间没有间隔，因为我们在创建列的时候已经告诉MySQL列的长度了，MySQL在查询数据的时候，只需要按部就班寻找就行了，不需要在中途计算这个数据段的长度。\n但是varchar类型的存放就不同了，在每个数据段开头，都要有一段空间（1~2个字节）存放数据段的长度，在数据段的结尾还有一段空间（1个字节）标记此字段的节数。MySQL在读取一个数据段的时候，首先要读开头，比如读到了3，说明数据段的长度是3，之后就不多不少，只读3个字节。所以MySQL在遍历数据的时候，磁针要比char类型的列多读很多次磁盘来获取字段的真实长度，这就是为什么varchar比char查询效率低的原因了。</code></pre>\n\n<h3 id=\"SQL语句优化\"><a href=\"#SQL语句优化\" class=\"headerlink\" title=\"SQL语句优化\"></a>SQL语句优化</h3><pre class=\"line-numbers language-txt\" data-language=\"txt\"><code class=\"language-txt\">一、语句优化\n1.少使用select *语句，尽量指明需要查询的具体字段，对于一个字段特别多的表格来说特别消耗数据库性能\n2.对于条件查询等号两边的数据类型需要一致，字符串不加单引号索引会失效\n3.尽量少使用order by排序，对于需要多个字段进行排序的可以使用组合索引；\n4.对于group by语句要先过滤后分组\n5.在查询时尽量少使用null，对字段有多个null可以加默认值\n6.少使用like，对于需要使用的，如需要使用尽量使用like abc% 把模糊查询内容放查询内容后面\n7.在where后面少使用函数或者是运算\n8、去除的distinct过滤字段要少，避免distinct *；\n9、不超过5个以上的表连接。\n\n二、建立合适索引\n1、对于高频筛选字段可以适当的建立索引；\n2、一个表的索引尽量不要超过5个，多了会影响插入数据和修改数据\n3、不要对字段值有重复的字段建立索引，比如性别等；\n4、使用组合索引一定要遵循最左原则；就是触发索引效果的是第一个索引后续的索引进行引进处理\n\n三、替代优化\n1、不要使用not in 和&lt;&gt;,这个会破化索引，not in可以用not exists来替代，&lt;&gt;可以分成两个条件&gt;或者&lt;等；\n2、使用连接join来替代子查询；</code></pre>\n\n<h3 id=\"MySQL-索引\"><a href=\"#MySQL-索引\" class=\"headerlink\" title=\"MySQL 索引\"></a>MySQL 索引</h3><pre class=\"line-numbers language-latex\" data-language=\"latex\"><code class=\"language-latex\">MySQL索引的建立对于MySQL的高效运行是很重要的，索引可以大大提高MySQL的检索速度。\n\n拿汉语字典的目录页（索引）打比方，我们可以按拼音、笔画、偏旁部首等排序的目录（索引）快速查找到需要的字。\n\n索引分单列索引和组合索引。单列索引，即一个索引只包含单个列，一个表可以有多个单列索引，但这不是组合索引。组合索引，即一个索引包含多个列。\n\n创建索引时，你需要确保该索引是应用在 SQL 查询语句的条件(一般作为 WHERE 子句的条件)。\n\n实际上，索引也是一张表，该表保存了主键与索引字段，并指向实体表的记录。\n\n上面都在说使用索引的好处，但过多的使用索引将会造成滥用。因此索引也会有它的缺点：虽然索引大大提高了查询速度，同时却会降低更新表的速度，如对表进行INSERT、UPDATE和DELETE。因为更新表时，MySQL不仅要保存数据，还要保存一下索引文件。\n建立索引会占用磁盘空间的索引文件。</code></pre>\n\n<h3 id=\"索引失效\"><a href=\"#索引失效\" class=\"headerlink\" title=\"索引失效\"></a>索引失效</h3><pre class=\"line-numbers language-txt\" data-language=\"txt\"><code class=\"language-txt\">1、like查询以“%”开头；\n\n2、or语句前后没有同时使用索引(or条件+没有索引的字段)；\n\n3、组合索引中不是使用第一列索引；\n\n4、在索引列上使用“IS NULL”或“IS NOT NULL”操作；\n\n5、在索引字段上进行运算（如，+、-、*、&#x2F;）、使用“not”，“&lt;&gt;”，“!&#x3D;”等等。\n\n6、在索引列上使用mysql的内置函数，索引失效</code></pre>\n\n<h3 id=\"最左匹配原则\"><a href=\"#最左匹配原则\" class=\"headerlink\" title=\"最左匹配原则\"></a>最左匹配原则</h3><p>mysql创建联合索引时，首先会对最左边字段排序，也就是第一个字段，然后再在保证第一个字段有序的情况下，再排序第二个字段，以此类推。所以联合索引最左列是绝对有序的，其他字段无序。</p>\n<p>当我们创建一个联合索引的时候，如(k1,k2,k3)，相当于创建了（k1）、(k1,k2)和(k1,k2,k3)三个索引，这就是最左匹配原则。</p>\n<h3 id=\"脏读、幻读、不可重复读\"><a href=\"#脏读、幻读、不可重复读\" class=\"headerlink\" title=\"脏读、幻读、不可重复读\"></a>脏读、幻读、不可重复读</h3><pre class=\"line-numbers language-latex\" data-language=\"latex\"><code class=\"language-latex\">1、脏读（读未提交）：脏读就是指当一个事务正在访问数据，并且对数据进行了修改，而这种修改还没有提交到数据库中，这时，另外一个事务也访问这个数据，然后使用了这个数据。\n例如：\n张三的工资为5000,事务A中把他的工资改为8000,但事务A尚未提交。\n与此同时，\n事务B正在读取张三的工资，读取到张三的工资为8000。\n随后，\n事务A发生异常，而回滚了事务。张三的工资又回滚为5000。\n最后，\n事务B读取到的张三工资为8000的数据即为脏数据，事务B做了一次脏读。\n\n2、不可重复读：是指在一个事务内，多次读同一数据。在这个事务还没有结束时，另外一个事务也访问该同一数据。那么，在第一个事务中的两次读数据之间，由于第二个事务的修改，那么第一个事务两次读到的的数据可能是不一样的。这样就发生了在一个事务内两次读到的数据是不一样的，因此称为是不可重复读。\n例如：\n在事务A中，读取到张三的工资为5000，操作没有完成，事务还没提交。\n与此同时，\n事务B把张三的工资改为8000，并提交了事务。\n随后，\n在事务A中，再次读取张三的工资，此时工资变为8000。在一个事务中前后两次读取的结果并不致，导致了不可重复读。\n\n3、幻读：是指当事务不是独立执行时发生的一种现象，例如第一个事务对一个表中的数据进行了修改，这种修改涉及到表中的全部数据行。同时，第二个事务也修改这个表中的数据，这种修改是向表中插入一行新数据。那么，以后就会发生操作第一个事务的用户发现表中还有没有修改的数据行，就好象发生了幻觉一样。\n例如：\n目前工资为5000的员工有10人，事务A读取所有工资为5000的人数为10人。\n此时，\n事务B插入一条工资也为5000的记录。\n这是，事务A再次读取工资为5000的员工，记录为11人。此时产生了幻读。</code></pre>\n\n<h3 id=\"SQL注入\"><a href=\"#SQL注入\" class=\"headerlink\" title=\"SQL注入\"></a>SQL注入</h3><p>SQL注入（SQL Injection）是一种常见的Web安全漏洞，主要形成的原因是在数据交互中，前端的数据传入到后台处理时，没有做严格的判断，导致其传入的“数据”拼接到SQL语句中后，被当作SQL语句的一部分执行。 从而导致数据库受损（被脱库、被删除、甚至整个服务器权限陷）。</p>\n<p>即：注入产生的原因是后台服务器接收相关参数未经过滤直接带入数据库查询</p>\n<h3 id=\"MySQL死锁\"><a href=\"#MySQL死锁\" class=\"headerlink\" title=\"MySQL死锁\"></a>MySQL死锁</h3><pre class=\"line-numbers language-latex\" data-language=\"latex\"><code class=\"language-latex\">死锁是2+个线程在执行过程中， 因争夺资源而造成的相互等待的现象，若无外力作用，它们将无法推进下去。\n\n死锁产生的4个必要条件\n1、互斥条件\n指进程对所分配的资源进行排他性使用，即一段时间内某资源只有一个进程占用，其他的进程请求资源只能等待，直至被占有资源的进程得到释放。\n\n2、请求和保留条件\n指进程至少保持占用一个资源，但又提出新的资源请求，而该资源正被其他进程占用，此时请求进程阻塞，但对以获得的其他资源保持不放。\n\n3、不剥夺条件\n指进程已获得的资源，在未使用完之前，不能剥夺，只能使用完时由自己释放。\n\n4、环路等待条件\n值发生死锁时，必然存在一个进程占用资源的环形链，即进程集合（P0，P1，P2, … Pn），P0等待P1资源释放，P1等待P2资源释放，P3等待 … Pn等待P0资源释放。</code></pre>\n\n<h2 id=\"JWT\"><a href=\"#JWT\" class=\"headerlink\" title=\"JWT\"></a>JWT</h2><p>其实就是一个很长的字符串，字符之间通过”.”分隔符分为三个子串，各字串之间没有换行符。</p>\n<p>每一个子串表示了一个功能块，总共有三个部分：JWT头（header)、有效载荷（payload)、签名（signature)。</p>\n<h2 id=\"jwt认证过程\"><a href=\"#jwt认证过程\" class=\"headerlink\" title=\"jwt认证过程\"></a>jwt认证过程</h2><p>授权流程：</p>\n<p> 1、用户请求登录，携带用户名密码到授权中心<br> 2、授权中心携带用户名密码，到用户中心查询用户<br> 3、查询如果正确，生成JWT凭证<br> 4、返回JWT给用户</p>\n<p> 鉴权流程：</p>\n<p> 1、用户请求某微服务功能，携带JWT<br> 2、微服务将jwt交给授权中心校验<br> 3、授权中心返回校验结果到微服务<br> 4、微服务判断校验结果，成功或失败<br> 5、失败则直接返回401<br> 6、成功则处理业务并返回</p>\n<h2 id=\"会话跟踪\"><a href=\"#会话跟踪\" class=\"headerlink\" title=\"会话跟踪\"></a>会话跟踪</h2><p>服务器无法判断这两次请求是同一个客户端发过来的，还是不同的客户端发过来的。</p>\n<p>通过会话跟踪技术来解决无状态的问题。</p>\n<p>会话跟踪技术主要有以下四种：</p>\n<p><strong>（1）Cookie</strong></p>\n<p><strong>（2）url重写</strong></p>\n<p><strong>（3）隐藏表单域</strong></p>\n<p><strong>（4）Session</strong></p>\n<h2 id=\"URI与URL\"><a href=\"#URI与URL\" class=\"headerlink\" title=\"URI与URL\"></a>URI与URL</h2><p>URI 在于I(Identifier)是统一资源标示符，可以唯一标识一个资源。<br>URL 在于Locater，是统一资源定位符，提供找到该资源的确切路径</p>\n<h2 id=\"主键策略\"><a href=\"#主键策略\" class=\"headerlink\" title=\"主键策略\"></a>主键策略</h2><p>MyBatis-Plus默认的主键策略是：ID_WORKER \t全局唯一ID</p>\n<p>自增策略@TableId(type &#x3D; IdType.AUTO)</p>\n<p>ID_WORKER_STR、AUTO、UUID、NONE、INPUT</p>\n<p><a href=\"https://www.cnblogs.com/haoxinyue/p/5208136.html\">分布式系统唯一ID生成方案汇总 - nick hao - 博客园 (cnblogs.com)</a></p>\n<p><strong>1. 数据库自增长序列或字段</strong></p>\n<p><strong>2. UUID</strong></p>\n<p><strong>3. UUID的变种</strong></p>\n<p><strong>4. Redis生成ID</strong></p>\n<p><strong>5. Twitter的snowflake算法</strong></p>\n<p><strong>6. 利用zookeeper生成唯一ID</strong></p>\n<h2 id=\"MP实现乐观锁\"><a href=\"#MP实现乐观锁\" class=\"headerlink\" title=\"MP实现乐观锁\"></a>MP实现乐观锁</h2><p>（1）数据库中添加version字段</p>\n<pre class=\"line-numbers language-sql\" data-language=\"sql\"><code class=\"language-sql\">ALTER TABLE &#96;user&#96; ADD COLUMN &#96;version&#96; INT</code></pre>\n\n<p>（2）实体类添加version字段，并添加 @Version 注解</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">@Version\n@TableField(fill &#x3D; FieldFill.INSERT)\nprivate Integer version;</code></pre>\n\n<h2 id=\"乐观锁插件\"><a href=\"#乐观锁插件\" class=\"headerlink\" title=\"乐观锁插件\"></a>乐观锁插件</h2><pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">@EnableTransactionManagement\n@Configuration\n@MapperScan(&quot;com.dxc.mybatis_plus.mapper&quot;)\npublic class MybatisPlusConfig &#123;\n&#x2F;&#x2F;乐观锁插件\n@Bean\npublic OptimisticLockerInterceptor optimisticLockerInterceptor() &#123;\n\treturn new OptimisticLockerInterceptor();\n\t&#125;\n&#125;</code></pre>\n\n<h2 id=\"MyBatis-Plus实现分页\"><a href=\"#MyBatis-Plus实现分页\" class=\"headerlink\" title=\"MyBatis Plus实现分页\"></a>MyBatis Plus实现分页</h2><pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;&#x2F;在配置类中创建分页插件\n@Bean\npublic PaginationInterceptor paginationInterceptor() &#123;\n\treturn new PaginationInterceptor();\n&#125;\n\n\tPage&lt;User&gt; page &#x3D; new Page&lt;&gt;(1,5);\n\tuserMapper.selectPage(page, null);</code></pre>\n\n<h2 id=\"逻辑删除\"><a href=\"#逻辑删除\" class=\"headerlink\" title=\"逻辑删除\"></a>逻辑删除</h2><p>对应数据中代表是否被删除字段状态修改为“被删除状态”，之后在数据库中仍旧能看到此条数据记录</p>\n<p>（1）数据库中添加 deleted字段</p>\n<p>（2）实体类添加deleted 字段，并加上 @TableLogic 注解 和 @TableField(fill &#x3D; FieldFill.INSERT) 注解</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">@TableLogic\n@TableField(fill &#x3D; FieldFill.INSERT)\nprivate Integer deleted;</code></pre>\n\n<p>（3）元对象处理器接口添加deleted的insert默认值</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">@Override\npublic void insertFill(MetaObject metaObject) &#123;\n\t......\n\tthis.setFieldValByName(&quot;deleted&quot;, 0, metaObject);\n&#125;</code></pre>\n\n<p>（4）在 MybatisPlusConfig 中注册 Bean</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;&#x2F;逻辑删除插件\n@Bean\npublic ISqlInjector sqlInjector() &#123;\n\treturn new LogicSqlInjector();\n&#125;</code></pre>\n\n<h2 id=\"QueryWrapper的方法\"><a href=\"#QueryWrapper的方法\" class=\"headerlink\" title=\"QueryWrapper的方法\"></a>QueryWrapper的方法</h2><p>ge、gt、le、lt、isNull、isNotNull、eq、ne、between、notBetween、allEq、like、notLike、likeLeft、likeRight、in、notIn、inSql、notinSql、exists、notExists</p>\n<h2 id=\"配置类\"><a href=\"#配置类\" class=\"headerlink\" title=\"配置类\"></a>配置类</h2><p><code>@Configuration</code><br>配置类：在springboot中被@Configuration或者@SpringBootConfiguration标注的类称之为配置类。</p>\n<p>在配置类可以定义很多@Bean的方法，可以让这些@Bean修饰的方式让spring框架加载到ioc容器中去。</p>\n<h2 id=\"RestController\"><a href=\"#RestController\" class=\"headerlink\" title=\"@RestController\"></a>@RestController</h2><p><code>@RestController=@Controller + @ResponseBody。</code></p>\n<p><code>@ResponseBody</code></p>\n<p>在请求方法上加上这个注解，控制器就会将请求响应的数据以指定的格式写入到Response的body中去。 </p>\n<h2 id=\"RequestBody\"><a href=\"#RequestBody\" class=\"headerlink\" title=\"@RequestBody\"></a>@RequestBody</h2><p><code>@RequestBody</code>用来处理请求头<code>Content-Type</code>: 为<code> application/json</code>编码的内容，明确的告诉服务器发送的内容是<code>json</code>。<br>因为需要读取body中内容，所以只能接受<code>post</code>请求。</p>\n<h2 id=\"http-method请求方式\"><a href=\"#http-method请求方式\" class=\"headerlink\" title=\"http method请求方式\"></a>http method请求方式</h2><p>常用的就是get post delete put;</p>\n<p>Patch方式是对put方式的一种补充;</p>\n<p>put方式是可以更新.但是更新的是整体.patch是对局部更新;</p>\n<ul>\n<li><em>@GetMapping</em></li>\n<li><em>@PostMapping</em></li>\n<li><em>@PutMapping</em></li>\n<li><em>@DeleteMapping</em></li>\n</ul>\n<h2 id=\"PathVariable\"><a href=\"#PathVariable\" class=\"headerlink\" title=\"@PathVariable\"></a>@PathVariable</h2><p>映射URL绑定的占位符</p>\n<h2 id=\"条件分页查询\"><a href=\"#条件分页查询\" class=\"headerlink\" title=\"条件分页查询\"></a>条件分页查询</h2><p>在数据库表中找到相应的条件，&#x3D;&#x3D;把条件写在一个类中封装为对象&#x3D;&#x3D;，通过wrapper判断。</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">@ApiOperation(&quot;带条件的分页查询&quot;)\n&#x2F;&#x2F; 条件查询带分页的方法\n@PostMapping(&quot;pageTeacherCondition&#x2F;&#123;current&#125;&#x2F;&#123;limit&#125;&quot;)\npublic R pageTeacherCondition(@PathVariable long current, @PathVariable long limit,\n                                  @RequestBody(required &#x3D; false) TeacherQuery teacherQuery) &#123;&#125;</code></pre>\n\n<h2 id=\"封装统一返回结果\"><a href=\"#封装统一返回结果\" class=\"headerlink\" title=\"封装统一返回结果\"></a>封装统一返回结果</h2><p>规范代码，对统一返回结果进行封装，方便前后端交互。</p>\n<h2 id=\"GET和POST\"><a href=\"#GET和POST\" class=\"headerlink\" title=\"GET和POST\"></a>GET和POST</h2><p>最直观区别：GET把参数包含在URL中，POST通过request body传递参数</p>\n<p>get是从服务器上获取数据，post是向服务器传送数据。</p>\n<p>get传送的数据量较小，不能大于2KB。post传送的数据量较大，一般被默认为不受限制。</p>\n<p>get安全性非常低，post安全性较高。 因为参数直接暴露在URL上，所以不建议使用get请求来传递敏感信息。</p>\n<p>GET请求只能进行url编码，而POST支持多种编码方式。</p>\n<p>GET请求会被浏览器主动缓存，而POST不会</p>\n<p>GET请求在URL中传送的参数是有长度限制的，而POST没有。</p>\n<h2 id=\"状态码\"><a href=\"#状态码\" class=\"headerlink\" title=\"状态码\"></a>状态码</h2><p>1XX（信息性状态码）表示接收的请求正在处理<br>2XX（成功状态码）表示请求正常处理完毕<br>3XX（重定向状态码）表示需要进行附加操作以完成请求<br>4XX（客户端错误状态码）表示服务器无法处理请求<br>5XX（服务器错误状态码）表示服务器处理请求出错</p>\n<p>常见状态码  </p>\n<pre class=\"line-numbers language-txt\" data-language=\"txt\"><code class=\"language-txt\">200 OK——客户端发来的请求在服务器端被正常处理\n在响应报文中，随状态码返回的信息会因方法的不同而改变。比如，使用GET时对应请求资源的实体会作为响应返回；使用HEAD时，在响应中只返回首部，不返回实体的主体部分。\n204 No Content——服务器接收的请求已成功处理，但返回的响应报文中不含实体的主体部分，即无资源可返回\n一般在只需从客户端往服务器发送信息，而对客户端不需要发送新信息内容的情况下使用。\n206 Partial Content——服务器成功执行了客户端发来的范围GET请求\n\n301 Moved Permanently——永久重定向（请求的资源已被分配新的URL，以后应使用资源现在所指的URL）\n302 Found——临时重定向（请求的资源已被分配新的URL，希望用户本次使用新的URL）\n303 See Other——由于请求对应的资源存在着另一个URL，应使用GET方法定向获取请求的资源\n与302功能相同，但不同点在于303要求使用GET方法获取资源。\n304 Not Modified——客户端发送附带条件的请求时，，服务器端允许请求访问资源，但请求未满足条件\n304其实与重定向没有关系。\n307 Temporary Redirect——临时重定向，但请求方式不会从POST变为GET\n与302含义相同，但是302规定的禁止POST变为GET并不被遵守，而307严格遵守不会从POST变为GET。\n\n400 Bad Request——请求报文中存在语法错误\n401 Unauthorized——发送的请求需有通过HTTP认证的认证信息\n当浏览器初次接收401，会弹出认证用的对话窗口；若之前已进行过1次请求，则表示用户认证失败。返回含有401的响应必须包含一个适用于被请求资源的WWW-Authenticate首部用以质询用户信息。\n403 Forbidden——对请求资源的访问被服务器拒绝了\n404 Not Found——服务器上无法找到请求的资源\n500 Internal Server Error——服务器在执行请求时发生错误\n503 Service Unavailable——服务器暂处于超负载或正在进行停机维护，现在无法处理请求\n\n4开头的状态码，在后端接口正确的时候，一般是前端的问题\n\n5开头的状态码，基本都是后端的问题</code></pre>\n\n<h2 id=\"统一异常处理类\"><a href=\"#统一异常处理类\" class=\"headerlink\" title=\"统一异常处理类\"></a>统一异常处理类</h2><pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">@ExceptionHandler(ArithmeticException.class)\n@ResponseBody\npublic R error(ArithmeticException e)&#123;\n\te.printStackTrace();\n\treturn R.error().message(&quot;执行了自定义异常&quot;);\n&#125;\n&#x2F;&#x2F;自定义异常\n@Data\n@AllArgsConstructor\n@NoArgsConstructor\npublic class GuliException extends RuntimeException &#123;\n\t@ApiModelProperty(value &#x3D; &quot;状态码&quot;)\n\tprivate Integer code;\n\tprivate String msg;\n&#125;\n\n&#x2F;&#x2F;在GlobalExceptionHandler.java中添加\n@ExceptionHandler(GuliException.class)\n@ResponseBody\npublic R error(GuliException e)&#123;\ne.printStackTrace();\nreturn R.error().message(e.getMsg()).code(e.getCode());\n&#125;</code></pre>\n\n<h2 id=\"Lombok\"><a href=\"#Lombok\" class=\"headerlink\" title=\"Lombok\"></a><strong>Lombok</strong></h2><p>能通过注解的形式自动生成构造器、getter&#x2F;setter、equals、hashcode、toString等方法，提高了一定的开发效率让代码变得简洁，不用过多的去关注相应的方法，属性做修改时，也简化了维护为这些属性所生成的getter&#x2F;setter方法等。</p>\n<p>不仅自己要安装，任何和你协同开发的人都要安装。对于代码有很强的侵入性，那就会影响我们对JDK的升级。</p>\n<h2 id=\"Java是值传递还是引用传递\"><a href=\"#Java是值传递还是引用传递\" class=\"headerlink\" title=\"Java是值传递还是引用传递\"></a>Java是值传递还是引用传递</h2><p> Java 语言中，&#x3D;&#x3D;本质只有值传递&#x3D;&#x3D;，而无引用传递</p>\n<p>值传递（Pass By Value）指的是方法传参时，&#x3D;&#x3D;传递的是原内容的副本&#x3D;&#x3D;，因此对副本进行如何修改都不会影响原内容。</p>\n<p>引用传递（Pass By Reference）指的是方法传参时，传递的是参数本身，因此对参数进行任意修改都会影响原内容。</p>\n<p>在 Java 语言中只有值传递，方法传参时只会传递副本信息而非原内容。我们还知道了基础数据类型会直接生成到栈上，而对象或数组则会在栈和堆上都生成信息，并将栈上生成的引用，直接指向堆中生成的数据。</p>\n<h2 id=\"值传递机制\"><a href=\"#值传递机制\" class=\"headerlink\" title=\"值传递机制\"></a>值传递机制</h2><p>如果参数是基本数据类型，此时实参赋给形参的是实参真实存储的数据值。</p>\n<p>如果参数是引用数据类型，此时实参赋给形参的是实参存储数据的地址值。</p>\n<h2 id=\"跨域\"><a href=\"#跨域\" class=\"headerlink\" title=\"跨域\"></a>跨域</h2><p>跨域本质：是浏览器基于同源策略的一种安全手段，是一种约定，它是浏览器最核心也最基本的安全功能，如果缺少了同源策略，则浏览器的正常功能可能都会受到影响。Web 是构建在同源策略基础之上的，浏览器只是针对同源策略的一种实现。同源策略会阻止一个域的javascript脚本和另外一个域的内容进行交互。浏览器执行JavaScript脚本时，会检查这个脚本属于哪个页面，如果不是同源页面,就不会被执行。所谓同源（即指在同一个域）就是两个页面具有相同的协议（protocol），主机（host）和端口号（port）。</p>\n<p><strong>如何解决？</strong></p>\n<p>Nginx VS CORS</p>\n<p>简单来说，<strong>Nginx是间接跨域，而CORS则实现了直接跨域</strong>。Nginx的反向代理“欺诈了”浏览器，所以浏览器和服务器都认为是同源访问，所以Session不会丢失。（PS：如果发生跨域访问，服务器会每次都创建新的Session，所以才造成了前后端分离的Session丢失问题。） 至于CORS这种跨域机制的安全性和灵活性更高，但需要自己解决跨域访问Session丢失的问题，通常情况可以采用Session+Redis来实现Session共享。<strong>）</strong></p>\n<p>1.Nginx</p>\n<p>如果是通过<code>vue-cli</code>脚手架工具搭建项目，我们可以通过<code>webpack</code>为我们起一个本地服务器作为请求的代理对象通过该服务器转发请求至目标服务器，得到结果再转发给前端，<strong>但是最终发布上线时如果web应用和接口服务器不在一起仍会跨域</strong>,在<code>vue.config.js</code>文件。</p>\n<p>2.CORS</p>\n<pre class=\"line-numbers language-txt\" data-language=\"txt\"><code class=\"language-txt\">CORS （Cross-Origin Resource Sharing，跨域资源共享）是一种W3C标准，它由一系列传输的HTTP头组成，这些HTTP头决定浏览器是否阻止前端 JavaScript 代码获取跨域请求的响应</code></pre>\n\n<p>CORS 实现起来非常方便，只需要增加一些 HTTP 头，让服务器能声明允许的访问来源。只要后端实现了 CORS，就实现了跨域</p>\n<p>1.当一个请求url的&#x3D;&#x3D;[协议、域名、端口]&#x3D;&#x3D;三者之间任意一个与当前页面url不同即为跨域。</p>\n<p>跨域解决方式</p>\n<p>(1)在后端接口Controller类添加注解（&#x3D;&#x3D;常用&#x3D;&#x3D;）</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">@CrossOrigin\t&#x2F;&#x2F;解决跨域\npublic class EduLoginController &#123;\n&#125;</code></pre>\n\n\n<p>(2)使用网关解决</p>\n<h2 id=\"使用阿里云OSS服务，实现对课程封面以及讲师头像的储存\"><a href=\"#使用阿里云OSS服务，实现对课程封面以及讲师头像的储存\" class=\"headerlink\" title=\"使用阿里云OSS服务，实现对课程封面以及讲师头像的储存\"></a>使用阿里云OSS服务，实现对课程封面以及讲师头像的储存</h2><p>1.创建子模块</p>\n<p>2.引入相关依赖</p>\n<p>3.添加配置文件</p>\n<p>4.添加相关注解</p>\n<h2 id=\"网易云、阿里云、腾讯云、七牛云\"><a href=\"#网易云、阿里云、腾讯云、七牛云\" class=\"headerlink\" title=\"网易云、阿里云、腾讯云、七牛云\"></a>网易云、阿里云、腾讯云、七牛云</h2><p>网易云不管是从服务、文档 、价格及直播解决方案都没有话说，转码目前免费，但潜意识里大家还是会先用腾讯和阿里，毕竟腾讯和阿里更大。阿里在云服务这一块的能力是&#x3D;&#x3D;最全面的&#x3D;&#x3D;，基本具备所有云平台提供的所有功能，但阿里直播方案还不够合理，每个产品是独立存在的，但产品之间又有相互关联，比较难搞清楚，比较绕，而且目前直播会产生额外的2处费用。腾讯中规中矩。阿里腾讯稳定性没话说。七牛主要集中在云存储和直播方面上面， &#x3D;&#x3D;稳定性欠缺&#x3D;&#x3D;许多，而且文档真是乱， 但七牛服务好，解答问题及时。</p>\n<h2 id=\"CDN\"><a href=\"#CDN\" class=\"headerlink\" title=\"CDN\"></a>CDN</h2><p>CDN(Content Delivery Network)是指内容分发网络，也称为内容传送网络，这个概念始于1996年，是美国麻省理工学院的一个研究小组为改善互联网的服务质量而提出的。为了能在传统IP网上发布丰富的宽带媒体内容，他们提出在现有互联网基础上建立一个内容分发平台专门为网站提供服务，并于1999年成立了专门的CDN服务公司，为Yahoo提供专业服务。由于CDN是为加快网络访问速度而被优化的网络覆盖层，因此被形象地称为“网络加速器”。</p>\n<p>归纳起来，CDN具有以下主要功能：</p>\n<pre class=\"line-numbers language-markdown\" data-language=\"markdown\"><code class=\"language-markdown\">(1)节省骨干网带宽，减少带宽需求量；\n(2)提供服务器端加速，解决由于用户访问量大造成的服务器过载问题；\n(3)服务商能使用Web Cache技术在本地缓存用户访问过的Web页面和对象，实现相同对象的访问无须占用主干的出口带宽，并提高用户访问因特网页面的相应时间的需求；\n(4)能克服网站分布不均的问题，并且能降低网站自身建设和维护成本；\n(5)降低“通信风暴”的影响，提高网络访问的稳定性。</code></pre>\n\n<h2 id=\"Spring中的注解\"><a href=\"#Spring中的注解\" class=\"headerlink\" title=\"Spring中的注解\"></a>Spring中的注解</h2><p>主要分为两类：</p>\n<p>类级别的注解： 如@Component、@Repository、@Controller、@Service以及JavaEE6的@ManagedBean和@Named注解，都是添加在类上面的类级别注解。</p>\n<p>类内部的注解： 如@Bean、@Autowired、@Value、@Resource以及EJB和WebService相关的注解等，都是添加在类内部的字段或者方法上的类内部注解。</p>\n<p><strong>1.声明bean的注解</strong></p>\n<p>@Component组件，通用的注解方式</p>\n<p>@Service 在业务逻辑层使用（service层）</p>\n<p>@Repository 在数据访问层使用（dao层）</p>\n<p>@Controller 在表现层使用，控制器的声明</p>\n<p><strong>2.注入bean的注解</strong></p>\n<p>@Autowired：由Spring提供</p>\n<p>@Inject：由JSR-330提供</p>\n<p>@Resource：由JSR-250提供</p>\n<p>都可以注解在set方法和属性上，推荐注解在属性上（一目了然，少写代码）。</p>\n<p><strong>3.java配置类相关注解</strong></p>\n<p>@Configuration 声明当前类为配置类，相当于xml形式的Spring配置（类上）</p>\n<p>@Bean 注解在方法上，声明当前方法的返回值为一个bean，替代xml中的方式（方法上）</p>\n<p>@Configuration 声明当前类为配置类，其中内部组合了@Component注解，表明这个类是一个bean（类上）</p>\n<p>@ComponentScan 用于对Component进行扫描，相当于xml中的（类上）</p>\n<p>@WishlyConfiguration 为@Configuration与@ComponentScan的组合注解，可以替代这两个注解</p>\n<p><strong>4.切面（AOP）相关注解</strong></p>\n<p>Spring支持AspectJ的注解式切面编程。</p>\n<p>@Aspect 声明一个切面（类上）</p>\n<p>使用@After、@Before、@Around定义建言（advice），可直接将拦截规则（切点）作为参数。</p>\n<p>@After 在方法执行之后执行（方法上） @Before 在方法执行之前执行（方法上） @Around 在方法执行之前与之后执行（方法上）</p>\n<p>@PointCut 声明切点</p>\n<p>在java配置类中使用@EnableAspectJAutoProxy注解开启Spring对AspectJ代理的支持（类上）</p>\n<h3 id=\"Component和-Bean的区别\"><a href=\"#Component和-Bean的区别\" class=\"headerlink\" title=\"@Component和@Bean的区别\"></a>@Component和@Bean的区别</h3><p>1.Component注解表明一个类会作为组件类，并告知Spring要为这个类创建bean。</p>\n<p>2.Bean注解告诉Spring这个方法将会返回一个对象，这个对象要注册成Spring应用上下文中的bean。通常方法体包含了最终产生bean实例的逻辑。</p>\n<p>区别：</p>\n<ul>\n<li><p>Component通常是通过类路径扫描来自动侦测以及自动装配到Spring容器中</p>\n</li>\n<li><p>Bean注解通常是我们在标有该注解的方法中定义产生这个bean的逻辑。</p>\n</li>\n<li><p>&#x3D;&#x3D;Component用在类上，Bean用在方法上&#x3D;&#x3D;。</p>\n</li>\n</ul>\n<h2 id=\"Springboot自动装配的原理\"><a href=\"#Springboot自动装配的原理\" class=\"headerlink\" title=\"Springboot自动装配的原理\"></a>Springboot自动装配的原理</h2><pre class=\"line-numbers language-markdown\" data-language=\"markdown\"><code class=\"language-markdown\">1.springboot自动装配主要是基于注解编程，和预定优于配置的思想来进行设计的\n\n自动装配就是自动地把其他组件中的Bean装载到IOC容器中，不需要开发人员再去配置文件中添加大量的配置，\n我们只需要在springboot的启动类上添加一个SptingBootApplication的一个注解，这样就可以开启自动装配\n这种自动装配的思想在spring3.x以后就支持了，我们只需要在类上添加一个叫做@Enable的注解就可以了，只是spring没有向SpringBoot这样全面去设计，\n因此Spring和SpringBoot最大的区别就是在于SpringBoot的自动装配\n\n2.自动装配的原理又是什么？\n\n@SptingBootApplication这个注解是暴露给用户使用的一个入口，它的底层其实是由@EnableAutoConfiguration这个注解来实现的，\n\n自动装配的实现，归纳为以下三个核心的步骤：\n\n第一步：\n启动依赖组件的时候组件中必须要包含@Configuration的配置类，在这个配置类里面声明为Bean注解，然后将方法的返回值或者是属性注入到IOC容器中\n\n第二部：\n第三方jar包，SpringBoot会采用SPI机制，在&#x2F;META-INF&#x2F;目录下增加spring.factories文件，然后SpringBoot会自动根据约定，自动使用SpringFactoriesLoader来加载配置文件中的内容\n\n第三步：\n\nSpring获取到第三方jar中的配置以后会调用ImportSelector接口来完成动态加载，\n这样设计的好处，在于大幅度减少了臃肿的配置文件，而各模块之间的依赖，也深度的解耦，\n\n比如我们使用Spring创建Web程序的时候需要引用非常多的Maven依赖，而SpringBoot中只需要引用一个Maven依赖就可以来创建Web程序.并且SpringBoot把我们常用的依赖都放在了一起，，我们只需要去引入spring-boot-starter-web这个依赖就可以去完成一个简单的Web应用\n\n以前我们使用Spring的时候需要xml文件来配置开启一些功能，现在使用SpringBoot就不需要xml文件了，\n只需要一个加了@Configuration注解的类，或者是实现了对因接口的配置类就可以了\n\nSpringBoot自动装配是Spring的完善和扩展，就是为了我们便捷开发，方便测试和部署，提高效率而诞生的框架技术。</code></pre>\n\n<h2 id=\"Springboot常用注解\"><a href=\"#Springboot常用注解\" class=\"headerlink\" title=\"Springboot常用注解\"></a>Springboot常用注解</h2><p>@SpringBootApplication；@Repository；@Service；@RestController；@ResponseBody。</p>\n<h2 id=\"Springboot项目四种启动方式\"><a href=\"#Springboot项目四种启动方式\" class=\"headerlink\" title=\"Springboot项目四种启动方式\"></a>Springboot项目四种启动方式</h2><p>一：使用 <code>@SpringBootApplication</code> 注解，右击 Run AS -&gt; Java Application</p>\n<p>二：在pom文件中配置使用启动SpringBoot的<a href=\"https://so.csdn.net/so/search?q=maven&spm=1001.2101.3001.7020\">maven</a>插件。即在springboot的应用的根目录下运行mvn spring-boot:run</p>\n<p>三：打jar包来访问。java -jar tx_demo2-0.0.1-SNAPSHOT.jar</p>\n<p>四：通过docker容器虚拟化运行</p>\n<h2 id=\"Spring-Boot-项目特点\"><a href=\"#Spring-Boot-项目特点\" class=\"headerlink\" title=\"Spring Boot 项目特点\"></a>Spring Boot 项目特点</h2><p>&#x3D;&#x3D;完全采用注解化&#x3D;&#x3D;（使用注解方式启动SpringMVC），简化XML，&#x3D;&#x3D;内置HTTP服务器&#x3D;&#x3D;（Tomcat，Jetty），最终以java应用程序进行执行；（不需要翻入打包放入到服务器，之间通过Java命令可以执行（java -jar））</p>\n<pre class=\"line-numbers language-latex\" data-language=\"latex\"><code class=\"language-latex\">1. 独立运行的 Spring 项目\nSpring Boot可以以 jar 包的形式独立运行，Spring Boot 项目只需通过命令“ java–jar xx.jar” 即可运行。\n\n2. 内嵌 Servlet 容器\nSpring Boot使用嵌入式的 Servlet容器（例如 Tomcat、Jetty 或者 Undertow 等），应用无需打成 WAR 包 。\n\n3. 提供 starter 简化 Maven 配置\nSpring Boot 提供了一系列的“starter”项目对象模型（POMS）来简化 Maven 配置。\n\n4. 提供了大量的自动配置\nSpring Boot 提供了大量的默认自动配置，来简化项目的开发，开发人员也通过配置文件修改默认配置。\n\n5. 自带应用监控\nSpring Boot 可以对正在运行的项目提供监控。\n\n6. 无代码生成和 xml 配置\nSpring Boot 不需要任何 xml 配置即可实现 Spring 的所有配置。\n\n为基于Springb的开发提供更快的入门体验。\n创建可以独立运行的Spring应用\n直接嵌入Tomcat和Jetty服务器，不需要打包成WAR文件\n提供推荐的基础POM文件（starter）来简化Apache Maven配置\n尽可能的提供项目依赖来自动配置Spring框架\n提供可以直接在生产环境中使用的功能，如性能指标、应用信息和应用健康检查\n开箱即用，没有代码生成，也无需XMl配置。同时也可以修改默认值来满足特定的需求。\n其他大量项目都是基于Spring Boot之上的，如Spring Cloud\nSpring Boot使编码变简单\nSpring Boot使配置变简单\nSpring Boot使部署变简单\nSpring Boot使监控变简单\n\nSpring Boot 的缺点\n1、依赖太多，随便一个Spring Boot的应用都有好几十M\n2、缺少服务的注册和发现等解决方案\n3、缺少监控集成方案、安全管理方案\n4、中文的文档和资料太少且不够深入</code></pre>\n\n<h2 id=\"Spring-MVC常用注解\"><a href=\"#Spring-MVC常用注解\" class=\"headerlink\" title=\"Spring MVC常用注解\"></a>Spring MVC常用注解</h2><pre class=\"line-numbers language-markdown\" data-language=\"markdown\"><code class=\"language-markdown\">@Controller\n@Controller注解在类上，表明这个类是Spring MVC里的Controller，将其声明为Spring的一个Bean，Dispatch Servlet会自动扫描注解了此注解的类，并将Web请求映射到注解了@RequestMapping的方法上，需要注意的是，在Spring MVC声明控制器Bean的时候，只能使用@Controller。\n\n@RequestMapping\n@RequestMapping注解是用来映射Web请求（访问路径和参数）、处理类和方法的。它可以注解在类和方法上。注解在方法上的@RequestMapping路径会继承注解在类上的路径，@RequestMapping支持Servlet的request和response作为参数，也支持对它们的媒体类型进行配置。\n\n@RequestBody\n@RequestBody允许request的参数在request体中，而不是在直接链接在地址后面。此注解放在参数前。\n\n@RestController\n@RestController是一个组合注解，组合了@Controller和@ResponseBody，意味着当只开发一个和页面交互数据的控制的时候，需要使用此注解。 若没有此注解，要想实现上述功能，则需自己在代码中加@Controller和@ResponseBody两个注解。\n\n@Autowired\n@Autowired为Spring提供的注解，需要导入包,byType注入\n@Resource\n@Resource默认按照ByName自动注入\n@PathVariable\n用于将请求URL中的模板变量映射到功能处理方法的参数上，即取出uri模板中的变量作为参数。</code></pre>\n\n<p>转发：在返回值前面加”forward”,<br>重定向：在返回值前面加”redirect”</p>\n<h2 id=\"微服务五大组件\"><a href=\"#微服务五大组件\" class=\"headerlink\" title=\"微服务五大组件\"></a>微服务五大组件</h2><p>1.Eureka：注册中心</p>\n<p>2.Zuul：服务网关</p>\n<p>3.Ribbon：负载均衡</p>\n<p>4.Feign：服务调用</p>\n<p>5.Hystix：熔断器</p>\n<h2 id=\"Conditional\"><a href=\"#Conditional\" class=\"headerlink\" title=\"@Conditional\"></a>@Conditional</h2><p>@Conditional是Spring4新提供的注解，它的作用是按照一定的条件进行判断，满足条件给容器注册bean。</p>\n<h2 id=\"Spring初始化bean有两种方式\"><a href=\"#Spring初始化bean有两种方式\" class=\"headerlink\" title=\"Spring初始化bean有两种方式\"></a>Spring初始化bean有两种方式</h2><p>  1）实现InitializingBean接口，继而实现afterPropertiesSet的方法 ；</p>\n<p>  2）利用类反射原理，配置加载文件，使用init-method标签直接注入bean。</p>\n<h2 id=\"Bean的生命周期\"><a href=\"#Bean的生命周期\" class=\"headerlink\" title=\"Bean的生命周期\"></a>Bean的生命周期</h2><p>分为四个阶段：</p>\n<p>1、 实例化(Instantiation)</p>\n<p>2、 属性设置(populate)</p>\n<p>3、 初始化(Initialization)</p>\n<p>4、 销毁(Destruction)</p>\n<h2 id=\"接口\"><a href=\"#接口\" class=\"headerlink\" title=\"接口\"></a>接口</h2><pre class=\"line-numbers language-txt\" data-language=\"txt\"><code class=\"language-txt\">接口（英文：Interface），在JAVA编程语言中是一个抽象类型，是抽象方法的集合，接口通常以interface来声明。一个类通过继承接口的方式，从而来继承接口的抽象方法。\n\n接口并不是类，编写接口的方式和类很相似，但是它们属于不同的概念。类描述对象的属性和方法。接口则包含类要实现的方法。\n\n除非实现接口的类是抽象类，否则该类要定义接口中的所有方法。\n\n接口无法被实例化，但是可以被实现。一个实现接口的类，必须实现接口内所描述的所有方法，否则就必须声明为抽象类。另外，在 Java 中，接口类型可用来声明一个变量，他们可以成为一个空指针，或是被绑定在一个以此接口实现的对象。</code></pre>\n\n<p>API接口：</p>\n<p>应用程序角度的接口:</p>\n<ul>\n<li>内部接口：</li>\n</ul>\n<p>最常见的就是开发过程中，后端开发写好了一个方法，封装成了一个接口，供前端开发人员调用，来实现某个特定功能，我们就可以通过在页面上做操作，来间接调用这个接口来实现某个特定功能，这种接口就属于api接口。</p>\n<ul>\n<li>外部接口：</li>\n</ul>\n<p>同理，当我们开发某些功能需要调用第三方接口时（比如支付功能），需要调用支付宝的第三方接口来实现支付功能，这种第三方接口，也属于api接口。</p>\n<p>总结：</p>\n<p>interface是在代码中使用的接口,api是提供给外部使用的程序接入点。</p>\n<p>前者是编程语言中使用的,没有具体实现的抽象的定义，后者其实是一个已经包含了逻辑的可执行的程序,供外部使用的。</p>\n<h2 id=\"泛型\"><a href=\"#泛型\" class=\"headerlink\" title=\"泛型\"></a>泛型</h2><p>泛型的好处是&#x3D;&#x3D;在编译的时候检查类型安全&#x3D;&#x3D;，并且所有的强制转换都是自动和隐式的，以提高代码的重用率。</p>\n<p>泛型有三种使用方式，分别为：泛型类、泛型接口、泛型方法.</p>\n<h2 id=\"泛型擦除\"><a href=\"#泛型擦除\" class=\"headerlink\" title=\"泛型擦除\"></a>泛型擦除</h2><p>使用泛型的时候加上的类型参数，会被编译器&#x3D;&#x3D;在编译的时候去掉&#x3D;&#x3D;。如在代码中定义的 List<Object>和 List<String>等类型，在编译之后都会变成 List。 这个过程就称为类型擦除。</p>\n<p>JVM并不知道泛型的存在，因为泛型在编译阶段就已经被处理成普通的类和方法。</p>\n<h2 id=\"spring配置文件加载顺序\"><a href=\"#spring配置文件加载顺序\" class=\"headerlink\" title=\"spring配置文件加载顺序\"></a>spring配置文件加载顺序</h2><p>yml文件与properties文件同时存在时，优先使用properties的配置，其他配置进行互补</p>\n<pre class=\"line-numbers language-latex\" data-language=\"latex\"><code class=\"language-latex\">（1）命令行参数：\n在命令行中通过 java -jar 命令启动项目时，可以使用连续的两个减号 – 对配置文件中的属性值进行赋值，则命令行设置的属性会覆盖配置文件中属性的值。\njava -jar xx.jar --server.port&#x3D;8081，会覆盖配置文件中的端口。\n\n（2）外置配置文件：\n还可以指定配置文件的路径或者目录，则系统会使用指定的配置文件，或者目录下所有的配置文件。\njava -jar xxx.jar --spring.config.location&#x3D;&#x2F;opt&#x2F;servicex&#x2F;config&#x2F;application.yml\njava -jar xxx.jar --spring.config.location&#x3D;&#x2F;opt&#x2F;servicex&#x2F;config&#x2F;</code></pre>\n\n<h2 id=\"yml、properties\"><a href=\"#yml、properties\" class=\"headerlink\" title=\"yml、properties\"></a>yml、properties</h2><p>加载顺序yml&gt;properties,优先级properties&gt;yml，properties会覆盖yml</p>\n<p>&#x3D;&#x3D;加载顺序和优先级是相反的&#x3D;&#x3D;，正常的加载顺序是yml&gt;properties，但是由于后加载的会覆盖先加载的，所以当两种文件都有的时候我们看到的是properties的执行了和yml的被覆盖了，所以优先级是properties&gt;yml</p>\n<h2 id=\"ArrayList与LinkedList\"><a href=\"#ArrayList与LinkedList\" class=\"headerlink\" title=\"ArrayList与LinkedList\"></a>ArrayList与LinkedList</h2><p>ArrayList 是基于数组实现的，LinkedList 是基于双向链表实现的，ArrayList 在新增和删除元素时，因为涉及到数组复制，所以效率比 LinkedList 低，而在遍历的时候，ArrayList 的效率要高于 LinkedList。<br>ArrayList 是基于动态数组实现的非线程安全的集合。当底层数组满的情况下还在继续添加的元素时，ArrayList则会执行扩容机制扩大其数组长度。ArrayList查询速度非常快，使得它在实际开发中被广泛使用。美中不足的是插入和删除元素较慢，同时它并不是线程安全的。<br>扩容机制：通过扩容机制判断原数组是否还有空间，若没有则重新实例化一个空间更大的新数组，把旧数组的数据拷贝到新数组中，先判断下标是否越界，再扩容。若插入的下标为i，则通过复制数组的方式将i后面的所有元素，往后移一位，新数据替换下标为i的旧元素。<br>LinkedList 是基于双向链表实现的非线程安全的集合，它是一个链表结构，不能像数组一样随机访问，必须是每个元素依次遍历直到找到元素为止。其结构的特殊性导致它查询数据慢。<br>查询时先判断元素是靠近头部，还是靠近尾部，然后再查询。</p>\n<h2 id=\"ArrayList的扩容机制\"><a href=\"#ArrayList的扩容机制\" class=\"headerlink\" title=\"ArrayList的扩容机制\"></a>ArrayList的扩容机制</h2><p>（1） jdk 1.8中，集合的初始化容量为10；<br>（2）当集合中元素的个数+1超过了数组的容量，就需要进行扩容；<br>（3）每次扩容到原来的1.5倍。</p>\n<h2 id=\"ArrayList怎么实现线程安全\"><a href=\"#ArrayList怎么实现线程安全\" class=\"headerlink\" title=\"ArrayList怎么实现线程安全\"></a>ArrayList怎么实现线程安全</h2><p>使用Collections包下的synchronizedList()</p>\n<h2 id=\"Arrays-asList\"><a href=\"#Arrays-asList\" class=\"headerlink\" title=\"Arrays.asList()\"></a>Arrays.asList()</h2><p>我们可以使用它将一个数组转换为一个List集合</p>\n<p>如果你的List只是用来遍历，就用Arrays.asList()。</p>\n<p>如果你的List还要添加或删除元素，还是乖乖地new一个java.util.ArrayList，然后一个一个的添加元素。</p>\n<h2 id=\"接口和抽象类有什么区别\"><a href=\"#接口和抽象类有什么区别\" class=\"headerlink\" title=\"接口和抽象类有什么区别\"></a>接口和抽象类有什么区别</h2><p>他们&#x3D;&#x3D;都不能实例化对象，都可以包含抽象方法&#x3D;&#x3D;，而且抽象方法必须被继承的类全部实现。</p>\n<p>区别：</p>\n<p>1、抽象类和接口都不能直接实例化，如果要实例化，抽象类变量必须指向实现所有抽象方法的子类对象，接口变量必须指向实现所有接口方法的类对象。</p>\n<p>2、抽象类要被子类继承，接口要被类实现。</p>\n<p>3、接口只能做方法申明，抽象类中可以做方法申明，也可以做方法实现</p>\n<p>4、接口里定义的变量只能是公共的静态的常量，抽象类中的变量是普通变量。</p>\n<p>5、抽象类里的抽象方法必须全部被子类所实现，如果子类不能全部实现父类抽象方法，那么该子类只能是抽象类。同样，一个实现接口的时候，如不能全部实现接口方法，那么该类也只能为抽象类。</p>\n<p>6、抽象方法只能申明，不能实现，接口是设计的结果 ，抽象类是重构的结果</p>\n<p>7、抽象类里可以没有抽象方法</p>\n<p>8、如果一个类里有抽象方法，那么这个类只能是抽象类</p>\n<p>9、抽象方法要被实现，所以不能是静态的，也不能是私有的。</p>\n<p>10、接口可继承接口，并可多继承接口，但类只能单根继承。</p>\n<h2 id=\"HashMap\"><a href=\"#HashMap\" class=\"headerlink\" title=\"HashMap\"></a>HashMap</h2><p>数组的特点：查询效率高，插入、删除效率低。</p>\n<p>链表的特点：查询效率低，插入、删除效率高。</p>\n<p>在HashMap底层使用数组加（链表或红黑树）的结构完美的解决了数组和链表的问题，使得查询和插入，删除的效率都很高。</p>\n<p>java1.7 之前是数组+链表 ，之后是 数组+链表+红黑树。</p>\n<p>HashMap 有两个影响性能的关键参数：&#x3D;&#x3D;“初始容量”和“加载因子”&#x3D;&#x3D;</p>\n<ul>\n<li>容量 capacity：就是哈希表中数组的数量，默认初始容量是16，容量必须是2的N次幂（涉及到位移运算），这是为了提高计算机的执行效率。为了能让HashMap &#x3D;&#x3D;存取高效，尽量较少碰撞&#x3D;&#x3D;，也就是要尽量把数据分配均匀，每个链表&#x2F;红黑树长度大致相同。这个实现就是把数据存到哪个链表&#x2F;红黑树中的算法。</li>\n<li>加载因子 loadfactor：在 HashMap 扩容之前，容量可以达到多满的程度，默认值为 0.75</li>\n<li>扩容阈值 threshold &#x3D; capacity * loadfactor</li>\n</ul>\n<h3 id=\"HashMap-的-put-方法添加元素的过程：\"><a href=\"#HashMap-的-put-方法添加元素的过程：\" class=\"headerlink\" title=\"HashMap 的 put() 方法添加元素的过程：\"></a><strong>HashMap 的 put() 方法添加元素的过程：</strong></h3><p>1）重新计算 hash 值：</p>\n<p>拿到 key 的 hashcode 值之后，调用 hash() 方法重新计算 hash 值，防止质量低下的 hashCode() 函数出现，从而使 hash 值的分布尽量均匀。</p>\n<p>2）计算元素存放在数组中的哪个位置：</p>\n<p>将重新计算出来的 hash 值与 (tablel.length-1) 进行位与&amp;运算，得出元素应该放入数组的哪个位置。</p>\n<p>3）将 key-value 添加到数组中：</p>\n<p>① 如果计算出的数组位置上为空，那么直接将这个元素插入放到该位置中。</p>\n<p>② 如果数组该位置上已经存在链表，则使用 equals() 比较链表上是否存在 key 相同的节点，如果为true，则替换原元素；如果不存在，则在链表的尾部插入新节点（Jdk1.7及以前的版本使用的头插法）</p>\n<p>③ 如果插入元素后，如果链表的节点数是否超过8个，则调用 treeifyBin() 将链表节点转为红黑树节点。</p>\n<p>④ 最后判断 HashMap 总容量是否超过阈值 threshold，则调用 resize() 方法进行扩容，扩容后数组的长度变成原来的2倍。</p>\n<h3 id=\"HashMap扩容的过程：\"><a href=\"#HashMap扩容的过程：\" class=\"headerlink\" title=\"HashMap扩容的过程：\"></a>HashMap扩容的过程：</h3><p>（1）&#x3D;&#x3D;重新建立一个新的数组&#x3D;&#x3D;，长度为原数组的两倍；</p>\n<p>（2）遍历旧数组的每个数据，&#x3D;&#x3D;重新计算每个元素在新数组中的存储位置&#x3D;&#x3D;。使用节点的hash值与旧数组长度进行位与运算，如果运算结果为0，表示元素在新数组中的位置不变；否则，则在新数组中的位置下标&#x3D;原位置+原数组长度。</p>\n<p>（3）将旧数组上的每个数据使用尾插法逐个转移到新数组中，并重新设置扩容阈值。</p>\n<h3 id=\"HashMap链表转换成红黑树：\"><a href=\"#HashMap链表转换成红黑树：\" class=\"headerlink\" title=\"HashMap链表转换成红黑树：\"></a>HashMap链表转换成红黑树：</h3><p>当数组中某个位置的节点达到8个时，会触发 treeifyBin() 方法将链表节点（Node）转红黑树节点（TreeNode，间接继承Node），转成红黑树节点后，其实链表的结构还存在，通过next属性维持，红黑树节点在进行操作时都会维护链表的结构，并不是转为红黑树节点后，链表结构就不存在了。当数组中某个位置的节点在移除后达到6个时，并且该索引位置的节点为红黑树节点，会触发 untreeify() 将红黑树节点转化成链表节点。</p>\n<h2 id=\"ConcurrentHashMap\"><a href=\"#ConcurrentHashMap\" class=\"headerlink\" title=\"ConcurrentHashMap\"></a>ConcurrentHashMap</h2><p>实现原理：在 JDK8 及以上的版本中，ConcurrentHashMap 的底层数据结构依然采用“数组+链表+红黑树”，但是在实现线程安全性方面，采用了 synchronized + CAS 算法来保证线程安全。在ConcurrentHashMap中，大量使用 Unsafe.compareAndSwapXXX 的方法，这类方法是利用一个CAS算法实现无锁化的修改值操作，可以大大减少使用加锁造成的性能消耗。这个算法的基本思想就是&#x3D;&#x3D;不断比较当前内存中的变量值和你预期变量值是否相等&#x3D;&#x3D;，如果相等，则接受修改的值，否则拒绝你的而操作。因为当前线程中的值已经不是最新的值，你的修改很可能会覆盖掉其他线程修改的结果。</p>\n<h2 id=\"HashMap和Hashtable的区别\"><a href=\"#HashMap和Hashtable的区别\" class=\"headerlink\" title=\"HashMap和Hashtable的区别\"></a>HashMap和Hashtable的区别</h2><p>相同点:hashmap和Hashtable都实现了map、Cloneable（可克隆）、Serializable（可序列化）这三个接口</p>\n<p>不同点:</p>\n<pre class=\"line-numbers language-txt\" data-language=\"txt\"><code class=\"language-txt\">底层数据结构不同:\njdk1.7底层都是数组+链表,但jdk1.8 HashMap加入了红黑树\nHashtable 是不允许键或值为 null 的，HashMap 的键值则都可以为 null。\n添加key-value的hash值算法不同：HashMap添加元素时，是使用自定义的哈希算法,而HashTable是直接采用key的hashCode()\n\n实现方式不同：Hashtable 继承的是 Dictionary类，而 HashMap 继承的是 AbstractMap 类。\n初始化容量不同：HashMap 的初始容量为：16，Hashtable 初始容量为：11，两者的负载因子默认都是：0.75。\n扩容机制不同：当已用容量&gt;总容量 * 负载因子时，HashMap 扩容规则为当前容量翻倍，Hashtable 扩容规则为当前容量翻倍 +1。\n\n支持的遍历种类不同：HashMap只支持Iterator遍历,而HashTable支持Iterator和Enumeration两种方式遍历\n迭代器不同：HashMap的迭代器(Iterator)是fail-fast迭代器，而Hashtable的enumerator迭代器不是fail-fast的。所以当有其它线程改变了HashMap的结构（增加或者移除元素），将会抛出ConcurrentModificationException，但迭代器本身的remove()方法移除元素则不会抛出ConcurrentModificationException异常。但这并不是一个一定发生的行为，要看JVM。而Hashtable 则不会。\n部分API不同：HashMap不支持contains(Object value)方法，没有重写toString()方法,而HashTable支持contains(Object value)方法，而且重写了toString()方法\n\n同步性不同: Hashtable是同步(synchronized)的，适用于多线程环境,\n而hashmap不是同步的，适用于单线程环境。多个线程可以共享一个Hashtable；而如果没有正确的同步的话，多个线程是不能共享HashMap的。\n由于Hashtable是线程安全的也是synchronized，所以在单线程环境下它比HashMap要慢。如果你不需要同步，只需要单一线程，那么使用HashMap性能要好过Hashtable。</code></pre>\n\n<h2 id=\"哈希函数和哈希码\"><a href=\"#哈希函数和哈希码\" class=\"headerlink\" title=\"哈希函数和哈希码\"></a>哈希函数和哈希码</h2><p>Hash，一般翻译为“散列”，也有直接音译为“哈希”的，这就是把任意长度的输入通过散列算法，变换成固定长度的输出，该输出就是散列值（哈希值）；这种转换是一种压缩映射，也就是，散列值的空间通常远小于输入的空间，不同的输入可能会散列成相同的输出，所以不可能从散列值来唯一的确定输入值。简单的说就是一种将任意长度的消息压缩到某一固定长度的消息摘要的函数。</p>\n<p>所有散列函数都有如下一个基本特性：根据同一散列函数计算出的散列值如果不同，那么输入值肯定也不同。但是，根据同一散列函数计算出的散列值如果相同，输入值不一定相同。</p>\n<h2 id=\"哈希碰撞\"><a href=\"#哈希碰撞\" class=\"headerlink\" title=\"哈希碰撞\"></a>哈希碰撞</h2><p>哈希：将不同的输入映射成独一无二的、固定长度的值（又称”哈希值”）。它是最常见的软件运算之一。如果不同的输入得到了同一个哈希值，就发生了”哈希碰撞”（collision）。、</p>\n<h3 id=\"哈希冲突解决方案：\"><a href=\"#哈希冲突解决方案：\" class=\"headerlink\" title=\"哈希冲突解决方案：\"></a>哈希冲突解决方案：</h3><p>1.开放地址法：（再散列法）：当关键字key的哈希地址p出现冲突时，以p为基础，产生另一个哈希地址p1，如果p1仍然冲突，再以p为基础，产生另一个哈希地址，直到找出一个不冲突的哈希地址pi ，将相应元素存入其中。</p>\n<p>2.再哈希法：在发生冲突的时候再用另外一个哈希函数算出哈希值，直到算出的哈希值不同为止。 </p>\n<p>3.链地址法（拉链法）：例如HashMap。把同一个散列槽（数组的每一个槽）中的所有元素放到一个链表中。</p>\n<p>4.建立公共溢出区法： 在创建哈希表的同时，再额外创建一个公共溢出区，专门用来存放发生哈希冲突的元素。查找时，先从哈希表查，查不到再去公共溢出区查。</p>\n<h2 id=\"Iterator\"><a href=\"#Iterator\" class=\"headerlink\" title=\"Iterator\"></a>Iterator</h2><p>迭代器可以对集合进⾏遍历，但每⼀个集合内部的数据结构可能是不尽相同的，所以每⼀个集合存和取都很可能是不⼀样的，虽然我们可以⼈为地在每⼀个类中定义 hasNext() 和 next() ⽅法，但这样做会让整个集合体系过于臃肿。于是就有了迭代器。</p>\n<p>主要是⽤来遍历集合⽤的，它的特点是更加安全，因为它可以确保，在当前遍历的集合元素被更改的时候，就会抛出 ConcurrentModificationException 异常。</p>\n<h2 id=\"乐观锁和悲观锁\"><a href=\"#乐观锁和悲观锁\" class=\"headerlink\" title=\"乐观锁和悲观锁\"></a>乐观锁和悲观锁</h2><pre class=\"line-numbers language-latex\" data-language=\"latex\"><code class=\"language-latex\">一、什么是乐观锁\n乐观锁，顾名思义就是总是假设最好的情况，每次获取数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据，可以使用版本号机制和 CAS 算法实现。乐观锁适用于多读的应用类型，这样可以提高吞吐量，像数据库提供的类似于 write_condition 机制，其实都是提供的乐观锁。在 Java 中 java.util.concurrent.atomic 包下面的原子变量类就是使用了乐观锁的一种实现方式 CAS 实现的。 \n\n二、什么是悲观锁\n悲观锁，顾名思义就是总是假设最坏的情况，每次获取数据的时候都认为别人会修改，所以每次在获取数据的时候都会上锁，这样别人想获取这个数据就会阻塞直到它拿到锁后才可以获取（共享资源每次只给一个线程使用，其它线程阻塞，当前线程用完后再把资源转让给其它线程）。传统的关系型数据库里边就用到了很多这种锁机制，比如行锁、表锁、读锁、写锁等，都是在做操作之前先上锁。Java 中 synchronized 和 ReentrantLock 等独占锁就是悲观锁思想的实现。\n\n三、两种锁的使用场景\n  从上面对两种锁的介绍，我们知道两种锁各有优缺点，我们不可以简单的认为它们哪一种更好 ，像乐观锁适用于写比较少的情况下（多读场景），即实际冲突很少发生的时候，这样可以省去加锁造成的开销，加大了系统的整个吞吐量。但如果是在多写的情况，一般会经常产生冲突，这就会导致上层应用会不断的进行重试，这样反倒是降低了性能，所以一般在多写的场景下使用悲观锁就比较合适。</code></pre>\n\n<h2 id=\"CAS\"><a href=\"#CAS\" class=\"headerlink\" title=\"CAS\"></a>CAS</h2><p>CAS(compare and swap),比较并交换。可以解决多线程并行情况下使用锁造成性能损耗的一种机制。</p>\n<p>CAS 操作包含三个操作数—内存位置（V）、预期原值（A）和新值(B)。</p>\n<p>如果内存位置的值与预期原值相匹配，那么处理器会自动将该位置值更新为新值。否则，处理器不做任何操作。一个线程从主内存中得到num值，并对num进行操作，写入值的时候，线程会把第一次取到的num值和主内存中num值进行比较，如果相等，就会将改变后的num写入主内存，如果不相等，则一直循环对比，知道成功为止。</p>\n<p>优点：cas是一种乐观锁的思想，而且是一种非阻塞的轻量级的乐观锁，非阻塞式是指一个线程的失败或者挂起不应该影响其他线程的失败或挂起的算法。</p>\n<h2 id=\"ABA\"><a href=\"#ABA\" class=\"headerlink\" title=\"ABA\"></a>ABA</h2><p>本质：<strong>ABA问题的根本在于cas在修改变量的时候，无法记录变量的状态，比如修改的次数，否修改过这个变量。这样就很容易在一个线程将A修改成B时，另一个线程又会把B修改成A,造成casd多次执行的问题。</strong></p>\n<p>当执行campare and swap会出现失败的情况。例如，一个线程先读取共享内存数据值A，随后因某种原因，线程暂时挂起，同时另一个线程临时将共享内存数据值先改为B，随后又改回为A。随后挂起线程恢复，并通过CAS比较，最终比较结果将会无变化。这样会通过检查，这就是ABA问题。 在CAS比较前会读取原始数据，随后进行原子CAS操作。这个间隙之间由于并发操作，最终可能会带来问题。</p>\n<h2 id=\"数据库事务\"><a href=\"#数据库事务\" class=\"headerlink\" title=\"数据库事务\"></a>数据库事务</h2><p>具有四个特征：原子性（ Atomicity ）、一致性（ Consistency ）、隔离性（ Isolation ）和持续性（ Durability ）。这四个特性简称为 ACID 特性。</p>\n<pre class=\"line-numbers language-latex\" data-language=\"latex\"><code class=\"language-latex\">原子性：一个事务（transaction）中的所有操作，要么全部完成，要么全部不完成，不会结束在中间某个环节。事务在执行过程中发生错误，会被回滚（Rollback）到事务开始前的状态，就像这个事务从来没有执行过一样。\n\n一致性：在事务开始之前和事务结束以后，数据库的完整性没有被破坏。这表示写入的资料必须完全符合所有的预设规则，这包含资料的精确度、串联性以及后续数据库可以自发性地完成预定的工作。\n\n隔离性：数据库允许多个并发事务同时对其数据进行读写和修改的能力，隔离性可以防止多个事务并发执行时由于交叉执行而导致数据的不一致。事务隔离分为不同级别，包括读未提交（Read uncommitted）、读提交（read committed）、可重复读（repeatable read）和串行化（Serializable）。 \n\n持久性：事务处理结束后，对数据的修改就是永久的，即便系统故障也不会丢失。</code></pre>\n\n<h2 id=\"Spring注解事务失效原因\"><a href=\"#Spring注解事务失效原因\" class=\"headerlink\" title=\"Spring注解事务失效原因\"></a>Spring注解事务失效原因</h2><pre class=\"line-numbers language-latex\" data-language=\"latex\"><code class=\"language-latex\">原因一：没有开启事务管理\n原因二：标注了@Transactional的方法里面的异常被捕获了\n原因三：标注了@Transactional的方法发生了非Error 或者 非RuntimeException\n原因四：标注了@Transactional的方法的事务传播类型propagation配置成了NOTSUPPORT\n原因五：标注了@Transactional的方法的事务传播类型propagation配置成了NEVER\n原因六：标注了@Transactional的方法的事务传播类型propagation配置成了SUPPORTS且当前没有事务\n原因七：外部调用方法A，A内部调用方法B，A没有@Transaction注解而B有@Transactional注解\n原因九：标注了@Transactional的方法不是public的\n原因十：标注了@Transactional的方法发生的异常不是rollbackFor指定的类型或子类\n原因十一：数据库不支持事务</code></pre>\n\n<h2 id=\"MySQL的四种隔离级别\"><a href=\"#MySQL的四种隔离级别\" class=\"headerlink\" title=\"MySQL的四种隔离级别\"></a>MySQL的四种隔离级别</h2><p>SQL标准定义了4类隔离级别，包括了一些具体规则，用来限定事务内外的哪些改变是可见的，哪些是不可见的。低级别的隔离级一般支持更高的并发处理，并拥有更低的系统开销。</p>\n<p>Read Uncommitted（读取未提交内容）</p>\n<p>在该隔离级别，所有事务都可以看到其他未提交事务的执行结果。本隔离级别很少用于实际应用，因为它的性能也不比其他级别好多少。读取未提交的数据，也被称之为脏读（Dirty Read）。</p>\n<p>Read Committed（读取提交内容）<br>这是大多数数据库系统的默认隔离级别（但不是MySQL默认的）。它满足了隔离的简单定义：一个事务只能看见已经提交事务所做的改变。这种隔离级别 也支持所谓的不可重复读（Nonrepeatable Read），因为同一事务的其他实例在该实例处理其间可能会有新的commit，所以同一select可能返回不同结果。</p>\n<p>Repeatable Read（可重复读）</p>\n<p>这是MySQL的&#x3D;&#x3D;默认事务隔离级别&#x3D;&#x3D;，它确保同一事务的多个实例在并发读取数据时，会看到同样的数据行。不过理论上，这会导致另一个棘手的问题：幻读 （Phantom Read）。简单的说，幻读指当用户读取某一范围的数据行时，另一个事务又在该范围内插入了新行，当用户再读取该范围的数据行时，会发现有新的“幻影” 行。InnoDB和Falcon存储引擎通过多版本并发控制（MVCC，Multiversion Concurrency Control）机制解决了该问题。</p>\n<p>Serializable（可串行化）</p>\n<p>这是最高的隔离级别，它通过强制事务排序，使之不可能相互冲突，从而解决幻读问题。简言之，它是在每个读的数据行上加上共享锁。在这个级别，可能导致大量的超时现象和锁竞争。</p>\n<h2 id=\"事务传播行为\"><a href=\"#事务传播行为\" class=\"headerlink\" title=\"事务传播行为\"></a><strong>事务传播行为</strong></h2><p><strong>事务传播行为（propagation behavior）指的就是当一个事务方法被另一个事务方法调用时，这个事务方法应该如何运行。</strong></p>\n<p>例如：methodA方法调用methodB方法时，methodB是继续在调用者methodA的事务中运行呢，还是为自己开启一个新事务运行，这就是由methodB的事务传播行为决定的。</p>\n<ul>\n<li>Spring在TransactionDefinition接口中规定了7种类型的事务传播行为。</li>\n<li>事务传播行为是Spring框架独有的事务增强特性。</li>\n</ul>\n<p><strong>7种：(required &#x2F; supports &#x2F; mandatory &#x2F; requires_new &#x2F; not supported &#x2F; never &#x2F; nested)</strong></p>\n<pre class=\"line-numbers language-txt\" data-language=\"txt\"><code class=\"language-txt\">PROPAGATION_REQUIRED：如果当前没有事务，就创建一个新事务，如果当前存在事务，就加入该事务，这是最常见的选择，也是Spring默认的事务传播行为。(required需要，没有新建，有加入)\nPROPAGATION_SUPPORTS：支持当前事务，如果当前存在事务，就加入该事务，如果当前不存在事务，就以非事务执行。（supports支持，有则加入，没有就不管了，非事务运行）\nPROPAGATION_MANDATORY：支持当前事务，如果当前存在事务，就加入该事务，如果当前不存在事务，就抛出异常。（mandatory强制性，有则加入，没有异常）\nPROPAGATION_REQUIRES_NEW：创建新事务，无论当前存不存在事务，都创建新事务。（requires_new需要新的，不管有没有，直接创建新事务）\nPROPAGATION_NOT_SUPPORTED：以非事务方式执行操作，如果当前存在事务，就把当前事务挂起。（not supported不支持事务，存在就挂起）\nPROPAGATION_NEVER：以非事务方式执行，如果当前存在事务，则抛出异常。（never不支持事务，存在就异常）\nPROPAGATION_NESTED：如果当前存在事务，则在嵌套事务内执行。如果当前没有事务，则按REQUIRED属性执行。（nested存在就在嵌套的执行，没有就找是否存在外面的事务，有则加入，没有则新建）</code></pre>\n\n<h2 id=\"Autowired和-Resource区别：\"><a href=\"#Autowired和-Resource区别：\" class=\"headerlink\" title=\"@Autowired和@Resource区别：\"></a>@Autowired和@Resource区别：</h2><blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>（1）@Autowired：自动按照类型type注入。<br>（2）@Resource：自动按照bean的id注入。可以独立使用，相当于Autowired和Qualifier的结合。</p></blockquote>\n<h2 id=\"maven\"><a href=\"#maven\" class=\"headerlink\" title=\"maven\"></a>maven</h2><p>1） maven可以管理jar文件<br>2）自动下载jar和他的文档，源代码<br>3）管理jar直接的依赖， a.jar需要b.jar ， maven会自动下载b.jar<br>4）管理你需要的jar版本<br>5）帮你编译程序，把java编译为class<br>6）帮你测试你的代码是否正确。<br>7）帮你打包文件，形成jar文件，或者war文件<br>8）帮你部署项目</p>\n<h3 id=\"maven支持的构建包括有：\"><a href=\"#maven支持的构建包括有：\" class=\"headerlink\" title=\"maven支持的构建包括有：\"></a>maven支持的构建包括有：</h3><pre class=\"line-numbers language-mark\" data-language=\"mark\"><code class=\"language-mark\">1.清理， 把之前项目编译的东西删除掉，我新的编译代码做准备。\n2.编译， 把程序源代码编译为执行代码， java-class文件\n批量的，maven可以同时把成千上百的文件编译为class。javac 不一样，javac一次编译一个文件。\n3.测试， maven可以执行测试程序代码，验证你的功能是否正确。批量的，maven同时执行多个测试代码，同时测试很多功能。\n4.报告， 生成测试结果的文件， 测试通过没有。\n5.打包， 把你的项目中所有的class文件，配置文件等所有资源放到一个压缩文件中。这个压缩文件就是项目的结果文件， 通常java程序，压缩文件是jar扩展名的。\n对于web应用，压缩文件扩展名是.war\n6.安装， 把5中生成的文件jar，war安装到本机仓库\n7.部署， 把程序安装好可以执行</code></pre>\n\n<h3 id=\"maven核心概念：\"><a href=\"#maven核心概念：\" class=\"headerlink\" title=\"maven核心概念：\"></a>maven核心概念：</h3><p>①POM ： 一个文件 名称是pom.xml , pom翻译过来叫做项目对象模型。<br>maven把一个项目当做一个模型使用。控制maven构建项目的过程，管理jar依赖。</p>\n<p>②约定的目录结构 ： maven项目的目录和文件的位置都是规定的。</p>\n<p>③坐标 ： 是一个唯一的字符串，用来表示资源的。</p>\n<p>④依赖管理 ： 管理你的项目可以使用jar文件</p>\n<p>⑤仓库管理 ：你的资源存放的位置</p>\n<h2 id=\"SpringMVC的九大组件\"><a href=\"#SpringMVC的九大组件\" class=\"headerlink\" title=\"SpringMVC的九大组件\"></a>SpringMVC的九大组件</h2><p>1、HandlerMapping<br>根据request找到相应的处理器。因为Handler（Controller）有两中形式，一种是基于类的Handler，另一种是基于Method的Handler（也就是我们常用的）<br>2、HandlerAdapter<br>调用Handler的适配器。如果把Handler（Controller）当做工具的话，那么HandlerAdapter就相当于干活的工人</p>\n<p>3、HanderExceptionResolver<br>对异常的处理<br>4、ViewResolver<br>用来将String类型的视图名和Locale解析为View类型的视图<br>5、RequestToViewNameTranslator<br>有的Handler（Controller）处理完后没有设置返回类型，比如是Void方法，这是需要从request中获取的viewName<br>6、LocaleResolver<br>从request中解析出Locale。Locale表示一个区域，比如zh-cn，对于不同的区域的用户，显示不同的结果，这就是i18你（SpringMVC中有具体的拦截器LocaleChangelnterceptor）<br>7、ThemeResolver<br>主题解析，这种类似于我们手机的主题<br>8、MultipartResolver<br>处理上传请求，将普通的request封装成MultipartHttpServletRequest<br>9、FlashMapManager<br>用于管理FlashMap，FlashMap用于在redirect重定向中传递参数</p>\n<h2 id=\"过滤器-Filter-和-拦截器-Interceptor\"><a href=\"#过滤器-Filter-和-拦截器-Interceptor\" class=\"headerlink\" title=\"过滤器 (Filter) 和 拦截器 (Interceptor)\"></a><strong>过滤器 (Filter) 和 拦截器 (Interceptor)</strong></h2><p>1、实现原理不同。过滤器和拦截器底层实现方式大不相同，过滤器 是基于函数回调的，拦截器 则是基于Java的反射机制（动态代理）实现的。</p>\n<p>2、使用范围不同 。我们看到过滤器 实现的是 javax.servlet.Filter 接口，而这个接口是在Servlet规范中定义的，也就是说过滤器Filter 的使用要依赖于Tomcat等容器，导致它只能在web程序中使用。 而拦截器(Interceptor) 它是一个Spring组件，并由Spring容器管理，并不依赖Tomcat等容器，是可以单独使用的。不仅能应用在web程序中，也可以用于Application、Swing等程序中。<br>3、触发时机不同 。过滤器Filter是在请求进入容器后，但在进入servlet之前进行预处理，请求结束是在servlet处理完以后。拦截器 Interceptor 是在请求进入servlet后，在进入Controller之前进行预处理的，Controller 中渲染了对应的视图之后请求结束。</p>\n<p>4、拦截的请求范围不同。 过滤器Filter执行了两次，拦截器Interceptor只执行了一次。这是因为过滤器几乎可以对所有进入容器的请求起作用，而拦截器只会对Controller中请求或访问static目录下的资源请求起作用。</p>\n<p>5、注入Bean情况不同。 这是因为加载顺序导致的问题，拦截器加载的时间点在springcontext之前，而Bean又是由spring进行管理。</p>\n<p>6、控制执行顺序不同。 过滤器用@Order注解控制执行顺序，通过@Order控制过滤器的级别，值越小级别越高越先执行。 拦截器默认的执行顺序，就是它的注册顺序，也可以通过Order手动设置控制，值越小越先执行</p>\n<h2 id=\"Comparator和Comparable的区别\"><a href=\"#Comparator和Comparable的区别\" class=\"headerlink\" title=\"Comparator和Comparable的区别\"></a>Comparator和Comparable的区别</h2><p>Integer、String等这些基本类型的JAVA封装类都已经实现了Comparable接口，这些类对象本身就支持自比较，直接调用Collections.sort()就可以对集合中元素的排序，无需自己去实现Comparable接口。</p>\n<p>有些自定义类的List序列，当这个对象不支持自比较或者自比较函数不能满足你的要求时，你可以写一个比较器来完成两个对象之间大小的比较，也就是指定使用Comparator（临时规则排序，也称作专门规则排序），如果不指定Comparator，那么就用自然规则排序，这里的自然顺序就是实现Comparable接口设定的排序方式。</p>\n<p><img src=\"https://img-blog.csdnimg.cn/2021011710420042.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2RsOTYyNDU0,size_16,color_FFFFFF,t_70\" alt=\"img\"></p>\n<h2 id=\"无序性和不可重复性的含义是什么\"><a href=\"#无序性和不可重复性的含义是什么\" class=\"headerlink\" title=\"无序性和不可重复性的含义是什么\"></a>无序性和不可重复性的含义是什么</h2><p>1、⽆序性不等于随机性 ，⽆序性是指存储的数据在底层数组中并⾮按照数组索引的顺序添加 ，⽽是根据数据的哈希值决定的。<br>2、什么是不可重复性？不可重复性是指添加的元素按照 equals()判断时 ，返回 false，需要同时重写 equals()⽅法和 HashCode()⽅法。</p>\n<h2 id=\"⽐较-HashSet、LinkedHashSet-和-TreeSet-三者的异同\"><a href=\"#⽐较-HashSet、LinkedHashSet-和-TreeSet-三者的异同\" class=\"headerlink\" title=\"⽐较 HashSet、LinkedHashSet 和 TreeSet 三者的异同\"></a>⽐较 HashSet、LinkedHashSet 和 TreeSet 三者的异同</h2><p>HashSet 是 Set 接⼝的主要实现类 ，HashSet 的底层是 HashMap，线程不安全的，可以存储 null<br>值；<br>LinkedHashSet 是 HashSet 的⼦类，能够按照&#x3D;&#x3D;添加的顺序&#x3D;&#x3D;遍历；<br>TreeSet 底层使⽤红⿊树，能够按照添加元素的顺序进⾏遍历，排序的⽅式有⾃然排序和定制排序。</p>\n<h2 id=\"String、StringBuffer、StringBuilder的区别\"><a href=\"#String、StringBuffer、StringBuilder的区别\" class=\"headerlink\" title=\"String、StringBuffer、StringBuilder的区别\"></a>String、StringBuffer、StringBuilder的区别</h2><p>1.三者在java中都是用来处理字符串的</p>\n<p>2.三个类都被final修饰，因此都是不可继承的</p>\n<p>3.StringBuilder与StringBuffer有公共父类AbstractStringBuilder(抽象类)</p>\n<p>String的对象不可变，StringBuffer和StringBuilder的对象是可变的</p>\n<p>String、StringBuffer是线程安全的，&#x3D;&#x3D;StringBuilder是线程不安全的&#x3D;&#x3D;（所以如果程序是单线程的使用StringBuilder效率高，如果是多线程使用StringBuffer或者String）</p>\n<h2 id=\"Token\"><a href=\"#Token\" class=\"headerlink\" title=\"Token\"></a>Token</h2><p>定义：Token是服务端生成的一串字符串，以作客户端进行请求的一个令牌，当第一次登录后，服务器生成一个Token便将此Token返回给客户端，以后客户端只需带上这个Token前来请求数据即可，无需再次带上用户名和密码。</p>\n<p>使用Token的目的：Token的目的是为了减轻服务器的压力，减少频繁的查询数据库，使服务器更加健壮。</p>\n<p>1、用设备号&#x2F;设备mac地址作为Token（推荐）</p>\n<p>客户端：客户端在登录的时候获取设备的设备号&#x2F;mac地址，并将其作为参数传递到服务端。</p>\n<p>服务端：服务端接收到该参数后，便用一个变量来接收同时将其作为Token保存在数据库，并将该Token设置到session中，客户端每次请求的时候都要统一拦截，并将客户端传递的token和服务器端session中的token进行对比，如果相同则放行，不同则拒绝。</p>\n<p>分析：此刻客户端和服务器端就统一了一个唯一的标识Token，而且保证了每一个设备拥有了一个唯一的会话。该方法的缺点是客户端需要带设备号&#x2F;mac地址作为参数传递，而且服务器端还需要保存；优点是客户端不需重新登录，只要登录一次以后一直可以使用，至于超时的问题是有服务器这边来处理，如何处理？若服务器的Token超时后，服务器只需将客户端传递的Token向数据库中查询，同时并赋值给变量Token，如此，Token的超时又重新计时。</p>\n<p>2、用session值作为Token</p>\n<p>客户端：客户端只需携带用户名和密码登陆即可。</p>\n<p>客户端：客户端接收到用户名和密码后并判断，如果正确了就将本地获取sessionID作为Token返回给客户端，客户端以后只需带上请求数据即可。</p>\n<p>分析：这种方式使用的好处是方便，不用存储数据，但是缺点就是当session过期后，客户端必须重新登录才能进行访问数据。</p>\n<h2 id=\"深拷贝与浅拷贝的区别\"><a href=\"#深拷贝与浅拷贝的区别\" class=\"headerlink\" title=\"深拷贝与浅拷贝的区别\"></a>深拷贝与浅拷贝的区别</h2><p>浅拷贝：在拷贝一个对象时，对对象的基本数据类型的成员变量进行拷贝，但对引用类型的成员变量只进行引用的传递，并没有创建一个新的对象，当对引用类型的内容修改会影响被拷贝的对象。</p>\n<p>深拷贝：在拷贝一个对象时，除了对基本数据类型的成员变量进行拷贝，对引用类型的成员变量进行拷贝时，创建一个新的对象来保存引用类型的成员变量。</p>\n<h2 id=\"零拷贝\"><a href=\"#零拷贝\" class=\"headerlink\" title=\"零拷贝\"></a>零拷贝</h2><p>零拷贝是指计算机执行IO操作时，CPU不需要将数据从一个存储区域复制到另一个存储区域，进而减少上下文切换以及CPU的拷贝时间。它是一种IO操作优化技术。</p>\n<h2 id=\"单例模式\"><a href=\"#单例模式\" class=\"headerlink\" title=\"单例模式\"></a>单例模式</h2><p>单例模式（Singleton Pattern）是 Java 中最简单的设计模式之一。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。</p>\n<p><strong>在程序中多次使用同一个对象且作用相同时，为了防止&#x3D;&#x3D;频繁地创建对象使得内存飙升&#x3D;&#x3D;，单例模式可以让程序仅在内存中创建一个对象，让所有需要调用的地方都共享这一单例对象。</strong></p>\n<p>这种模式涉及到一个单一的类，该类负责创建自己的对象，同时确保只有单个对象被创建。这个类提供了一种访问其唯一的对象的方式，可以直接访问，不需要实例化该类的对象。</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class Singleton &#123;\n    private static final Singleton INSTANCE &#x3D; new Singleton();\n    private Singleton() &#123;&#125;\n    public static Singleton getInstance() &#123;\n        return INSTANCE;\n    &#125;\n&#125;</code></pre>\n\n<h3 id=\"懒汉式和饿汉式\"><a href=\"#懒汉式和饿汉式\" class=\"headerlink\" title=\"懒汉式和饿汉式\"></a>懒汉式和饿汉式</h3><ul>\n<li><strong>懒汉式：</strong> 默认不会实例化，什么时候用什么时候new,,线程不安全。</li>\n</ul>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class Lazy &#123;\n    &#x2F;&#x2F;默认不会实例化，什么时候用什么时候new\n    private static Lazy lazy &#x3D; null;\n\n    private Lazy() &#123;\n    &#125;\n\n    public static synchronized Lazy getInstance() &#123;\n        if (lazy &#x3D;&#x3D; null) &#123;\n            lazy &#x3D; new Lazy();\n        &#125;\n        return lazy;\n    &#125;\n&#125;</code></pre>\n\n<ul>\n<li><strong>饿汉式：</strong>类加载的时候就实例化，并且创建单例对象,线程安全。</li>\n</ul>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class Hungry &#123;\n    &#x2F;&#x2F; 类加载的时候就实例化，并且创建单例对象\n    private static final Hungry hungry &#x3D; new Hungry();\n\n    private Hungry() &#123;\n    &#125;\n\n    public static Hungry getInstance() &#123;\n        return hungry;\n    &#125;\n&#125;</code></pre>\n\n<h3 id=\"懒汉式和饿汉式区别：\"><a href=\"#懒汉式和饿汉式区别：\" class=\"headerlink\" title=\"懒汉式和饿汉式区别：\"></a>懒汉式和饿汉式区别：</h3><ul>\n<li><strong>实例化方面：</strong> 懒汉式默认不会实例化，外部什么时候调用什么时候new。饿汉式在类加载的时候就实例化，并且创建单例对象。</li>\n<li><strong>线程安全方面：</strong></li>\n</ul>\n<ol>\n<li>饿汉式线程安全：在线程还没出现之前就已经实例化了，因此饿汉式线程一定是安全的。</li>\n<li>懒汉式线程不安全：因为懒汉式加载是在使用时才会去new 实例的，那么你去new的时候是一个动态的过程，是放到方法中实现的。</li>\n</ol>\n<ul>\n<li><strong>执行效率上：</strong></li>\n</ul>\n<ol>\n<li>饿汉式没有加任何的锁，因此执行效率比较高。</li>\n<li>懒汉式一般使用都会加同步锁，效率比饿汉式差。</li>\n</ol>\n<ul>\n<li><strong>性能上：</strong></li>\n</ul>\n<ol>\n<li>饿汉式在类加载的时候就初始化，不管你是否使用，它都实例化了，所以会占据空间，浪费内存。</li>\n<li>懒汉式什么时候需要什么时候实例化，相对来说不浪费内存。</li>\n</ol>\n<h2 id=\"代理模式\"><a href=\"#代理模式\" class=\"headerlink\" title=\"代理模式\"></a>代理模式</h2><p>&#x3D;&#x3D;目标对象不可访问，通过代理对象的增强功能访问。&#x3D;&#x3D;</p>\n<p>代理模式就是代理对象具备真实对象的功能，并代替真实对象完成相应操作，并能够在操作执行的前后，对操作进行增强处理。<strong>（为真实对象提供代理，然后供其他对象通过代理访问真实对象）</strong></p>\n<p>为其他对象提供一种代理来控制这个对象的访问，在某些情况下一个对象不适合或不能直接引用另一个对象，而代理对象可以在客户类和目标对象直接起到中介的作用</p>\n<ul>\n<li><p>功能增强：其中目标对象实现真正的功能，但是代理对象可以对目标对象的功能做进一步的扩充</p>\n</li>\n<li><p>控制访问：代理类不让你访问目标类</p>\n</li>\n</ul>\n<h3 id=\"静态代理\"><a href=\"#静态代理\" class=\"headerlink\" title=\"静态代理\"></a>静态代理</h3><p>通常是对原有业务逻辑的扩充，通过让代理类持有真实对象，在代理类的源代码中调用被代理类方法来添加我们需要的业务逻辑。例如：买车不去工厂而是去4S店。</p>\n<p>缺点：如果有多个类需要代理，那么就需要创建多个代理类分别代理目标对象，工作量较大，不利于维护。</p>\n<h3 id=\"动态代理\"><a href=\"#动态代理\" class=\"headerlink\" title=\"动态代理\"></a>动态代理</h3><p>在程序执行的过程中，&#x3D;&#x3D;使用jdk的反射机制，创建代理类对象并动态地指定要代理的目标类&#x3D;&#x3D;。也就是说动态代理是一种&#x3D;&#x3D;创建java对象&#x3D;&#x3D;的能力，使得我们不用创建淘宝类或微商类，就能创建代理类对象</p>\n<p>利用的反射机制动态地生成代理的对象，我们不需要知道谁代理谁。代理类的那部分代码被固定下来了，不会因为业务的增加而逐渐庞大。</p>\n<p>在程序运行期，创建目标对象的代理对象，并对目标对象中的方法进行功能性增强的一种技术。</p>\n<p>创建的代理对象，并不是事先在Java代码中定义好的。而是在运行期间，根据我们在动态代理对象中的“指示”，动态生成的。</p>\n<p>动态代理：当想要给实现了某个接口的类中的方法，加一些额外的处理。比如说加日志，加事务等。可以给这个类创建一个代理，故名思议就是创建一个新的类，这个类不仅包含原来类方法的功能，而且还在原来的基础上添加了额外处理的新类。这个代理类并不是定义好的，是动态生成的。具有解耦意义，灵活，扩展性强。</p>\n<p>动态代理的应用：Spring的AOP，加事务，加权限，加日志。</p>\n<pre class=\"line-numbers language-txt\" data-language=\"txt\"><code class=\"language-txt\">invoke（）：表示代理对象要执行的功能代码，你的代理类要完成的功能就写在invoke（）方法中\n（1）代理类要完成的功能\n调用目标方法，执行目标方法的功能\n增强功能\n（2）invoke方法\ninvoke(Object proxy, Method method, Object[] args)\nmethod：目标类中的方法，jdk负责提供method对象\nObject[] args：目标类中的参数\nObject proxy：jdk创建的代理对象，无需赋值\n（3）使用过程\nInvocationHandler接口：表示代理要干什么（定义目标类要完成的功能）\n创建目标类实现接口\n创建InvocationHandler接口的实现类，在invoke方法中完成代理类的功能\ninvoke方法：重写invoke方法，把原来静态代理中代理类要完成的功能写在方法内\nmethod.invoke()是用来执行目标方法的\n使用Proxy类的静态方法，来创建代理对象，并把返回值转换为接口类型\n核心的对象，创建代理对象，之前的对象都是new类的构造方法，现在我们使用的是Proxy类的方法，代替new的使用\n方法newProxyInstance（），作用是创建代理对象，需要三个参数</code></pre>\n\n<h2 id=\"序列化和反序列化\"><a href=\"#序列化和反序列化\" class=\"headerlink\" title=\"序列化和反序列化\"></a>序列化和反序列化</h2><p>序列化就是指把Java对象转换为字节序列的过程</p>\n<p>反序列化就是指把字节序列恢复为Java对象的过程。</p>\n<p>作用：在传递和保存对象时，保证对象的&#x3D;&#x3D;完整性和可传递性&#x3D;&#x3D;。对象转换为有序字节流,以便在网络上传输或者保存在本地文件中。 </p>\n<p>反序列化的最重要的作用：根据字节流中保存的对象状态及描述信息，通过反序列化重建对象。</p>\n<p>总结：核心作用就是&#x3D;&#x3D;对象状态的保存和重建&#x3D;&#x3D;。（整个过程核心点就是字节流中所保存的对象状态及描述信息）</p>\n<h2 id=\"冒泡排序\"><a href=\"#冒泡排序\" class=\"headerlink\" title=\"冒泡排序\"></a>冒泡排序</h2><blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>冒泡排序的英文<strong>Bubble Sort</strong>，是一种最基础的<strong>交换排序</strong>。之所以叫做冒泡排序，因为每一个元素都可以像小气泡一样，根据自身大小一点一点向数组的一侧移动。</p></blockquote>\n<h5 id=\"冒泡排序的原理：\"><a href=\"#冒泡排序的原理：\" class=\"headerlink\" title=\"冒泡排序的原理：\"></a><strong>冒泡排序的原理：</strong></h5><p>每一趟只能确定将一个数归位。即第一趟只能确定将末位上的数归位，第二趟只能将倒数第 2 位上的数归位，依次类推下去。如果有 n 个数进行排序，只需将 n-1 个数归位，也就是要进行 n-1 趟操作。</p>\n<p>而 “每一趟 ” 都需要从第一位开始进行相邻的两个数的比较，将较大的数放后面，比较完毕之后向后挪一位继续比较下面两个相邻的两个数大小关系，重复此步骤，直到最后一个还没归位的数。</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public static int[] bubbleSort(int[] arr) &#123;\n     if (arr &#x3D;&#x3D; null || arr.length &lt; 2) &#123;\n          return arr;\n     &#125;\n     for (int i &#x3D; 0; i &lt; arr.length - 1; i++) &#123;\n         boolean isSorted  &#x3D; true;&#x2F;&#x2F;有序标记，每一轮的初始是true\n         for (int j &#x3D; 0; j &lt; arr.length -i - 1; j++) &#123;\n             if (arr[j + 1] &lt; arr[j]) &#123;\n                 isSorted  &#x3D; false;&#x2F;&#x2F;有元素交换，所以不是有序，标记变为false\n                 int t &#x3D; arr[j];\n                 arr[j] &#x3D; arr[j+1];\n                 arr[j+1] &#x3D; t;\n             &#125;\n         &#125;\n         &#x2F;&#x2F;一趟下来是否发生位置交换，如果没有交换直接跳出大循环\n         if(isSorted )\n              break;\n     &#125;\n     return arr;\n&#125;</code></pre>\n\n<h2 id=\"UTF-8、UTF-16-和-UTF-32\"><a href=\"#UTF-8、UTF-16-和-UTF-32\" class=\"headerlink\" title=\"UTF-8、UTF-16 和 UTF-32\"></a>UTF-8、UTF-16 和 UTF-32</h2><ol>\n<li>UTF-8 在编码字符时最少使用一个字节，而 UTF-16 最少使用两个字节。</li>\n</ol>\n<p>在 UTF-8 中，从 0 到 127 的每个代码点都存储在单个字节中。仅使用 2,3 或实际上最多 4 个字节存储代码点 128 及以上。简而言之，UTF-8 是<em>可变长度编码</em>，占用 1 到 4 个字节，具体取决于代码点。UTF-16 也是可变长度字符编码，但需要 2 或 4 个字节。另一方面，UTF-32 是固定的 4 个字节。</p>\n<ol start=\"2\">\n<li>UTF-8 与 ASCII 兼容，而 UTF-16 与 ASCII 不兼容</li>\n</ol>\n<h2 id=\"Unicode、ISO-10646、UTF-8、GB-2312、GBK的区别\"><a href=\"#Unicode、ISO-10646、UTF-8、GB-2312、GBK的区别\" class=\"headerlink\" title=\"Unicode、ISO 10646、UTF-8、GB-2312、GBK的区别\"></a>Unicode、ISO 10646、UTF-8、GB-2312、GBK的区别</h2><p>首先unicode是一个规范，用于全球统一编码，就是防止出现不同国家使用不同的编码表而出现的乱码情况</p>\n<p>其次IOS和unicode做的是同样的事情，并且unicode和IOS都相互兼容</p>\n<p>UTF-8就是一个遵循了Unicode规范的编码，它能够包含中文等多种字符的编码</p>\n<p>GBK时一个遵循了ISO规范的编码，向下兼容GB2312编码</p>\n<h2 id=\"static静态代码块、实例代码块\"><a href=\"#static静态代码块、实例代码块\" class=\"headerlink\" title=\"static静态代码块、实例代码块\"></a>static静态代码块、实例代码块</h2><p>静态代码块在类加载时执行，并且只执行一次。</p>\n<p>实例代码块在创建对象时（构造方法执行之前）执行。对象构建的时机。</p>\n<h2 id=\"面向对象的设计原则-7大原则\"><a href=\"#面向对象的设计原则-7大原则\" class=\"headerlink\" title=\"面向对象的设计原则(7大原则)\"></a>面向对象的设计原则(7大原则)</h2><p>★ 1、开闭原则: 是总纲，告诉我们要对扩展开放，对修改关闭；<br>★ 2、里氏替换原则: 告诉我们不要破坏继承体系；<br>                子类继承父类时，除添加新的方法完成新增功能外，尽量不要重写父类的方法。<br>★ 3、依赖倒置原则:告诉我们不要破坏继承体系；要面向接口编程，不要面向实现编程。<br>★ 4、单一职责原则: 告诉我们实现类&#x2F;方法要职责单一；一个类只负责一项职责，一个方法只负责处理一项事情。<br>★ 5、接口隔离原则： 告诉我们在设计接口的时候要精简单一；一个接口只服务于一个子模块或业务逻辑。只是单一职责是侧重于约束类和方法。而借口隔离侧重约束接口。<br>★ 6、迪米特法则：告诉我们要降低耦合度；<br>★ 7、合成复用（最少依赖）原则：告诉我们要优先使用组合或者聚合关系复用，少用继承关系复用。</p>\n<h2 id=\"远程调用技术\"><a href=\"#远程调用技术\" class=\"headerlink\" title=\"远程调用技术\"></a>远程调用技术</h2><p>例：手机归属地、天气查询、银行卡余额</p>\n<p>系统之间的调用。（业务层实现）</p>\n<p>微软的.NET技术应该算是时下最为流行的Web Service 开发技术。首先因为其公司在以前相应的产品就占有相当大的市场份额，以至使新推出的.NET得以有比较稳定的用户群；其次也是更重要的是 .NET平台不仅延续了微软一贯的编程风格，而且还增加了许多支持Web 服务的关键性技术，使得.NET在操作的简单性和执行的稳定性，高效性上达到了一个非常好的结合。</p>\n<p>从表面上看，Web service 就是一个应用程序，&#x3D;&#x3D;它向外界暴露出一个能够通过Web进行调用的API&#x3D;&#x3D;。这就是说，你能够用编程的方法通过Web来调用这个应用程序。我们把调用这个Web service 的应用程序叫做客户。例如，你想创建一个Web service ，它的作用是返回当前的天气情况。那么你可以建立一个ASP页面，它接受邮政编码作为查询字符串，然后返回一个由逗号隔开的字符串，包含了当前的气温和天气。</p>\n<p>Web services是建立可互操作的分布式应用程序的新平台。作为一个Windows程序员，你可能已经用COM或DCOM建立过基于组件的分布式应用程序。COM是一个非常好的组件技术，但是我们也很容易举出COM并不能满足要求的情况。<br>Web service平台是一套标准，它定义了应用程序如何在Web上实现互操作性。你可以用任何你喜欢的语言，在任何你喜欢的平台上写Web service ，只要我们可以通过Web service标准对这些服务进行查询和访问。</p>\n<h2 id=\"Java8-新特性\"><a href=\"#Java8-新特性\" class=\"headerlink\" title=\"Java8 新特性\"></a>Java8 新特性</h2><ul>\n<li><strong>Lambda 表达式</strong> − Lambda 允许把函数作为一个方法的参数（函数作为参数传递到方法中）。</li>\n<li><strong>方法引用</strong> − 方法引用提供了非常有用的语法，可以直接引用已有Java类或对象（实例）的方法或构造器。与lambda联合使用，方法引用可以使语言的构造更紧凑简洁，减少冗余代码。</li>\n<li><strong>默认方法</strong> − 默认方法就是一个在接口里面有了一个实现的方法。</li>\n<li><strong>新工具</strong> − 新的编译工具，如：Nashorn引擎 jjs、 类依赖分析器jdeps。</li>\n<li><strong>Stream API</strong> −新添加的Stream API（java.util.stream） 把真正的函数式编程风格引入到Java中。</li>\n<li><strong>Date Time API</strong> − 加强对日期与时间的处理。</li>\n<li><strong>Optional 类</strong> − Optional 类已经成为 Java 8 类库的一部分，用来解决空指针异常。</li>\n<li><strong>Nashorn, JavaScript 引擎</strong> − Java 8提供了一个新的Nashorn javascript引擎，它允许我们在JVM上运行特定的javascript应用。</li>\n</ul>\n<h2 id=\"多线程\"><a href=\"#多线程\" class=\"headerlink\" title=\"多线程\"></a>多线程</h2><h3 id=\"JUC\"><a href=\"#JUC\" class=\"headerlink\" title=\"JUC\"></a>JUC</h3><p>JUC是java.util.concurrent包的简称，在Java5.0添加，目的就是为了更好的支持高并发任务。让开发者进行多线程编程时减少竞争条件和死锁的问题！</p>\n<h3 id=\"线程和进程\"><a href=\"#线程和进程\" class=\"headerlink\" title=\"线程和进程\"></a>线程和进程</h3><p>线程（thread),进程可进一步细化为线程，是一个&#x3D;&#x3D;程序内部的一条执行路径&#x3D;&#x3D;。每个线程，<strong>拥有自己独立的：栈、程序计数器。多个线程，共享同一个进程中的结构：方法区、堆。</strong></p>\n<p>进程（process)是程序的一次执行过程，或是正在运行的一个程序。是一个动态的过程：有它自身的产生、存在和消亡的过程。——生命周期</p>\n<p>一个Java应用程序,至少有三个线程：<strong>main()主线程，gc()垃圾回收线程，异常处理线程</strong>。当然如果发生异常，会影响主线程。</p>\n<h3 id=\"线程安全问题\"><a href=\"#线程安全问题\" class=\"headerlink\" title=\"线程安全问题\"></a>线程安全问题</h3><p>多个线程同时修改同一个变量；或者一个线程修改，一个线程读取，可能会出现 BUG</p>\n<p><strong>原因:</strong></p>\n<p>1.线程是一个 抢占式 执行的过程（具有随机性）<strong>。（是操作系统内核来实现的，程序员无法控制）</strong><br>2.多个线程修改同一个变量<br><strong>3.修改操作不是 原子的</strong>（可能会有多条指令，在执行过程中相互穿插，也就无法保证线程的安全）<br><strong>4.内存的可见性 ：</strong>一个读内存，一个写内存；写操作的线程进行修改的时候，读线程可能读取到的都是修改之前的值，也可能读取到的是修改之后的值，仍然存在不确定性，这也会带来线程不安全。</p>\n<h3 id=\"解决线程安全问题的办法：\"><a href=\"#解决线程安全问题的办法：\" class=\"headerlink\" title=\"解决线程安全问题的办法：\"></a>解决线程安全问题的办法：</h3><p> synchronized 与volatile关键字</p>\n<p>synchronized的功能是保证 操作的原子性，禁止指令重排序，确保内存访问的可见性。（即使用于多个线程写的操作，也适用于一读一写的操作）。</p>\n<p>volatile的功能就是禁止指令的重排序和确保内存访问的可见性。但是不能保证原子性。（适用于一个线程写，一个线程读的情况下）。</p>\n<h3 id=\"多线程程序的优点：\"><a href=\"#多线程程序的优点：\" class=\"headerlink\" title=\"多线程程序的优点：\"></a>多线程程序的优点：</h3><pre class=\"line-numbers language-txt\" data-language=\"txt\"><code class=\"language-txt\">1.提高应用程序的响应。对图形化界面更有意义，可增强用户体验。\n2.提高计算机系统CPU的利用率\n3.改善程序结构。将既长又复杂的进程分为多个线程，独立运行，利于理解和修改</code></pre>\n\n<p>创建多线程方式：4种</p>\n<p>解决线程安全问题：3种</p>\n<p>程序：一组指令的集合。即一段静态的代码，静态对象。 </p>\n<p>进程：一次程序的执行过程，或是正在运行的一个程序。是一个动态的过程，存在生命周期。</p>\n<p><strong>线程</strong>：进程可进一步细化为线程，<strong>是一个程序内的一条执行路径</strong>。作为调度和执行的单位，每个线程拥有独立的运行栈和程序计数器（pc）。</p>\n<p>并行：<strong>多个CPU同时执行多个任务</strong>。（多个人同时做不同的事）</p>\n<p>并发：<strong>一个CPU（采用时间片）同时执行多个任务</strong>。（秒杀、多个人做同一件事）</p>\n<h2 id=\"并发和并行\"><a href=\"#并发和并行\" class=\"headerlink\" title=\"并发和并行\"></a>并发和并行</h2><p>并发是指&#x3D;&#x3D;一个处理器同时处理多个任务&#x3D;&#x3D;。<br>并行是指多个处理器或者是多核的处理器同时处理多个不同的任务。 </p>\n<p>并发是逻辑上的同时发生（simultaneous），而并行是物理上的同时发生。 </p>\n<p>并行需要两个或两个以上的线程跑在不同的处理器上，并发可以跑在一个处理器上通过时间片进行切换。</p>\n<p>并发编程的目标是充分的利用处理器的每一个核，以达到最高的处理性能。 CPU多核,多个线程同时进行 ; 使用线程池操作</p>\n<h4 id=\"方式一：继承Thread\"><a href=\"#方式一：继承Thread\" class=\"headerlink\" title=\"方式一：继承Thread\"></a>方式一：继承Thread</h4><p>1.创建Thread子类\t</p>\n<p>2.重写run方法（将执行操作声明在方法体中）\t</p>\n<p>3.创建子类对象\t</p>\n<p>4.通过此对象调用<strong>start方法</strong>（<strong>启动当前线程</strong>，同时调用当前线程的run方法）</p>\n<h4 id=\"方式二：实现Runnable接口\"><a href=\"#方式二：实现Runnable接口\" class=\"headerlink\" title=\"方式二：实现Runnable接口\"></a>方式二：实现Runnable接口</h4><p>1.创建一个实现Runnable接口的类</p>\n<p>2.实现接口中的run（）方法</p>\n<p>3.创建实现类的对象</p>\n<p>4.将此对象传入Thread（）构造器</p>\n<p>5.将构造器创建的对象调start方法</p>\n<p>比较两种方式：优先选择实现接口的方式。方式一受限Java单继承；&#x3D;&#x3D;实现接口更适合处理多个线程共享数据的情况。&#x3D;&#x3D;</p>\n<p>共同点：Thread本身也实现了Runnable接口，都重写了run方法。</p>\n<h3 id=\"Thread常用方法：\"><a href=\"#Thread常用方法：\" class=\"headerlink\" title=\"Thread常用方法：\"></a>Thread常用方法：</h3><p>1.start（）：&#x3D;&#x3D;启动&#x3D;&#x3D;当前线程，同时&#x3D;&#x3D;调用&#x3D;&#x3D;当前线程的run方法</p>\n<p>2.currentThread（）：静态方法，返回当前执行的线程</p>\n<p>3.setName（）&#x2F;  getName（）：设置&#x2F;获取当前线程名字</p>\n<p>4.yield（）：释放当前CPU执行权</p>\n<p>5.join（）：在线程a中调线程b的join方法，a进入阻塞状态，直到b线程完全执行完结束阻塞。</p>\n<p>6.sleep（）：当前线程阻塞指定的毫秒数。</p>\n<p>7.isAlive（）：判断当前线程是否存活。</p>\n<p>线程的调度</p>\n<p>抢占式：高优先级的线程抢占CPU</p>\n<p>线程优先级：10&#x2F;1&#x2F;5</p>\n<p>setPriority&#x2F;getPriority\t设置&#x2F;获取优先级</p>\n<p>每个线程拥有独立的栈、程序计数器。</p>\n<p>多个线程，共享一个进程的方法区、堆。</p>\n<p>线程的生命周期：<strong>新建、就绪、运行、阻塞</strong>（临时状态，sleep()、join()、等待同步锁、wait()）、<strong>死亡</strong>。</p>\n<p>通过<strong>同步机制</strong>解决线程安全问题。局限：操作代码时，只能有一个线程参与，其他线程等待，效率较低。</p>\n<h3 id=\"一、同步代码块\"><a href=\"#一、同步代码块\" class=\"headerlink\" title=\"一、同步代码块\"></a>一、同步代码块</h3><pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">synchronized(同步监视器)&#123;\n    需要被同步的代码\n&#125;</code></pre>\n\n<p>同步监视器：俗称锁。<strong>任何一个类的对象，都可以充当锁。</strong>要求：<strong>多个线程必须共用同一把锁。</strong> </p>\n<p>实现Runnable时可用this当锁。</p>\n<p>继承Thread类时可使用：synchronized(类)</p>\n<h3 id=\"二、同步方法\"><a href=\"#二、同步方法\" class=\"headerlink\" title=\"二、同步方法\"></a>二、同步方法</h3><p>非静态的同步方法，同步监视器是this</p>\n<p>静态的同步方法，同步监视器的类本身</p>\n<p>死锁：所有线程处于阻塞状态</p>\n<p>Lock锁：实例化ReentrantLock</p>\n<p>synchronized与Lock都是用来解决线程安全问题。区别：synchronized执行完相应的同步代码后自动释放锁，Lock需要手动启动、结束同步。建议优先使用Lock。</p>\n<h3 id=\"线程的通信：\"><a href=\"#线程的通信：\" class=\"headerlink\" title=\"线程的通信：\"></a>线程的通信：</h3><p>wait（）一旦执行，当前线程进入阻塞，并释放同步监视器。</p>\n<p>notify（）一旦执行，当前线程唤醒被wait的线程。notifyAll（）唤醒所有被wait的线程。</p>\n<p>三者必须使用在<strong>同步代码块或同步方法</strong>中。这三个方法的调用者必须是同步代码块方法中的同步监视器。均声明在Object类中。</p>\n<h3 id=\"sleep（）与wait（）异同：\"><a href=\"#sleep（）与wait（）异同：\" class=\"headerlink\" title=\"sleep（）与wait（）异同：\"></a><strong>sleep（）与wait（）</strong>异同：</h3><p>一旦执行，当前线程均进入阻塞状态。</p>\n<p>声明<strong>位置</strong>不同，Thread类中声明sleep（）；wait在Object类中声明。</p>\n<p>调用要求不同：sleep任何需要的场景均可调用，wait只能在同步代码块和同步方法中。</p>\n<p>是否释放同步监视器：wait会<strong>释放锁</strong>。</p>\n<h3 id=\"新增线程创建方式：\"><a href=\"#新增线程创建方式：\" class=\"headerlink\" title=\"新增线程创建方式：\"></a>新增线程创建方式：</h3><h4 id=\"一、实现Callable接口；\"><a href=\"#一、实现Callable接口；\" class=\"headerlink\" title=\"一、实现Callable接口；\"></a>一、实现Callable接口；</h4><p>相比run方法，&#x3D;&#x3D;可以有返回值&#x3D;&#x3D;，方法可以&#x3D;&#x3D;抛异常&#x3D;&#x3D;，&#x3D;&#x3D;支持泛型&#x3D;&#x3D;的返回值，需借助FutureTask类。</p>\n<h4 id=\"二、使用线程池：\"><a href=\"#二、使用线程池：\" class=\"headerlink\" title=\"二、使用线程池：\"></a>二、使用线程池：</h4><p>提高响应速度，降低资源消耗、便于线程管理。 创建池，调方法传对象，关闭池。</p>\n<p>实现Callable接口步骤：</p>\n<p>1.创建一个实现Callable接口的实现类</p>\n<p>2.实现call方法，将此线程需要执行的操作声明在call（）中。</p>\n<p>3.创建Callable接口实现类的对象</p>\n<p>4.将接口实现类的对象作为参数传递到FutureTask构造器中，创建FutureTask的对象</p>\n<p>5.将FutureTask的对象作为参数传递到Thread类的构造器中，创建Thread对象，调用start方法。</p>\n<p>6.获取Callablecall方法的返回值</p>\n<p><strong>Callable比实现Runnable接口更强大：1.call方法可以有返回值；2.call方法可抛异常；3.支持泛型。</strong></p>\n<h2 id=\"线程池\"><a href=\"#线程池\" class=\"headerlink\" title=\"线程池\"></a>线程池</h2><p>线程池（thread pool）：一种线程使用模式。线程过多会带来调度开销，进而影响缓存局部性和整体性能。而线程池&#x3D;&#x3D;维护着多个线程，对线程统一管理&#x3D;&#x3D;。</p>\n<p>线程池就是存放线程的池子，池子里&#x3D;&#x3D;存放了很多可以复用的线程&#x3D;&#x3D;。</p>\n<p>创建线程和销毁线程的花销是比较大的（手动new Thread 类），创建和消耗线程的时间有可能比处理业务的时间还要长。这样频繁的创建线程和销毁线程是比较消耗资源的。（我们可以把创建和销毁的线程的过程去掉）。</p>\n<p>线程池（ThreadPool）是一种基于池化思想管理和使用线程的机制。它是将多个线程预先存储在一个“池子”内，当有任务出现时可以避免重新创建和销毁线程所带来性能开销，只需要从“池子”内取出相应的线程执行对应的任务即可。</p>\n<p>线程池的创建方法可分为 2 类：</p>\n<ul>\n<li>一类是通过 <code>ThreadPoolExecutor</code> 创建的线程池；</li>\n<li>另一个类是通过 <code>Executors</code> 创建的线程池。</li>\n</ul>\n<p>一种线程使用模式。线程过多会带来调度开销，进而影响缓存局部性和整体性能。而线程池维护着多个线程，等待着监督管理者分配可并发执行的任务。这避免了在处理短时间任务时创建与销毁线程的代价。线程池不仅能够保证内核的充分利用，还能防止过分调度。</p>\n<p><strong>线程池的好处:</strong></p>\n<ol>\n<li>提高效率，创建好一定数量的线程放在池中，等需要使用的时候就从池中拿一个，这要比需要的时候创建一个线程对象要快的多。</li>\n<li>减少了创建和销毁线程的次数，每个工作线程都可以被重复利用，可执行多个任务。</li>\n<li>提升系统响应速度，假如创建线程用的时间为T1，执行任务用的时间为T2,销毁线程用的时间为T3，那么使用线程池就免去了T1和T3的时间；</li>\n</ol>\n<h3 id=\"创建线程池的三大方法：\"><a href=\"#创建线程池的三大方法：\" class=\"headerlink\" title=\"创建线程池的三大方法：\"></a>创建线程池的三大方法：</h3><pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">ExecutorService service &#x3D; Executors.newSingleThreadExecutor();&#x2F;&#x2F;单个线程\n &#x2F;*public static ExecutorService newSingleThreadExecutor() &#123;\n       return new FinalizableDelegatedExecutorService\n           (new ThreadPoolExecutor(1, 1,\n                                   0L, TimeUnit.MILLISECONDS,\n                                   new LinkedBlockingQueue&lt;Runnable&gt;()));\n   &#125;*&#x2F;\n ExecutorService service &#x3D; Executors.newFixedThreadPool(5);&#x2F;&#x2F;创建一个固定的线程池的大小\n &#x2F;* public static ExecutorService newFixedThreadPool(int nThreads) &#123;\n       return new ThreadPoolExecutor(nThreads, nThreads,\n                                     0L, TimeUnit.MILLISECONDS,\n                                     new LinkedBlockingQueue&lt;Runnable&gt;());\n   &#125;*&#x2F;\n ExecutorService service &#x3D; Executors.newCachedThreadPool();&#x2F;&#x2F;缓存线程池，可伸缩的\n &#x2F;*public static ExecutorService newCachedThreadPool() &#123;\n       return new ThreadPoolExecutor(0, Integer.MAX_VALUE,\n                                     60L, TimeUnit.SECONDS,\n                                     new SynchronousQueue&lt;Runnable&gt;());\n   &#125;*&#x2F;</code></pre>\n\n<p>在上面三大方法中，本质所有线程池最终都调用的ThreadPoolExecutor来创建线程池的，而ThreadPoolExecutor（）方法中有七大参数！</p>\n<h3 id=\"七大参数：\"><a href=\"#七大参数：\" class=\"headerlink\" title=\"七大参数：\"></a>七大参数：</h3><pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public ThreadPoolExecutor(int corePoolSize,&#x2F;&#x2F;核心线程池大小\n                             int maximumPoolSize,&#x2F;&#x2F;最大的线程池大小\n                             long keepAliveTime,&#x2F;&#x2F;存活时间\n                             TimeUnit unit,&#x2F;&#x2F;存活时间的时间单位\n                             BlockingQueue&lt;Runnable&gt; workQueue&#x2F;&#x2F;阻塞队列) \n                             ThreadFactory threadFactory,&#x2F;&#x2F;线程工厂,创建线程的,一般不动\n                             RejectedExecutionHandler handler&#x2F;&#x2F;拒绝策略) &#123;\n       if (corePoolSize &lt; 0 ||\n           maximumPoolSize &lt;&#x3D; 0 ||\n           maximumPoolSize &lt; corePoolSize ||\n           keepAliveTime &lt; 0)\n           throw new IllegalArgumentException();\n       if (workQueue &#x3D;&#x3D; null || threadFactory &#x3D;&#x3D; null || handler &#x3D;&#x3D; null)\n           throw new NullPointerException();\n       this.acc &#x3D; System.getSecurityManager() &#x3D;&#x3D; null ?\n               null :\n               AccessController.getContext();\n       this.corePoolSize &#x3D; corePoolSize;\n       this.maximumPoolSize &#x3D; maximumPoolSize;\n       this.workQueue &#x3D; workQueue;\n       this.keepAliveTime &#x3D; unit.toNanos(keepAliveTime);\n       this.threadFactory &#x3D; threadFactory;\n       this.handler &#x3D; handler;\n   &#125;</code></pre>\n\n<h2 id=\"OOM\"><a href=\"#OOM\" class=\"headerlink\" title=\"OOM\"></a>OOM</h2><p>内存溢出(Out Of Memory，简称OOM)是指应用系统中存在无法回收的内存或使用的内存过多，最终使得程序运行要用到的内存大于能提供的最大内存。</p>\n<p><strong>原因</strong></p>\n<pre class=\"line-numbers language-txt\" data-language=\"txt\"><code class=\"language-txt\">2.1、内存泄漏\n由于长期保持某些资源的引用，垃圾回收器无法回收它，从而使该资源不能够及时释放，也称为内存泄露。因而尽量不要将所有引用都使用为强引用，可以在合适的地方使用弱引用和软引用。\n2.2、超大对象\n保存多个耗用内存过大或当加载单个超大的对象时，该对象的大小超过了当前剩余的可用内存空间。比如查询数据库中的数据，一次查询过多，直接导致内存溢出了。因此查询数据库如果数据过多尽量使用分页查询。\n2.3、其他各种原因\n比如是否存在死循环，大循环重复产生对象，是否有集合对象使用完之后，依然被引用着，导致无法清除，是否使用了不恰当的数据结构，导致占用空间过大等等。</code></pre>\n\n<p><strong>解决方案</strong></p>\n<pre class=\"line-numbers language-txt\" data-language=\"txt\"><code class=\"language-txt\">3.1、修改JVM启动参数，直接增加内存\nJVM默认可以使用的内存为64M，Tomcat默认可以使用的内存为128MB，对于稍复杂一点的系统就会不够用。在某项目中，就因为启动参数使用的默认值，经常报“Out Of Memory”错误。因此，-Xms，-Xmx（堆内存的最小大小和最大大小值）参数一定不要忘记加。\n\n3.2、找出可能发生内存溢出的位置，并解决\n检查代码中是否有死循环或递归调用。\n检查是否有大循环重复产生新对象实体。\n检查对数据库查询中，是否有一次获得全部数据的查询。\n检查List、Map等集合对象是否有使用完后，未清除的问题。\n使用内存查看工具动态查看内存使用情况。</code></pre>\n\n<h2 id=\"QA\"><a href=\"#QA\" class=\"headerlink\" title=\"QA\"></a>QA</h2><p>（QUALITY ASSURANCE）中文意思是质量保证</p>\n<h2 id=\"DevOps\"><a href=\"#DevOps\" class=\"headerlink\" title=\"DevOps\"></a>DevOps</h2><p>（Development和Operations的组合词）是一组过程、方法与系统的统称，用于促进开发（应用程序&#x2F;软件工程）、技术运营和质量保障（QA）部门之间的沟通、协作与整合。</p>\n<h2 id=\"简历\"><a href=\"#简历\" class=\"headerlink\" title=\"简历\"></a>简历</h2><p>专业名词要写对，区分好大小写，比如Java不要写成java或者JAVA、MySQL不要写成mysql等，注重细节，力争做好每一步。</p>\n<p>不要写一些跟技术无关的东西，比如”PS&#x2F;PR”、”驾照”、”会用OFFICE”、””会重装系统”等等</p>\n<p>最好不要写一些使用 xx 的经验，比如接入微信 &#x2F;支付宝支付、接入友盟分享SDK等等，这种基本对着文档撸就好了，没必要写上去。除非特别有技术含量的。</p>\n<h2 id=\"GoF\"><a href=\"#GoF\" class=\"headerlink\" title=\"GoF\"></a>GoF</h2><p>GoF是设计模式的经典名著Design Patterns: Elements of Reusable Object-Oriented Software（中译本名为《设计模式——可复用面向对象软件的基础》）的四位作者，他们分为是：Elich Gamma、Richard Helm、Ralph Johnson、以及John Vlissides。这四个人常被称为Gang of Four， 即四人组，简称GoF。 </p>\n<h2 id=\"代码管理、分支策略\"><a href=\"#代码管理、分支策略\" class=\"headerlink\" title=\"代码管理、分支策略\"></a>代码管理、分支策略</h2><p>代码管理用的是git,分支管理使用的是&#x3D;&#x3D;稳定主干策略&#x3D;&#x3D;</p>\n<p>使用主干作为稳定版的发布，bug的修改和新功能的增加，全部在分支上进行，不同的修改或新功能开发以分支隔离，分支上的开发和测试完毕以后才合并到主干。</p>\n<h3 id=\"代码共享\"><a href=\"#代码共享\" class=\"headerlink\" title=\"代码共享\"></a>代码共享</h3><pre class=\"line-numbers language-latex\" data-language=\"latex\"><code class=\"language-latex\">1.从远程仓库中克隆代码到本地仓库\n2.从本地仓库中checkout代码然后进行代码修改\n3.在提交前先将代码提交到暂存区\n4.提交到本地仓库，本地仓库中保存修改的各合历史版本\n5.修改完成后，需要和团队成员共享代码时，将代码push到远程仓库</code></pre>\n\n<h2 id=\"技术架构\"><a href=\"#技术架构\" class=\"headerlink\" title=\"技术架构\"></a>技术架构</h2><p>视图层、控制层、业务逻辑层、持久层、整合层（Spring）</p>\n<h2 id=\"国产数据库\"><a href=\"#国产数据库\" class=\"headerlink\" title=\"国产数据库\"></a>国产数据库</h2><p>达梦、TiDB、OceanBase、PolarDB</p>\n","feature":true,"text":"Java笔记...","link":"","photos":[],"count_time":{"symbolsCount":"49k","symbolsTime":"44 mins."},"categories":[{"name":"编程","slug":"编程","count":16,"path":"api/categories/编程.json"}],"tags":[{"name":"Java","slug":"Java","count":9,"path":"api/tags/Java.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#JAVASE\"><span class=\"toc-text\">JAVASE</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1\"><span class=\"toc-text\">面向对象</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E2%80%9C-x3D-x3D-%E2%80%9D%E5%92%8Cequals\"><span class=\"toc-text\">“&#x3D;&#x3D;”和equals</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#MYSQL\"><span class=\"toc-text\">MYSQL</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#char%E5%92%8Cvarchar%E5%8C%BA%E5%88%AB\"><span class=\"toc-text\">char和varchar区别</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#char%E6%AF%94varchar%E6%95%88%E7%8E%87%E6%9B%B4%E5%BF%AB%E7%9A%84%E5%8E%9F%E5%9B%A0\"><span class=\"toc-text\">char比varchar效率更快的原因</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#SQL%E8%AF%AD%E5%8F%A5%E4%BC%98%E5%8C%96\"><span class=\"toc-text\">SQL语句优化</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#MySQL-%E7%B4%A2%E5%BC%95\"><span class=\"toc-text\">MySQL 索引</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E7%B4%A2%E5%BC%95%E5%A4%B1%E6%95%88\"><span class=\"toc-text\">索引失效</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%9C%80%E5%B7%A6%E5%8C%B9%E9%85%8D%E5%8E%9F%E5%88%99\"><span class=\"toc-text\">最左匹配原则</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E8%84%8F%E8%AF%BB%E3%80%81%E5%B9%BB%E8%AF%BB%E3%80%81%E4%B8%8D%E5%8F%AF%E9%87%8D%E5%A4%8D%E8%AF%BB\"><span class=\"toc-text\">脏读、幻读、不可重复读</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#SQL%E6%B3%A8%E5%85%A5\"><span class=\"toc-text\">SQL注入</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#MySQL%E6%AD%BB%E9%94%81\"><span class=\"toc-text\">MySQL死锁</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#JWT\"><span class=\"toc-text\">JWT</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#jwt%E8%AE%A4%E8%AF%81%E8%BF%87%E7%A8%8B\"><span class=\"toc-text\">jwt认证过程</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%BC%9A%E8%AF%9D%E8%B7%9F%E8%B8%AA\"><span class=\"toc-text\">会话跟踪</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#URI%E4%B8%8EURL\"><span class=\"toc-text\">URI与URL</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%B8%BB%E9%94%AE%E7%AD%96%E7%95%A5\"><span class=\"toc-text\">主键策略</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#MP%E5%AE%9E%E7%8E%B0%E4%B9%90%E8%A7%82%E9%94%81\"><span class=\"toc-text\">MP实现乐观锁</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%B9%90%E8%A7%82%E9%94%81%E6%8F%92%E4%BB%B6\"><span class=\"toc-text\">乐观锁插件</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#MyBatis-Plus%E5%AE%9E%E7%8E%B0%E5%88%86%E9%A1%B5\"><span class=\"toc-text\">MyBatis Plus实现分页</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E9%80%BB%E8%BE%91%E5%88%A0%E9%99%A4\"><span class=\"toc-text\">逻辑删除</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#QueryWrapper%E7%9A%84%E6%96%B9%E6%B3%95\"><span class=\"toc-text\">QueryWrapper的方法</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E9%85%8D%E7%BD%AE%E7%B1%BB\"><span class=\"toc-text\">配置类</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#RestController\"><span class=\"toc-text\">@RestController</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#RequestBody\"><span class=\"toc-text\">@RequestBody</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#http-method%E8%AF%B7%E6%B1%82%E6%96%B9%E5%BC%8F\"><span class=\"toc-text\">http method请求方式</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#PathVariable\"><span class=\"toc-text\">@PathVariable</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%9D%A1%E4%BB%B6%E5%88%86%E9%A1%B5%E6%9F%A5%E8%AF%A2\"><span class=\"toc-text\">条件分页查询</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%B0%81%E8%A3%85%E7%BB%9F%E4%B8%80%E8%BF%94%E5%9B%9E%E7%BB%93%E6%9E%9C\"><span class=\"toc-text\">封装统一返回结果</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#GET%E5%92%8CPOST\"><span class=\"toc-text\">GET和POST</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E7%8A%B6%E6%80%81%E7%A0%81\"><span class=\"toc-text\">状态码</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E7%BB%9F%E4%B8%80%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E7%B1%BB\"><span class=\"toc-text\">统一异常处理类</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Lombok\"><span class=\"toc-text\">Lombok</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Java%E6%98%AF%E5%80%BC%E4%BC%A0%E9%80%92%E8%BF%98%E6%98%AF%E5%BC%95%E7%94%A8%E4%BC%A0%E9%80%92\"><span class=\"toc-text\">Java是值传递还是引用传递</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%80%BC%E4%BC%A0%E9%80%92%E6%9C%BA%E5%88%B6\"><span class=\"toc-text\">值传递机制</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E8%B7%A8%E5%9F%9F\"><span class=\"toc-text\">跨域</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%BD%BF%E7%94%A8%E9%98%BF%E9%87%8C%E4%BA%91OSS%E6%9C%8D%E5%8A%A1%EF%BC%8C%E5%AE%9E%E7%8E%B0%E5%AF%B9%E8%AF%BE%E7%A8%8B%E5%B0%81%E9%9D%A2%E4%BB%A5%E5%8F%8A%E8%AE%B2%E5%B8%88%E5%A4%B4%E5%83%8F%E7%9A%84%E5%82%A8%E5%AD%98\"><span class=\"toc-text\">使用阿里云OSS服务，实现对课程封面以及讲师头像的储存</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E7%BD%91%E6%98%93%E4%BA%91%E3%80%81%E9%98%BF%E9%87%8C%E4%BA%91%E3%80%81%E8%85%BE%E8%AE%AF%E4%BA%91%E3%80%81%E4%B8%83%E7%89%9B%E4%BA%91\"><span class=\"toc-text\">网易云、阿里云、腾讯云、七牛云</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#CDN\"><span class=\"toc-text\">CDN</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Spring%E4%B8%AD%E7%9A%84%E6%B3%A8%E8%A7%A3\"><span class=\"toc-text\">Spring中的注解</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Component%E5%92%8C-Bean%E7%9A%84%E5%8C%BA%E5%88%AB\"><span class=\"toc-text\">@Component和@Bean的区别</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Springboot%E8%87%AA%E5%8A%A8%E8%A3%85%E9%85%8D%E7%9A%84%E5%8E%9F%E7%90%86\"><span class=\"toc-text\">Springboot自动装配的原理</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Springboot%E5%B8%B8%E7%94%A8%E6%B3%A8%E8%A7%A3\"><span class=\"toc-text\">Springboot常用注解</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Springboot%E9%A1%B9%E7%9B%AE%E5%9B%9B%E7%A7%8D%E5%90%AF%E5%8A%A8%E6%96%B9%E5%BC%8F\"><span class=\"toc-text\">Springboot项目四种启动方式</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Spring-Boot-%E9%A1%B9%E7%9B%AE%E7%89%B9%E7%82%B9\"><span class=\"toc-text\">Spring Boot 项目特点</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Spring-MVC%E5%B8%B8%E7%94%A8%E6%B3%A8%E8%A7%A3\"><span class=\"toc-text\">Spring MVC常用注解</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%BE%AE%E6%9C%8D%E5%8A%A1%E4%BA%94%E5%A4%A7%E7%BB%84%E4%BB%B6\"><span class=\"toc-text\">微服务五大组件</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Conditional\"><span class=\"toc-text\">@Conditional</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Spring%E5%88%9D%E5%A7%8B%E5%8C%96bean%E6%9C%89%E4%B8%A4%E7%A7%8D%E6%96%B9%E5%BC%8F\"><span class=\"toc-text\">Spring初始化bean有两种方式</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Bean%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F\"><span class=\"toc-text\">Bean的生命周期</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%8E%A5%E5%8F%A3\"><span class=\"toc-text\">接口</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%B3%9B%E5%9E%8B\"><span class=\"toc-text\">泛型</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%B3%9B%E5%9E%8B%E6%93%A6%E9%99%A4\"><span class=\"toc-text\">泛型擦除</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#spring%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E5%8A%A0%E8%BD%BD%E9%A1%BA%E5%BA%8F\"><span class=\"toc-text\">spring配置文件加载顺序</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#yml%E3%80%81properties\"><span class=\"toc-text\">yml、properties</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#ArrayList%E4%B8%8ELinkedList\"><span class=\"toc-text\">ArrayList与LinkedList</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#ArrayList%E7%9A%84%E6%89%A9%E5%AE%B9%E6%9C%BA%E5%88%B6\"><span class=\"toc-text\">ArrayList的扩容机制</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#ArrayList%E6%80%8E%E4%B9%88%E5%AE%9E%E7%8E%B0%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8\"><span class=\"toc-text\">ArrayList怎么实现线程安全</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Arrays-asList\"><span class=\"toc-text\">Arrays.asList()</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%8E%A5%E5%8F%A3%E5%92%8C%E6%8A%BD%E8%B1%A1%E7%B1%BB%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB\"><span class=\"toc-text\">接口和抽象类有什么区别</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#HashMap\"><span class=\"toc-text\">HashMap</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#HashMap-%E7%9A%84-put-%E6%96%B9%E6%B3%95%E6%B7%BB%E5%8A%A0%E5%85%83%E7%B4%A0%E7%9A%84%E8%BF%87%E7%A8%8B%EF%BC%9A\"><span class=\"toc-text\">HashMap 的 put() 方法添加元素的过程：</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#HashMap%E6%89%A9%E5%AE%B9%E7%9A%84%E8%BF%87%E7%A8%8B%EF%BC%9A\"><span class=\"toc-text\">HashMap扩容的过程：</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#HashMap%E9%93%BE%E8%A1%A8%E8%BD%AC%E6%8D%A2%E6%88%90%E7%BA%A2%E9%BB%91%E6%A0%91%EF%BC%9A\"><span class=\"toc-text\">HashMap链表转换成红黑树：</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#ConcurrentHashMap\"><span class=\"toc-text\">ConcurrentHashMap</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#HashMap%E5%92%8CHashtable%E7%9A%84%E5%8C%BA%E5%88%AB\"><span class=\"toc-text\">HashMap和Hashtable的区别</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E5%92%8C%E5%93%88%E5%B8%8C%E7%A0%81\"><span class=\"toc-text\">哈希函数和哈希码</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%93%88%E5%B8%8C%E7%A2%B0%E6%92%9E\"><span class=\"toc-text\">哈希碰撞</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%93%88%E5%B8%8C%E5%86%B2%E7%AA%81%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%EF%BC%9A\"><span class=\"toc-text\">哈希冲突解决方案：</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Iterator\"><span class=\"toc-text\">Iterator</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%B9%90%E8%A7%82%E9%94%81%E5%92%8C%E6%82%B2%E8%A7%82%E9%94%81\"><span class=\"toc-text\">乐观锁和悲观锁</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#CAS\"><span class=\"toc-text\">CAS</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#ABA\"><span class=\"toc-text\">ABA</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BA%8B%E5%8A%A1\"><span class=\"toc-text\">数据库事务</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Spring%E6%B3%A8%E8%A7%A3%E4%BA%8B%E5%8A%A1%E5%A4%B1%E6%95%88%E5%8E%9F%E5%9B%A0\"><span class=\"toc-text\">Spring注解事务失效原因</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#MySQL%E7%9A%84%E5%9B%9B%E7%A7%8D%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB\"><span class=\"toc-text\">MySQL的四种隔离级别</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%BA%8B%E5%8A%A1%E4%BC%A0%E6%92%AD%E8%A1%8C%E4%B8%BA\"><span class=\"toc-text\">事务传播行为</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Autowired%E5%92%8C-Resource%E5%8C%BA%E5%88%AB%EF%BC%9A\"><span class=\"toc-text\">@Autowired和@Resource区别：</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#maven\"><span class=\"toc-text\">maven</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#maven%E6%94%AF%E6%8C%81%E7%9A%84%E6%9E%84%E5%BB%BA%E5%8C%85%E6%8B%AC%E6%9C%89%EF%BC%9A\"><span class=\"toc-text\">maven支持的构建包括有：</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#maven%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5%EF%BC%9A\"><span class=\"toc-text\">maven核心概念：</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#SpringMVC%E7%9A%84%E4%B9%9D%E5%A4%A7%E7%BB%84%E4%BB%B6\"><span class=\"toc-text\">SpringMVC的九大组件</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E8%BF%87%E6%BB%A4%E5%99%A8-Filter-%E5%92%8C-%E6%8B%A6%E6%88%AA%E5%99%A8-Interceptor\"><span class=\"toc-text\">过滤器 (Filter) 和 拦截器 (Interceptor)</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Comparator%E5%92%8CComparable%E7%9A%84%E5%8C%BA%E5%88%AB\"><span class=\"toc-text\">Comparator和Comparable的区别</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%97%A0%E5%BA%8F%E6%80%A7%E5%92%8C%E4%B8%8D%E5%8F%AF%E9%87%8D%E5%A4%8D%E6%80%A7%E7%9A%84%E5%90%AB%E4%B9%89%E6%98%AF%E4%BB%80%E4%B9%88\"><span class=\"toc-text\">无序性和不可重复性的含义是什么</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E2%BD%90%E8%BE%83-HashSet%E3%80%81LinkedHashSet-%E5%92%8C-TreeSet-%E4%B8%89%E8%80%85%E7%9A%84%E5%BC%82%E5%90%8C\"><span class=\"toc-text\">⽐较 HashSet、LinkedHashSet 和 TreeSet 三者的异同</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#String%E3%80%81StringBuffer%E3%80%81StringBuilder%E7%9A%84%E5%8C%BA%E5%88%AB\"><span class=\"toc-text\">String、StringBuffer、StringBuilder的区别</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Token\"><span class=\"toc-text\">Token</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%B7%B1%E6%8B%B7%E8%B4%9D%E4%B8%8E%E6%B5%85%E6%8B%B7%E8%B4%9D%E7%9A%84%E5%8C%BA%E5%88%AB\"><span class=\"toc-text\">深拷贝与浅拷贝的区别</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E9%9B%B6%E6%8B%B7%E8%B4%9D\"><span class=\"toc-text\">零拷贝</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F\"><span class=\"toc-text\">单例模式</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%87%92%E6%B1%89%E5%BC%8F%E5%92%8C%E9%A5%BF%E6%B1%89%E5%BC%8F\"><span class=\"toc-text\">懒汉式和饿汉式</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%87%92%E6%B1%89%E5%BC%8F%E5%92%8C%E9%A5%BF%E6%B1%89%E5%BC%8F%E5%8C%BA%E5%88%AB%EF%BC%9A\"><span class=\"toc-text\">懒汉式和饿汉式区别：</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F\"><span class=\"toc-text\">代理模式</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E9%9D%99%E6%80%81%E4%BB%A3%E7%90%86\"><span class=\"toc-text\">静态代理</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86\"><span class=\"toc-text\">动态代理</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%BA%8F%E5%88%97%E5%8C%96%E5%92%8C%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96\"><span class=\"toc-text\">序列化和反序列化</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F\"><span class=\"toc-text\">冒泡排序</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F%E7%9A%84%E5%8E%9F%E7%90%86%EF%BC%9A\"><span class=\"toc-text\">冒泡排序的原理：</span></a></li></ol></li></ol></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#UTF-8%E3%80%81UTF-16-%E5%92%8C-UTF-32\"><span class=\"toc-text\">UTF-8、UTF-16 和 UTF-32</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Unicode%E3%80%81ISO-10646%E3%80%81UTF-8%E3%80%81GB-2312%E3%80%81GBK%E7%9A%84%E5%8C%BA%E5%88%AB\"><span class=\"toc-text\">Unicode、ISO 10646、UTF-8、GB-2312、GBK的区别</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#static%E9%9D%99%E6%80%81%E4%BB%A3%E7%A0%81%E5%9D%97%E3%80%81%E5%AE%9E%E4%BE%8B%E4%BB%A3%E7%A0%81%E5%9D%97\"><span class=\"toc-text\">static静态代码块、实例代码块</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99-7%E5%A4%A7%E5%8E%9F%E5%88%99\"><span class=\"toc-text\">面向对象的设计原则(7大原则)</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E8%BF%9C%E7%A8%8B%E8%B0%83%E7%94%A8%E6%8A%80%E6%9C%AF\"><span class=\"toc-text\">远程调用技术</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Java8-%E6%96%B0%E7%89%B9%E6%80%A7\"><span class=\"toc-text\">Java8 新特性</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%A4%9A%E7%BA%BF%E7%A8%8B\"><span class=\"toc-text\">多线程</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#JUC\"><span class=\"toc-text\">JUC</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E7%BA%BF%E7%A8%8B%E5%92%8C%E8%BF%9B%E7%A8%8B\"><span class=\"toc-text\">线程和进程</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98\"><span class=\"toc-text\">线程安全问题</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E8%A7%A3%E5%86%B3%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98%E7%9A%84%E5%8A%9E%E6%B3%95%EF%BC%9A\"><span class=\"toc-text\">解决线程安全问题的办法：</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%A8%8B%E5%BA%8F%E7%9A%84%E4%BC%98%E7%82%B9%EF%BC%9A\"><span class=\"toc-text\">多线程程序的优点：</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%B9%B6%E5%8F%91%E5%92%8C%E5%B9%B6%E8%A1%8C\"><span class=\"toc-text\">并发和并行</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E6%96%B9%E5%BC%8F%E4%B8%80%EF%BC%9A%E7%BB%A7%E6%89%BFThread\"><span class=\"toc-text\">方式一：继承Thread</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E6%96%B9%E5%BC%8F%E4%BA%8C%EF%BC%9A%E5%AE%9E%E7%8E%B0Runnable%E6%8E%A5%E5%8F%A3\"><span class=\"toc-text\">方式二：实现Runnable接口</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Thread%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95%EF%BC%9A\"><span class=\"toc-text\">Thread常用方法：</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%B8%80%E3%80%81%E5%90%8C%E6%AD%A5%E4%BB%A3%E7%A0%81%E5%9D%97\"><span class=\"toc-text\">一、同步代码块</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%BA%8C%E3%80%81%E5%90%8C%E6%AD%A5%E6%96%B9%E6%B3%95\"><span class=\"toc-text\">二、同步方法</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E7%BA%BF%E7%A8%8B%E7%9A%84%E9%80%9A%E4%BF%A1%EF%BC%9A\"><span class=\"toc-text\">线程的通信：</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#sleep%EF%BC%88%EF%BC%89%E4%B8%8Ewait%EF%BC%88%EF%BC%89%E5%BC%82%E5%90%8C%EF%BC%9A\"><span class=\"toc-text\">sleep（）与wait（）异同：</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%96%B0%E5%A2%9E%E7%BA%BF%E7%A8%8B%E5%88%9B%E5%BB%BA%E6%96%B9%E5%BC%8F%EF%BC%9A\"><span class=\"toc-text\">新增线程创建方式：</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E4%B8%80%E3%80%81%E5%AE%9E%E7%8E%B0Callable%E6%8E%A5%E5%8F%A3%EF%BC%9B\"><span class=\"toc-text\">一、实现Callable接口；</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E4%BA%8C%E3%80%81%E4%BD%BF%E7%94%A8%E7%BA%BF%E7%A8%8B%E6%B1%A0%EF%BC%9A\"><span class=\"toc-text\">二、使用线程池：</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E7%BA%BF%E7%A8%8B%E6%B1%A0\"><span class=\"toc-text\">线程池</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%88%9B%E5%BB%BA%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E4%B8%89%E5%A4%A7%E6%96%B9%E6%B3%95%EF%BC%9A\"><span class=\"toc-text\">创建线程池的三大方法：</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%B8%83%E5%A4%A7%E5%8F%82%E6%95%B0%EF%BC%9A\"><span class=\"toc-text\">七大参数：</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#OOM\"><span class=\"toc-text\">OOM</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#QA\"><span class=\"toc-text\">QA</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#DevOps\"><span class=\"toc-text\">DevOps</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E7%AE%80%E5%8E%86\"><span class=\"toc-text\">简历</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#GoF\"><span class=\"toc-text\">GoF</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%BB%A3%E7%A0%81%E7%AE%A1%E7%90%86%E3%80%81%E5%88%86%E6%94%AF%E7%AD%96%E7%95%A5\"><span class=\"toc-text\">代码管理、分支策略</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%BB%A3%E7%A0%81%E5%85%B1%E4%BA%AB\"><span class=\"toc-text\">代码共享</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%8A%80%E6%9C%AF%E6%9E%B6%E6%9E%84\"><span class=\"toc-text\">技术架构</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%9B%BD%E4%BA%A7%E6%95%B0%E6%8D%AE%E5%BA%93\"><span class=\"toc-text\">国产数据库</span></a></li></ol>","author":{"name":"Dxc","slug":"blog-author","avatar":"/images/avatar.png","link":"/","description":"Free will is not free. <br /> @ <b>公众号：精准拔草</b>","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"MyBatis里的#{}与${}","uid":"a913954b5ef24db41b6d947f05c6c6ca","slug":"MyBatis","date":"2021-08-19T14:09:53.000Z","updated":"2021-08-19T14:09:53.000Z","comments":true,"path":"api/articles/MyBatis.json","keywords":null,"cover":"/images/mybatis.jpg","text":"MyBatis里的占位符...","link":"","photos":[],"count_time":{"symbolsCount":"3.2k","symbolsTime":"3 mins."},"categories":[{"name":"编程","slug":"编程","count":16,"path":"api/categories/编程.json"}],"tags":[{"name":"MyBatis","slug":"MyBatis","count":1,"path":"api/tags/MyBatis.json"}],"author":{"name":"Dxc","slug":"blog-author","avatar":"/images/avatar.png","link":"/","description":"Free will is not free. <br /> @ <b>公众号：精准拔草</b>","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},"next_post":{"title":"GitHub使用","uid":"2572af26096eeface1afd9d3b84a91f5","slug":"GitHub怎么用","date":"2021-05-28T14:09:53.000Z","updated":"2021-05-28T14:09:53.000Z","comments":true,"path":"api/articles/GitHub怎么用.json","keywords":null,"cover":"/images/log.jpg","text":"GitHub使用...","link":"","photos":[],"count_time":{"symbolsCount":"2.2k","symbolsTime":"2 mins."},"categories":[{"name":"编程","slug":"编程","count":16,"path":"api/categories/编程.json"}],"tags":[{"name":"Java","slug":"Java","count":9,"path":"api/tags/Java.json"}],"author":{"name":"Dxc","slug":"blog-author","avatar":"/images/avatar.png","link":"/","description":"Free will is not free. <br /> @ <b>公众号：精准拔草</b>","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"feature":true}}