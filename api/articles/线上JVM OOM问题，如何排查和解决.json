{"title":"线上JVM OOM问题排查、解决","uid":"d5fb0aaa99438763a2290106469c53fe","slug":"线上JVM OOM问题，如何排查和解决","date":"2024-09-13T14:09:53.000Z","updated":"2024-09-13T14:09:53.000Z","comments":true,"path":"api/articles/线上JVM OOM问题，如何排查和解决.json","keywords":null,"cover":"/images/log.jpg","content":"<h1 id=\"线上JVM-OOM问题，如何排查和解决\"><a href=\"#线上JVM-OOM问题，如何排查和解决\" class=\"headerlink\" title=\"线上JVM OOM问题，如何排查和解决\"></a><strong>线上JVM OOM问题，如何排查和解决</strong></h1><h2 id=\"技术文章\"><a href=\"#技术文章\" class=\"headerlink\" title=\"技术文章\"></a>技术文章</h2><p><strong>一、JVM OOM 到底是什么？</strong></p>\n<p>简单来说，JVM OOM 就是 Java 虚拟机的内存用完了，而且垃圾回收器（GC）也无能为力，没办法再为新对象分配内存，于是抛出了错误。这就好比你开着一辆车，油箱里的油已经耗尽，但你还想继续加速，结果只能是熄火。</p>\n<p><strong>二、OOM 为啥会发生？</strong></p>\n<p>OOM 的原因多种多样，但归根结底就两个字——“不够用”。具体来说，有这么几种常见情况：</p>\n<ol>\n<li><strong>内存分配不足</strong>：JVM 初始化时，堆内存、永久代（或元空间）等区域分配得太小，根本不够业务跑。比如，你的应用要处理海量数据，但堆内存只给了 128MB，这不就是“杯水车薪”嘛。</li>\n<li><strong>大对象申请</strong>：一次性申请的内存太大，超出了 JVM 的承受范围。比如，你试图一次性加载一个几 GB 的文件到内存中，JVM 根本就装不下。</li>\n<li><strong>内存泄漏</strong>：程序中某些地方申请了内存，但因为代码逻辑错误，这些内存永远不会被释放，就像一个无底洞，不断吞噬着 JVM 的内存。</li>\n<li><strong>代码问题</strong>：程序里某些对象被频繁创建，用完后却没有被及时释放，导致内存被一点点蚕食。比如，一个定时任务不断往缓存里塞数据，但从来没清理过，时间一长，内存就被塞满了。</li>\n</ol>\n<p><strong>三、OOM 都有哪些“变种”？</strong></p>\n<p><strong>1. Java 堆内存溢出</strong></p>\n<p>这是 OOM 最常见的形式，错误信息是<code>java.lang.OutOfMemoryError: Java heap space </code>。堆内存是 JVM 里存放对象实例的地方，如果堆内存满了，垃圾回收器又没办法清理出足够的空间，就会触发这个错误。</p>\n<p><strong>2. 永久代&#x2F;元空间溢出</strong></p>\n<p>在 JDK 7 及以下版本里，有永久代（PermGen），用于存放类的元数据、常量池等信息。如果应用加载了大量类（比如使用了动态代理、字节码操作等技术），永久代很容易被撑爆，抛出  错误。从 JDK 8 开始，永久代被元空间（Metaspace）取代，但原理类似，错误信息也变成了 。</p>\n<p><strong>3. 栈内存溢出</strong></p>\n<p>栈内存是线程私有的，用于存放方法调用的局部变量、操作栈等信息。如果一个方法调用链太深（比如递归调用过深），或者方法里局部变量太多，栈内存就会溢出，抛出 。注意，虽然名字里有“Overflow”，但它本质上也是 OOM 的一种。</p>\n<p><strong>4. 直接内存溢出</strong></p>\n<p>直接内存是 JVM 外的一块内存，通常用于 NIO 操作。如果程序中大量使用 NIO，且没有正确管理直接内存，就会导致直接内存溢出，抛出  错误。</p>\n<p><strong>四、排查 OOM 的“杀手锏”</strong></p>\n<p>当线上服务出现 OOM 时，别慌，我们有这些“杀手锏”：</p>\n<p><strong>1. 启用 JVM 诊断选项</strong></p>\n<p>在启动应用时，加上这些参数：</p>\n<p>-XX:+HeapDumpOnOutOfMemoryError -XX:HeapDumpPath&#x3D;&#x2F;path&#x2F;to&#x2F;dump -Xlog:gc* (JVM 9 及以上) -XX:+PrintGCDetails -Xloggc:&#x2F;path&#x2F;to&#x2F;gc.log (JVM 8 及以下)</p>\n<p>这些参数可以让 JVM 在 OOM 时生成内存堆转储文件和 GC 日志，帮助我们分析问题。</p>\n<p><strong>2. 分析错误日志</strong></p>\n<p>仔细查看应用日志和 OOM 错误堆栈信息，看看是哪个内存区域出了问题。</p>\n<p><strong>3. 分析堆转储文件</strong></p>\n<p>用 JVisualVM、Eclipse MAT、JProfiler 这些工具打开堆转储文件，找出内存占用大户，看看是不是有内存泄漏。</p>\n<p><strong>4. 检查 GC 日志</strong></p>\n<p>分析 GC 日志，看看垃圾回收的频率、暂停时间和各内存区的使用情况，判断是不是垃圾回收出了问题。</p>\n<p><strong>5. 代码审查和优化</strong></p>\n<p>从代码层面找原因，看看是不是有缓存没清理、静态集合不断增长等内存泄漏问题。发现问题后，优化代码，减少对象创建，及时释放内存。</p>\n<p><strong>五、解决 OOM 的“锦囊妙计”</strong></p>\n<p><strong>1. 增加内存</strong></p>\n<ul>\n<li><strong>堆内存</strong>：用 -Xmx 参数增加最大堆内存，比如 -Xmx2g。</li>\n<li><strong>永久代&#x2F;元空间</strong>：用 -XX:MaxPermSize（JDK 7 及以下）或 -XX:MaxMetaspaceSize（JDK 8 及以上）增加大小。</li>\n<li><strong>直接内存</strong>：用 -XX:MaxDirectMemorySize 参数增加直接内存大小。</li>\n</ul>\n<p><strong>2. 优化代码</strong></p>\n<ul>\n<li><strong>释放对象</strong>：确保用完的对象能被垃圾回收，比如把不用的缓存清掉。</li>\n<li><strong>避免大对象</strong>：能不用大对象就不用，实在要用，也尽量拆分成小块。</li>\n<li><strong>用弱引用&#x2F;软引用</strong>：比如缓存可以用 WeakHashMap 或 SoftReference，避免内存泄漏。</li>\n</ul>\n<p><strong>3. 调优垃圾回收器</strong></p>\n<p>根据应用的特点，选择合适的 GC 算法（比如 G1、CMS），并调整参数，比如 。</p>\n<p><strong>4. 管理外部资源</strong></p>\n<p>确保文件句柄、数据库连接等外部资源用完后能正确关闭，别让它们占着内存不放。</p>\n<p><strong>5. 持续监控和预警</strong></p>\n<p>用 JMX、Prometheus、Grafana 等工具实时监控 JVM 内存使用情况，一旦发现异常，立刻报警，提前解决问题。</p>\n<p><strong>六、实战案例分析</strong></p>\n<p><strong>案例一：大数据量处理导致堆内存不足</strong></p>\n<p><strong>症状</strong>：应用处理大数据量时，抛出 。</p>\n<p><strong>排查</strong>：</p>\n<ul>\n<li>启用 GC 日志和堆转储选项。</li>\n<li>分析 GC 日志，发现 Full GC 频繁，但内存还是不够用。</li>\n<li>用 JVisualVM 分析堆转储文件，发现大量大对象占用了内存。</li>\n</ul>\n<p><strong>解决</strong>：</p>\n<ul>\n<li>优化算法，减少内存占用。</li>\n<li>通过 -Xmx 增加堆内存。</li>\n<li>改进数据处理流程，比如用流式处理，减少内存峰值。</li>\n</ul>\n<p><strong>案例二：动态类生成导致元空间不足</strong></p>\n<p><strong>症状</strong>：动态生成类时，抛出 。</p>\n<p><strong>排查</strong>：</p>\n<ul>\n<li>启用堆转储和 GC 日志选项。</li>\n<li>分析 GC 日志，发现元空间增长飞快，类加载频繁。</li>\n<li>用工具查看元空间内容，发现大量动态生成的类没被卸载。</li>\n</ul>\n<p><strong>解决</strong>：</p>\n<ul>\n<li>通过 -XX:MaxMetaspaceSize 增加元空间大小。</li>\n<li>优化动态类生成逻辑，减少不必要的类加载。</li>\n</ul>\n<p><strong>案例三：递归调用过深导致栈内存不足</strong></p>\n<p><strong>症状</strong>：递归调用抛出 。</p>\n<p><strong>排查</strong>：分析错误堆栈，发现递归调用深度太大。</p>\n<p><strong>解决</strong>：</p>\n<ul>\n<li>改用迭代算法替代递归。</li>\n<li>优化算法，减少递归深度。</li>\n</ul>\n<p><strong>七、总结</strong></p>\n<p>JVM OOM 是一个复杂但常见的问题，它可能出现在堆内存、永久代&#x2F;元空间、栈内存或直接内存等区域。排查 OOM 的关键在于启用诊断选项（如堆转储和 GC 日志）、分析错误日志和堆转储文件、检查垃圾回收日志。解决 OOM 的方法包括增加内存、优化代码、调优垃圾回收器参数和管理外部资源。持续监控和预警机制可以有效预防 OOM 问题的发生。</p>\n<h2 id=\"AI-回答\"><a href=\"#AI-回答\" class=\"headerlink\" title=\"AI 回答\"></a>AI 回答</h2><p>当 Java 应用程序发生 <strong>堆内存溢出（Heap OOM）</strong> 时，JVM 会抛出以下错误信息：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">java.lang.OutOfMemoryError: Java heap space</code></pre>\n\n<p>这是最常见的 OOM 类型，表示堆内存不足以容纳新创建的对象，且垃圾回收器（GC）无法回收足够的空间。</p>\n<hr>\n<h3 id=\"原因分析\"><a href=\"#原因分析\" class=\"headerlink\" title=\"原因分析\"></a><strong>原因分析</strong></h3><ol>\n<li><p><strong>内存泄漏（Memory Leak）</strong>  </p>\n<ul>\n<li>对象被无意中保留（如静态集合、缓存未清理、未关闭资源等），导致 GC 无法回收。</li>\n<li>例如：<code>static Map</code> 持续添加数据但未移除。</li>\n</ul>\n</li>\n<li><p><strong>合理的内存需求超出堆限制</strong>  </p>\n<ul>\n<li>应用需要处理的数据量确实超过 JVM 堆内存配置（如 <code>-Xmx</code> 设置过小）。</li>\n</ul>\n</li>\n<li><p><strong>代码设计问题</strong>  </p>\n<ul>\n<li>一次性加载大量数据到内存（如大文件、数据库查询结果未分页）。</li>\n<li>死循环或高频创建大对象。</li>\n</ul>\n</li>\n</ol>\n<hr>\n<h3 id=\"解决步骤\"><a href=\"#解决步骤\" class=\"headerlink\" title=\"解决步骤\"></a><strong>解决步骤</strong></h3><h4 id=\"1-确认错误信息\"><a href=\"#1-确认错误信息\" class=\"headerlink\" title=\"1. 确认错误信息\"></a><strong>1. 确认错误信息</strong></h4><p>检查日志，明确错误类型是否为 <code>Java heap space</code>。例如：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">Exception in thread &quot;main&quot; java.lang.OutOfMemoryError: Java heap space</code></pre>\n\n<hr>\n<h4 id=\"2-生成堆转储文件（Heap-Dump）\"><a href=\"#2-生成堆转储文件（Heap-Dump）\" class=\"headerlink\" title=\"2. 生成堆转储文件（Heap Dump）\"></a><strong>2. 生成堆转储文件（Heap Dump）</strong></h4><p>在 JVM 启动参数中添加以下选项，使 OOM 时自动生成堆转储：</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">-XX:+HeapDumpOnOutOfMemoryError -XX:HeapDumpPath&#x3D;&#x2F;path&#x2F;to&#x2F;dump.hprof</code></pre>\n<p>或通过命令手动生成：</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">jmap -dump:format&#x3D;b,file&#x3D;dump.hprof &lt;pid&gt;</code></pre>\n\n<hr>\n<h4 id=\"3-分析堆转储文件\"><a href=\"#3-分析堆转储文件\" class=\"headerlink\" title=\"3. 分析堆转储文件\"></a><strong>3. 分析堆转储文件</strong></h4><p>使用工具分析内存占用，定位泄漏对象：</p>\n<ul>\n<li><strong>Eclipse Memory Analyzer (MAT)</strong>  <ul>\n<li>打开 <code>dump.hprof</code>，查看 <strong>Dominator Tree</strong> 或 <strong>Leak Suspects Report</strong>，找到占用内存最大的对象。</li>\n</ul>\n</li>\n<li><strong>VisualVM</strong>  <ul>\n<li>监控堆内存使用趋势，检查大对象或持续增长的对象。</li>\n</ul>\n</li>\n</ul>\n<hr>\n<h4 id=\"4-检查代码\"><a href=\"#4-检查代码\" class=\"headerlink\" title=\"4. 检查代码\"></a><strong>4. 检查代码</strong></h4><p>根据分析结果修复问题：</p>\n<ul>\n<li><strong>内存泄漏</strong>  <ul>\n<li>清理无用的静态集合、关闭资源（如数据库连接、流）。</li>\n<li>使用弱引用（<code>WeakReference</code>）或缓存框架（如 Ehcache、Guava Cache）管理缓存。</li>\n</ul>\n</li>\n<li><strong>代码优化</strong>  <ul>\n<li>分页处理大数据集，避免一次性加载。</li>\n<li>减少大对象的创建频率（如重用对象池）。</li>\n</ul>\n</li>\n</ul>\n<hr>\n<h4 id=\"5-调整-JVM-堆参数\"><a href=\"#5-调整-JVM-堆参数\" class=\"headerlink\" title=\"5. 调整 JVM 堆参数\"></a><strong>5. 调整 JVM 堆参数</strong></h4><p>如果堆内存不足是合理的业务需求导致，增大堆大小：</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"># 示例：设置最大堆为 4GB\njava -Xmx4g -Xms4g -jar app.jar</code></pre>\n<ul>\n<li><strong>注意</strong>：盲目增大堆可能掩盖内存泄漏问题，需结合分析结果。</li>\n</ul>\n<hr>\n<h4 id=\"6-监控与调优\"><a href=\"#6-监控与调优\" class=\"headerlink\" title=\"6. 监控与调优\"></a><strong>6. 监控与调优</strong></h4><ul>\n<li><strong>实时监控工具</strong>  <ul>\n<li><code>jstat -gc &lt;pid&gt;</code>：查看 GC 频率和耗时。</li>\n<li><code>jconsole</code> 或 <code>VisualVM</code>：图形化监控堆内存和 GC 活动。</li>\n</ul>\n</li>\n<li><strong>垃圾回收器调优</strong>  <ul>\n<li>根据场景选择 GC 算法（如 G1、ZGC 适合大堆低延迟场景）。</li>\n</ul>\n</li>\n</ul>\n<hr>\n<h3 id=\"示例场景\"><a href=\"#示例场景\" class=\"headerlink\" title=\"示例场景\"></a><strong>示例场景</strong></h3><p>假设分析发现 <code>static Map</code> 未清理导致泄漏：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class LeakExample &#123;\n    private static Map&lt;String, Object&gt; cache &#x3D; new HashMap&lt;&gt;();\n\n    public void addToCache(String key, Object value) &#123;\n        cache.put(key, value); &#x2F;&#x2F; 数据持续添加，但未移除\n    &#125;\n&#125;</code></pre>\n<p><strong>修复方案</strong>：</p>\n<ul>\n<li>定期清理 <code>cache</code> 或使用 <code>WeakHashMap</code>。</li>\n<li>限制缓存大小（如 LRU 策略）。</li>\n</ul>\n<hr>\n<h3 id=\"预防措施\"><a href=\"#预防措施\" class=\"headerlink\" title=\"预防措施\"></a><strong>预防措施</strong></h3><ol>\n<li>代码审查时关注静态集合、缓存、资源关闭逻辑。</li>\n<li>使用 <code>-Xmx</code> 合理配置堆内存，避免过小或过大。</li>\n<li>生产环境中启用堆转储和监控告警（如 Prometheus + Grafana）。</li>\n</ol>\n<p>通过上述步骤，可以定位并解决大多数堆内存溢出问题。</p>\n","feature":true,"text":"增加内存、优化代码、调优垃圾回收器参数和管理外部资源...","link":"","photos":[],"count_time":{"symbolsCount":"4.4k","symbolsTime":"4 mins."},"categories":[{"name":"编程","slug":"编程","count":16,"path":"api/categories/编程.json"}],"tags":[{"name":"JVM","slug":"JVM","count":1,"path":"api/tags/JVM.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E7%BA%BF%E4%B8%8AJVM-OOM%E9%97%AE%E9%A2%98%EF%BC%8C%E5%A6%82%E4%BD%95%E6%8E%92%E6%9F%A5%E5%92%8C%E8%A7%A3%E5%86%B3\"><span class=\"toc-text\">线上JVM OOM问题，如何排查和解决</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%8A%80%E6%9C%AF%E6%96%87%E7%AB%A0\"><span class=\"toc-text\">技术文章</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#AI-%E5%9B%9E%E7%AD%94\"><span class=\"toc-text\">AI 回答</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%8E%9F%E5%9B%A0%E5%88%86%E6%9E%90\"><span class=\"toc-text\">原因分析</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E8%A7%A3%E5%86%B3%E6%AD%A5%E9%AA%A4\"><span class=\"toc-text\">解决步骤</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#1-%E7%A1%AE%E8%AE%A4%E9%94%99%E8%AF%AF%E4%BF%A1%E6%81%AF\"><span class=\"toc-text\">1. 确认错误信息</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#2-%E7%94%9F%E6%88%90%E5%A0%86%E8%BD%AC%E5%82%A8%E6%96%87%E4%BB%B6%EF%BC%88Heap-Dump%EF%BC%89\"><span class=\"toc-text\">2. 生成堆转储文件（Heap Dump）</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#3-%E5%88%86%E6%9E%90%E5%A0%86%E8%BD%AC%E5%82%A8%E6%96%87%E4%BB%B6\"><span class=\"toc-text\">3. 分析堆转储文件</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#4-%E6%A3%80%E6%9F%A5%E4%BB%A3%E7%A0%81\"><span class=\"toc-text\">4. 检查代码</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#5-%E8%B0%83%E6%95%B4-JVM-%E5%A0%86%E5%8F%82%E6%95%B0\"><span class=\"toc-text\">5. 调整 JVM 堆参数</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#6-%E7%9B%91%E6%8E%A7%E4%B8%8E%E8%B0%83%E4%BC%98\"><span class=\"toc-text\">6. 监控与调优</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E7%A4%BA%E4%BE%8B%E5%9C%BA%E6%99%AF\"><span class=\"toc-text\">示例场景</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E9%A2%84%E9%98%B2%E6%8E%AA%E6%96%BD\"><span class=\"toc-text\">预防措施</span></a></li></ol></li></ol></li></ol>","author":{"name":"Dxc","slug":"blog-author","avatar":"/images/avatar.png","link":"/","description":"Free will is not free. <br /> @ <b>公众号：精准拔草</b>","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{},"next_post":{"title":"文案整理","uid":"3ede5db1f2dfd6645b710a2389815e97","slug":"文章整理","date":"2024-08-14T14:09:53.000Z","updated":"2025-03-02T13:05:01.020Z","comments":true,"path":"api/articles/文章整理.json","keywords":null,"cover":"/images/ziranshengzhang.jpg","text":"回头看，轻舟已过万重山；向前看，前路漫漫亦灿灿。...","link":"","photos":[],"count_time":{"symbolsCount":"24k","symbolsTime":"22 mins."},"categories":[{"name":"成长","slug":"成长","count":2,"path":"api/categories/成长.json"}],"tags":[{"name":"文章整理","slug":"文章整理","count":2,"path":"api/tags/文章整理.json"}],"author":{"name":"Dxc","slug":"blog-author","avatar":"/images/avatar.png","link":"/","description":"Free will is not free. <br /> @ <b>公众号：精准拔草</b>","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"feature":true}}